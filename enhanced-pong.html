<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Enhanced Pong game with AI, analytics, tournaments, mobile optimization, and accessibility - Version 1.7.0">
    <meta name="keywords" content="pong, enhanced, game, ai, multiplayer, sound, effects">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2a5298">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Enhanced Pong">
    
    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="../icons/icon-128x128.png">
    <link rel="apple-touch-icon" href="../icons/icon-192x192.png">
    <link rel="manifest" href="../manifest.json">
    
    <title>Enhanced Pong Game - Ultimate Edition</title>
    
    <!-- Chart.js for Analytics Dashboard -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <!-- Socket.io Client for Real-time Multiplayer -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="version-manager.js"></script>
</head>
    <style>
        :root {
            --primary-color: #4ecdc4;
            --secondary-color: #ff6b6b;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .game-container {
            position: relative;
            text-align: center;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            padding: 10px;
        }

        #gameCanvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: #000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            font-family: Arial, sans-serif;
        }

        .menu-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 20px;
            color: white;
            pointer-events: auto;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 40px rgba(78,205,196,0.6), 0 0 80px rgba(78,205,196,0.3);
            backdrop-filter: blur(15px);
            max-width: min(600px, 90vw);
            max-height: 90vh;
            overflow-y: auto;
            word-wrap: break-word;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .menu-panel.slide-out {
            animation: slideOut 0.3s ease-in forwards;
        }
        
        @keyframes slideOut {
            from {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            to {
                opacity: 0;
                transform: translate(-50%, -40%) scale(0.95);
            }
        }

        .menu-btn {
            background: linear-gradient(45deg, var(--primary-color), #44a08d);
            border: none;
            color: white;
            padding: 14px 24px;
            margin: 6px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            min-width: 160px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 15px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 25px rgba(78,205,196,0.5), 0 4px 10px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }
        
        .menu-btn:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 0 4px 15px rgba(78,205,196,0.4);
        }

        .menu-btn.secondary {
            background: linear-gradient(45deg, #6c7b7f, #4a5759);
        }

        .menu-btn.secondary:hover {
            box-shadow: 0 8px 25px rgba(108,123,127,0.4), 0 4px 10px rgba(0,0,0,0.3);
        }

        .game-modes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin: 20px 0;
            justify-items: center;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            text-align: left;
        }

        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .setting-item label {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-item input[type="range"] {
            width: 120px;
        }

        .setting-item select {
            padding: 5px;
            border-radius: 5px;
            min-width: 120px;
        }

        #inGameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: white;
            font-size: 16px;
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        .ui-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ui-controls {
            pointer-events: auto;
        }

        .ui-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 5px;
            font-size: 12px;
        }

        .ui-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin: 20px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .stats-section {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }
        
        .stats-section h3 {
            margin: 0 0 12px 0;
            font-size: 18px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .stats-item:last-child {
            border-bottom: none;
        }
        
        .stats-label {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
        }
        
        .stats-value {
            font-weight: bold;
            font-size: 14px;
            color: var(--secondary-color);
        }
        
        .stats-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .stats-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 0.3s ease;
        }
        
        .achievement-badge {
            display: inline-block;
            background: rgba(255,215,0,0.2);
            color: #ffd700;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin: 2px;
            border: 1px solid rgba(255,215,0,0.3);
        }
        
        /* Analytics Dashboard Styles */
        .analytics-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .chart-container {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            position: relative;
            min-height: 300px;
        }
        
        .chart-container h4 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chart-wrapper {
            position: relative;
            height: 250px;
            width: 100%;
        }
        
        .chart-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .chart-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .chart-btn:hover, .chart-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }
        
        /* Tournament Bracket Styles */
        .tournament-info {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .tournament-header {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .tournament-settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            font-size: 12px;
        }
        
        .tournament-bracket {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            min-height: 300px;
            overflow-x: auto;
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .bracket-round {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            min-width: 180px;
            margin: 0 10px;
        }
        
        .bracket-container {
            display: flex;
            align-items: center;
            min-height: 300px;
        }
        
        .bracket-match {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .bracket-match:hover {
            background: rgba(255,255,255,0.15);
            border-color: var(--primary-color);
        }
        
        .bracket-match.completed {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--primary-color);
        }
        
        .bracket-match.current {
            background: rgba(255, 107, 107, 0.2);
            border-color: var(--secondary-color);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.4);
        }
        
        .bracket-player {
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
        }
        
        .bracket-player.winner {
            background: rgba(78, 205, 196, 0.3);
            color: var(--primary-color);
        }
        
        .bracket-player.loser {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.6);
        }
        
        .bracket-connector {
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 15px;
            height: 2px;
            background: var(--primary-color);
        }
        
        .bracket-connector.vertical {
            width: 2px;
            height: 40px;
            right: -8px;
        }
        
        .round-label {
            text-align: center;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tournament-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tournament-preview {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .tournament-preview h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .preview-round {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 13px;
        }
        
        .preview-round:last-child {
            border-bottom: none;
        }
        
        .ai-personality-badge {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 8px;
        }
        
        .difficulty-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 4px;
        }
        
        .difficulty-easy { background-color: #4CAF50; }
        .difficulty-medium { background-color: #FF9800; }
        .difficulty-hard { background-color: #F44336; }
        .difficulty-expert { background-color: #9C27B0; }
        
        .no-data-message {
            text-align: center;
            color: rgba(255,255,255,0.7);
            font-style: italic;
            padding: 40px 20px;
        }

        .theme-neon { background: linear-gradient(135deg, #1e3c72, #2a5298); }
        .theme-retro { background: linear-gradient(135deg, #2d1b69, #11998e); }
        .theme-classic { background: linear-gradient(135deg, #000000, #434343); }
        .theme-cyberpunk { background: linear-gradient(135deg, #0f0f0f, #1a0033); }
        .theme-synthwave { background: linear-gradient(135deg, #2d1b4e, #ff006e, #8338ec); }
        .theme-ocean { background: linear-gradient(135deg, #0f3460, #16537e, #005c98); }
        .theme-forest { background: linear-gradient(135deg, #0f2027, #203a43, #2c5530); }
        .theme-sunset { background: linear-gradient(135deg, #f2994a, #f2c94c, #eb5757); }
        .theme-galaxy { background: linear-gradient(135deg, #1a0033, #330066, #660099); }
        .theme-volcanic { background: linear-gradient(135deg, #1a0000, #cc0000, #ff3300); }
        .theme-arctic { background: linear-gradient(135deg, #e6f7ff, #b3e5fc, #81d4fa); color: #000000; }
        .theme-matrix { background: linear-gradient(135deg, #000000, #003300, #006600); }
        .theme-crimson { background: linear-gradient(135deg, #330000, #660000, #990000); }
        .theme-highcontrast { background: linear-gradient(135deg, #ffffff, #f0f0f0); color: #000000; }
        .theme-protanopia { background: linear-gradient(135deg, #0066cc, #004499); }
        .theme-deuteranopia { background: linear-gradient(135deg, #cc6600, #994400); }
        .theme-midnight { background: linear-gradient(135deg, #000428, #004e92); }
        .theme-aurora-green { background: linear-gradient(135deg, #00f260, #0575e6); }
        .theme-rose-gold { background: linear-gradient(135deg, #f093fb, #f5576c); }
        .theme-deep-space { background: linear-gradient(135deg, #0c0c0c, #1a0033, #4a0080); }
        .theme-golden-hour { background: linear-gradient(135deg, #ff9a9e, #fecfef, #fecfef); }
        .theme-electric-blue { background: linear-gradient(135deg, #667eea, #764ba2); }
        .theme-emerald { background: linear-gradient(135deg, #11998e, #38ef7d); }
        .theme-cosmic-purple { background: linear-gradient(135deg, #667db6, #0082c8, #0082c8, #667db6); }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .game-container {
                padding: 5px;
            }
            
            .menu-panel {
                padding: 20px;
                max-width: 95vw;
                font-size: 14px;
            }
            
            .menu-btn {
                min-width: 140px;
                padding: 16px 20px;
                font-size: 14px;
                margin: 4px;
                /* Larger touch targets for mobile */
                min-height: 48px;
            }
            
            .game-modes {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .settings-grid {
                gap: 12px;
            }
            
            .setting-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .setting-item input[type="range"] {
                width: 100%;
            }
            
            .setting-item select {
                width: 100%;
                min-width: auto;
                padding: 8px;
            }
            
            #gameCanvas {
                width: 100%;
                max-width: 100vw;
                height: auto;
            }
        }
        
        @media (max-width: 480px) {
            .menu-panel {
                padding: 15px;
                border-radius: 15px;
            }
            
            .menu-btn {
                min-width: 120px;
                padding: 14px 16px;
                font-size: 13px;
            }
            
            .game-modes {
                gap: 8px;
            }
        }
        
        /* Touch device improvements */
        @media (hover: none) and (pointer: coarse) {
            .menu-btn:hover {
                transform: none;
                box-shadow: none;
                filter: none;
            }
            
            .menu-btn:active {
                transform: scale(0.95);
                opacity: 0.8;
            }
        }
        
        /* High DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            #gameCanvas {
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
            }
        }
        
        /* Enhanced Mobile Styles */
        .mobile-device {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-device .menu-btn {
            min-height: 56px; /* Larger touch targets */
            padding: 18px 24px;
            font-size: 16px;
            line-height: 1.2;
        }
        
        /* Orientation-specific styles */
        .landscape .game-container {
            padding: 0;
        }
        
        .landscape #gameCanvas {
            width: 100vw;
            height: auto;
            max-height: 80vh;
        }
        
        .portrait .menu-panel {
            max-height: 85vh;
            overflow-y: auto;
        }
        
        /* Mobile control hints */
        .mobile-hint {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 250px;
            font-size: 13px;
            border: 2px solid var(--primary-color);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .hint-content p {
            margin: 5px 0;
        }
        
        .hint-close {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
        }
        
        /* Accessibility enhancements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Focus indicators */
        .menu-btn:focus-visible {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .menu-btn {
                border: 2px solid white;
                background: black;
                color: white;
            }
            
            .menu-panel {
                border: 3px solid white;
                background: black;
            }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .menu-btn {
                transform: none !important;
            }
            
            .menu-btn:hover {
                transform: none !important;
            }
        }
        
        /* Large text support */
        @media (min-width: 320px) and (max-width: 768px) and (orientation: portrait) {
            .mobile-device.large-text .menu-btn {
                font-size: 18px;
                min-height: 60px;
                padding: 20px 28px;
            }
            
            .mobile-device.large-text .menu-panel {
                font-size: 16px;
            }
        }
        
        /* Touch-friendly analytics dashboard */
        @media (max-width: 768px) {
            .analytics-dashboard {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .chart-container {
                min-height: 250px;
                padding: 15px;
            }
            
            .chart-btn {
                min-height: 44px;
                padding: 8px 12px;
                font-size: 14px;
            }
        }
        
        /* Mobile tournament bracket enhancements */
        @media (max-width: 768px) {
            .tournament-bracket {
                padding: 10px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }
            
            .bracket-match {
                min-height: 70px;
                padding: 8px;
                margin: 6px 0;
                font-size: 12px;
                min-width: 160px;
            }
            
            .bracket-player {
                padding: 6px 8px;
                font-size: 12px;
            }
            
            .round-label {
                font-size: 12px;
                margin-bottom: 10px;
            }
        }
        
        /* Performance optimization classes */
        .reduced-quality .particle-system {
            display: none;
        }
        
        .reduced-quality .background-effect {
            opacity: 0.3;
        }
        
        /* Voice control indicator */
        .voice-control-active {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .voice-control-active::before {
            content: '🎤 ';
        }
        
        /* Online Multiplayer Styles */
        .connection-status-bar {
            display: flex;
            justify-content: space-between;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .status-item {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
        }
        
        .connection-status {
            font-weight: 600;
        }
        
        .connection-status.ready, .connection-status.connected {
            color: #4ecdc4;
        }
        
        .connection-status.hosting {
            color: #f9ca24;
        }
        
        .connection-status.connecting {
            color: #f0932b;
        }
        
        .connection-status.disconnected {
            color: #eb4d4b;
        }
        
        .multiplayer-options {
            display: grid;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .option-group {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .option-group h4 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .player-card {
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            min-width: 120px;
        }
        
        .player-card h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
        }
        
        .vs-indicator {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .player-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-size: 14px;
        }
        
        .multiplayer-help {
            margin: 20px 0;
        }
        
        .multiplayer-help details {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 15px;
        }
        
        .multiplayer-help summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 10px;
        }
        
        .help-content {
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .help-content ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .help-content li {
            margin-bottom: 8px;
        }
        
        /* Mobile responsive for multiplayer */
        @media (max-width: 768px) {
            .connection-status-bar {
                flex-direction: column;
                gap: 10px;
            }
            
            .player-info {
                flex-direction: column;
                gap: 10px;
            }
            
            .vs-indicator {
                transform: rotate(90deg);
            }
        }
        
        /* Navigation breadcrumbs */
        .nav-breadcrumb {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 12px;
            opacity: 0.7;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .nav-breadcrumb .separator {
            opacity: 0.5;
        }
        
        /* Menu header improvements */
        .menu-header {
            text-align: center;
            margin-bottom: 25px;
            position: relative;
        }
        
        .menu-title {
            color: var(--primary-color);
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }
        
        .menu-subtitle {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        /* Enhanced form controls */
        .form-group {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .form-group label {
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
            color: rgba(255,255,255,0.9);
        }
        
        .form-group select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .form-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(78,205,196,0.3);
        }
        
        /* Authentication Panel Styles */
        .auth-form {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .form-group input[type="text"],
        .form-group input[type="email"],
        .form-group input[type="password"] {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
            outline: none;
        }
        
        .form-group input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(78,205,196,0.2);
            background: rgba(0,0,0,0.4);
        }
        
        .form-group input:valid {
            border-color: #4CAF50;
        }
        
        .form-group input:invalid:not(:focus):not(:placeholder-shown) {
            border-color: var(--secondary-color);
        }
        
        .password-toggle {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            user-select: none;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .password-toggle:hover {
            opacity: 1;
        }
        
        .form-group {
            position: relative;
        }
        
        .input-hint {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            margin-top: 5px;
            font-style: italic;
        }
        
        .form-actions {
            display: flex;
            gap: 12px;
            margin-top: 25px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .quick-play-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        /* User Profile Section */
        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }
        
        .user-avatar {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }
        
        .user-details h4 {
            margin: 0 0 5px 0;
            color: white;
            font-size: 18px;
        }
        
        .user-details p {
            margin: 0;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
        }
        
        .user-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.2s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-2px);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Auth Messages */
        #authMessages {
            text-align: center;
        }
        
        .auth-message {
            padding: 12px 20px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
            animation: slideDown 0.3s ease-out;
        }
        
        .auth-message.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            color: #81C784;
        }
        
        .auth-message.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.4);
            color: #E57373;
        }
        
        .auth-message.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.4);
            color: #64B5F6;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }
        
        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid var(--primary-color);
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile responsiveness for auth */
        @media (max-width: 768px) {
            .user-stats-grid {
                grid-template-columns: 1fr;
            }
            
            .form-actions {
                flex-direction: column;
            }
            
            .form-actions .menu-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <div id="gameOverlay">
            <!-- Main Menu -->
            <div id="gameMenu" class="menu-panel">
                <div class="menu-header">
                    <h1 class="menu-title">🏓 ENHANCED PONG</h1>
                    <p class="menu-subtitle">Ultimate Edition - Choose your game mode</p>
                </div>
                
                <div class="game-modes">
                    <button class="menu-btn" onclick="startGame('classic')">🎮 Classic</button>
                    <button class="menu-btn" onclick="startGame('speedball')">⚡ Speedball</button>
                    <button class="menu-btn" onclick="startGame('survival')">❤️ Survival</button>
                    <button class="menu-btn" onclick="startGame('tournament')">🏆 Tournament</button>
                    <button class="menu-btn" onclick="showPanel('tournamentBracket')">🏆 Tournament Bracket</button>
                    <button class="menu-btn" onclick="startGame('practice')">🎯 Practice</button>
                    <button class="menu-btn" onclick="startGame('multiplayer')">👥 Local Multiplayer</button>
                    <button class="menu-btn" onclick="showPanel('onlineMultiplayer')">🌐 Online Multiplayer</button>
                </div>
                
                <div class="form-group">
                    <label>🤖 AI Difficulty:</label>
                    <select id="difficultySelect" onchange="changeDifficulty(this.value)">
                        <option value="easy">😊 Easy - Relaxed gameplay</option>
                        <option value="medium" selected>😐 Medium - Balanced challenge</option>
                        <option value="hard">😈 Hard - Intense competition</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>🧠 AI Personality:</label>
                    <select id="personalitySelect" onchange="changePersonality(this.value)">
                        <option value="balanced" selected>⚖️ Balanced - Standard AI behavior</option>
                        <option value="defensive">🛡️ Defensive - Cautious play style</option>
                        <option value="aggressive">⚔️ Aggressive - Fast & attacking</option>
                        <option value="perfect">🎯 Perfect - Near-perfect tracking</option>
                        <option value="unpredictable">🎲 Unpredictable - Random patterns</option>
                        <option value="trickster">🃏 Trickster - Uses fake movements</option>
                        <option value="copycat">🪞 Copycat - Mimics your style</option>
                        <option value="adaptive">🧠 Adaptive - Learns from you</option>
                    </select>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 25px;">
                    <button class="menu-btn secondary" onclick="showAuthenticationUI()">🔐 Account</button>
                    <button class="menu-btn secondary" onclick="showPanel('settings')">⚙️ Settings</button>
                    <button class="menu-btn secondary" onclick="showPanel('stats')">📊 Statistics</button>
                    <button class="menu-btn secondary" onclick="showPanel('help')">❓ Help</button>
                    <button class="menu-btn secondary" onclick="showPanel('about')">ℹ️ About</button>
                </div>
            </div>

            <!-- Settings Panel -->
            <div id="settingsPanel" class="menu-panel" style="display: none;">
                <div class="nav-breadcrumb">
                    <span>🏓 Main Menu</span>
                    <span class="separator">></span>
                    <span>⚙️ Settings</span>
                </div>
                <div class="menu-header">
                    <h1 class="menu-title">⚙️ Settings</h1>
                    <p class="menu-subtitle">Customize your game experience</p>
                </div>
                
                <div class="settings-grid">
                    <div class="setting-item">
                        <label>🔊 Volume: <span id="volumeValue">70%</span></label>
                        <input type="range" id="volumeSlider" min="0" max="100" value="70" oninput="updateVolume(this.value)">
                    </div>
                    
                    <div class="setting-item">
                        <label>🎨 Theme:</label>
                        <select id="themeSelect" onchange="changeTheme(this.value)">
                            <optgroup label="🌟 Popular Themes">
                                <option value="neon" selected>🌈 Neon</option>
                                <option value="cyberpunk">🔮 Cyberpunk</option>
                                <option value="synthwave">🌆 Synthwave</option>
                                <option value="midnight">🌙 Midnight Blue</option>
                                <option value="aurora-green">🌌 Aurora Green</option>
                            </optgroup>
                            <optgroup label="🎯 Classic Styles">
                                <option value="retro">👾 Retro</option>
                                <option value="classic">⚫ Classic</option>
                                <option value="matrix">🟢 Matrix Green</option>
                                <option value="electric-blue">⚡ Electric Blue</option>
                            </optgroup>
                            <optgroup label="🌈 Nature & Elements">
                                <option value="ocean">🌊 Ocean Depths</option>
                                <option value="forest">🌲 Forest Night</option>
                                <option value="sunset">🌅 Sunset Vibes</option>
                                <option value="aurora">🌟 Aurora Borealis</option>
                                <option value="galaxy">🌌 Galaxy</option>
                                <option value="emerald">💚 Emerald</option>
                            </optgroup>
                            <optgroup label="🔥 Intense Themes">
                                <option value="volcanic">🌋 Volcanic</option>
                                <option value="crimson">🔥 Crimson Fire</option>
                                <option value="deep-space">🚀 Deep Space</option>
                                <option value="cosmic-purple">💫 Cosmic Purple</option>
                            </optgroup>
                            <optgroup label="✨ Premium Themes">
                                <option value="rose-gold">🌹 Rose Gold</option>
                                <option value="golden-hour">🌇 Golden Hour</option>
                                <option value="arctic">❄️ Arctic Ice</option>
                            </optgroup>
                            <optgroup label="♿ Accessibility">
                                <option value="highcontrast">⬜ High Contrast</option>
                                <option value="protanopia">🔴 Protanopia Friendly</option>
                                <option value="deuteranopia">🟠 Deuteranopia Friendly</option>
                            </optgroup>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="particlesCheck" checked onchange="toggleParticles(this.checked)"> ✨ Particles</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="shakeCheck" checked onchange="toggleScreenShake(this.checked)"> 📳 Screen Shake</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="trailCheck" checked onchange="toggleBallTrail(this.checked)"> 🔥 Ball Trail</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="muteCheck" onchange="toggleMute(this.checked)"> 🔇 Mute</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="backgroundCheck" checked onchange="toggleBackgroundEffects(this.checked)"> 🌌 Background Effects</label>
                    </div>
                    
                    <div class="setting-item">
                        <label>🎭 Background Type:</label>
                        <select id="backgroundTypeSelect" onchange="changeBackgroundType(this.value)">
                            <option value="particles" selected>✨ Floating Particles</option>
                            <option value="waves">🌊 Animated Waves</option>
                            <option value="geometric">🔷 Geometric Patterns</option>
                            <option value="starfield">⭐ Starfield</option>
                            <option value="pulsing">💫 Pulsing Gradient</option>
                            <option value="matrix">🟢 Matrix Rain</option>
                            <option value="plasma">🌈 Plasma Field</option>
                            <option value="neural">🧠 Neural Network</option>
                            <option value="galaxy">🌌 Spiral Galaxy</option>
                            <option value="lightning">⚡ Lightning Storm</option>
                            <option value="aurora">🌟 Aurora Borealis</option>
                            <option value="circuit">🔌 Circuit Board</option>
                            <option value="honeycomb">🍯 Honeycomb Grid</option>
                            <option value="ripple">💧 Water Ripples</option>
                            <option value="storm">⛈️ Lightning Storm</option>
                        </select>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                    <button class="menu-btn" onclick="saveSettings()">💾 Save</button>
                    <button class="menu-btn secondary" onclick="clearGameCache()">🗑️ Clear Cache</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back</button>
                </div>
            </div>

            <!-- Stats Panel -->
            <div id="statsPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">📊 Statistics</h2>
                <div id="statsContent"></div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                    <button class="menu-btn" onclick="showPanel('analytics')">📊 Analytics Dashboard</button>
                    <button class="menu-btn" onclick="showPanel('heatmap')">🔥 Heat Maps</button>
                    <button class="menu-btn" onclick="showPanel('mlstats')">🧠 ML AI Stats</button>
                    <button class="menu-btn secondary" onclick="clearStats()">🗑️ Clear</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back</button>
                </div>
            </div>
            
            <!-- Heat Map Panel -->
            <div id="heatmapPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">🔥 Heat Map Visualization</h2>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <label>Heat Map Type:</label>
                    <select id="heatmapTypeSelect" onchange="updateHeatMap()" style="padding: 8px; margin: 10px;">
                        <option value="playerHits">🏓 Player Paddle Hits</option>
                        <option value="aiHits">🤖 AI Paddle Hits</option>
                        <option value="ballTrajectory">⚽ Ball Trajectory</option>
                        <option value="playerMovement">🕹️ Player Movement</option>
                        <option value="combined">🌈 Combined View</option>
                    </select>
                </div>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <canvas id="heatmapCanvas" width="400" height="200" style="border: 2px solid var(--primary-color); border-radius: 8px; background: #000;"></canvas>
                </div>
                
                <div style="font-size: 12px; text-align: center; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                        <span>🔵 Low Intensity</span>
                        <div style="width: 100px; height: 8px; background: linear-gradient(90deg, blue, cyan, green, yellow, orange, red); border-radius: 4px;"></div>
                        <span>🔴 High Intensity</span>
                    </div>
                </div>
                
                <div id="heatmapStats" style="font-size: 14px; text-align: left; margin-bottom: 15px;"></div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="menu-btn secondary" onclick="clearHeatMapData()">🗑️ Clear Heat Data</button>
                    <button class="menu-btn secondary" onclick="showPanel('stats')">🔙 Back</button>
                </div>
            </div>

            <!-- ML AI Stats Panel -->
            <div id="mlstatsPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">🧠 Machine Learning AI Statistics</h2>
                <div id="mlstatsContent"></div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="menu-btn secondary" onclick="resetMLAI()">🗑️ Reset ML AI</button>
                    <button class="menu-btn secondary" onclick="showPanel('stats')">🔙 Back</button>
                </div>
            </div>
            
            <!-- Tournament Bracket Panel -->
            <div id="tournamentBracketPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">🏆 Tournament Bracket</h2>
                
                <div class="tournament-info">
                    <div id="tournamentProgress" class="tournament-header"></div>
                    <div id="tournamentSettings" class="tournament-settings"></div>
                </div>
                
                <div id="tournamentBracket" class="tournament-bracket">
                    <!-- Bracket visualization will be dynamically generated -->
                </div>
                
                <div id="tournamentControls" class="tournament-controls">
                    <button class="menu-btn" onclick="startNextTournamentRound()" id="nextRoundBtn" style="display: none;">▶️ Next Round</button>
                    <button class="menu-btn secondary" onclick="saveTournamentProgress()">💾 Save Progress</button>
                    <button class="menu-btn secondary" onclick="customizeTournament()">⚙️ Customize</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back to Menu</button>
                </div>
            </div>
            
            <!-- Tournament Customization Panel -->
            <div id="tournamentCustomizePanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">⚙️ Tournament Settings</h2>
                
                <div class="settings-grid">
                    <div class="setting-item">
                        <label>Tournament Size:</label>
                        <select id="tournamentSize" onchange="updateTournamentPreview()">
                            <option value="4">4 Rounds (Quick)</option>
                            <option value="8" selected>8 Rounds (Standard)</option>
                            <option value="16">16 Rounds (Championship)</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label>Bracket Format:</label>
                        <select id="bracketFormat" onchange="updateTournamentPreview()">
                            <option value="single" selected>Single Elimination</option>
                            <option value="double">Double Elimination</option>
                            <option value="roundrobin">Round Robin</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label>Difficulty Progression:</label>
                        <select id="difficultyProgression">
                            <option value="linear">Linear (Easy → Hard)</option>
                            <option value="adaptive" selected>Adaptive (Based on Performance)</option>
                            <option value="random">Random Mix</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label>AI Personality Selection:</label>
                        <select id="aiPersonalityMode">
                            <option value="progressive" selected>Progressive Difficulty</option>
                            <option value="random">Random Each Round</option>
                            <option value="custom">Custom Selection</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label>Match Length:</label>
                        <select id="matchLength">
                            <option value="3">Best of 3</option>
                            <option value="5">Best of 5</option>
                            <option value="7" selected>Best of 7 (Standard)</option>
                            <option value="9">Best of 9 (Championship)</option>
                        </select>
                    </div>
                </div>
                
                <div id="tournamentPreview" class="tournament-preview">
                    <h4>Tournament Preview:</h4>
                    <div id="previewContent"></div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="menu-btn" onclick="createCustomTournament()">🚀 Start Tournament</button>
                    <button class="menu-btn secondary" onclick="resetTournamentSettings()">🔄 Reset</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back</button>
                </div>
            </div>
            
            <!-- Analytics Dashboard Panel -->
            <div id="analyticsPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">📊 Analytics Dashboard</h2>
                
                <div class="analytics-dashboard">
                    <!-- Performance Trends Chart -->
                    <div class="chart-container">
                        <h4>📈 Performance Trends</h4>
                        <div class="chart-controls">
                            <button class="chart-btn active" data-chart="performance" data-type="winrate">Win Rate</button>
                            <button class="chart-btn" data-chart="performance" data-type="reaction">Reaction Time</button>
                            <button class="chart-btn" data-chart="performance" data-type="consistency">Consistency</button>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="performanceChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Game Distribution Chart -->
                    <div class="chart-container">
                        <h4>🎮 Game Mode Distribution</h4>
                        <div class="chart-wrapper">
                            <canvas id="gameModeChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- AI Personality Stats -->
                    <div class="chart-container">
                        <h4>🤖 AI Personality Performance</h4>
                        <div class="chart-wrapper">
                            <canvas id="aiPersonalityChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Rally Length Distribution -->
                    <div class="chart-container">
                        <h4>🏓 Rally Length Analysis</h4>
                        <div class="chart-wrapper">
                            <canvas id="rallyChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- ML AI Learning Progress -->
                    <div class="chart-container">
                        <h4>🧠 ML AI Learning Progress</h4>
                        <div class="chart-wrapper">
                            <canvas id="mlProgressChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Session Activity -->
                    <div class="chart-container">
                        <h4>⏰ Play Session Activity</h4>
                        <div class="chart-wrapper">
                            <canvas id="sessionChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Tournament Analytics -->
                    <div class="chart-container">
                        <h4>🏆 Tournament Performance</h4>
                        <div class="chart-wrapper">
                            <canvas id="tournamentChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Heat Map Intensity Trends -->
                    <div class="chart-container">
                        <h4>🔥 Heat Map Intensity Over Time</h4>
                        <div class="chart-wrapper">
                            <canvas id="heatMapTrendsChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                    <button class="menu-btn secondary" onclick="exportAnalyticsData()">💾 Export Data</button>
                    <button class="menu-btn secondary" onclick="refreshAnalyticsCharts()">🔄 Refresh Charts</button>
                    <button class="menu-btn secondary" onclick="showPanel('stats')">🔙 Back to Stats</button>
                </div>
            </div>
            
            <!-- Online Multiplayer Panel -->
            <div id="onlineMultiplayerPanel" class="menu-panel" style="display: none;">
                <div class="nav-breadcrumb">
                    <span>🏓 Main Menu</span>
                    <span class="separator">></span>
                    <span>🌐 Online Multiplayer</span>
                </div>
                <div class="menu-header">
                    <h1 class="menu-title">🌐 Online Multiplayer</h1>
                    <p class="menu-subtitle">Play against other players online</p>
                </div>
                
                <div class="connection-status-bar">
                    <div class="status-item">
                        <span>Status: <span id="multiplayerStatus">❌ Disconnected</span></span>
                    </div>
                    <div class="status-item">
                        <span>Ping: <span id="latencyDisplay">--ms</span></span>
                    </div>
                    <div class="status-item">
                        <span>Player: <span id="playerDisplayName">Guest</span></span>
                    </div>
                </div>
                
                <div class="multiplayer-options">
                    <div class="option-group">
                        <h4>🏠 Host a Game</h4>
                        <div class="form-group">
                            <input type="text" id="roomIdInput" placeholder="Enter custom room ID (optional)" maxlength="8">
                            <button class="menu-btn" onclick="createOnlineRoom()" id="createRoomBtn">🏠 Create Room</button>
                        </div>
                        <div id="roomInfo" style="display: none;">
                            <p>Room ID: <strong id="displayRoomId"></strong></p>
                            <p>Share this ID with your friend to join!</p>
                            <button class="menu-btn secondary" onclick="copyRoomId()"📋 Copy Room ID</button>
                        </div>
                    </div>
                    
                    <div class="option-group">
                        <h4>🚪 Join a Game</h4>
                        <div class="form-group">
                            <input type="text" id="joinRoomInput" placeholder="Enter room ID" maxlength="8">
                            <button class="menu-btn" onclick="joinOnlineRoom()" id="joinRoomBtn">🚪 Join Room</button>
                        </div>
                    </div>
                    
                    <div class="option-group" id="gameReadySection" style="display: none;">
                        <h4>✅ Ready to Play</h4>
                        <div class="player-info">
                            <div class="player-card">
                                <h5>You</h5>
                                <span id="yourPlayerName">Player 1</span>
                            </div>
                            <div class="vs-indicator">VS</div>
                            <div class="player-card">
                                <h5>Opponent</h5>
                                <span id="opponentPlayerName">Waiting...</span>
                            </div>
                        </div>
                        <button class="menu-btn" onclick="startOnlineMatch()" id="startMatchBtn">🎮 Start Match</button>
                    </div>
                    
                    <div class="option-group">
                        <h4>👤 Player Profile</h4>
                        <div class="form-group">
                            <label>Display Name:</label>
                            <input type="text" id="displayNameInput" placeholder="Enter your name" maxlength="20">
                            <button class="menu-btn secondary" onclick="updatePlayerProfile()">💾 Save</button>
                        </div>
                        <div class="player-stats">
                            <div class="stat-item">
                                <span>Games Played: <span id="onlineGamesPlayed">0</span></span>
                            </div>
                            <div class="stat-item">
                                <span>Games Won: <span id="onlineGamesWon">0</span></span>
                            </div>
                            <div class="stat-item">
                                <span>Rating: <span id="playerRating">1200</span></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="multiplayer-help">
                    <details>
                        <summary>❓ How to Play Online</summary>
                        <div class="help-content">
                            <ol>
                                <li><strong>Host:</strong> Create a room and share the Room ID with your friend</li>
                                <li><strong>Join:</strong> Enter your friend's Room ID and click Join</li>
                                <li><strong>Play:</strong> Once connected, the host can start the match</li>
                                <li><strong>Controls:</strong> Same as local multiplayer - mouse/touch controls</li>
                            </ol>
                            <p><strong>Note:</strong> Both players need a stable internet connection for the best experience.</p>
                        </div>
                    </details>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                    <button class="menu-btn secondary" onclick="disconnectMultiplayer()" id="disconnectBtn">❌ Disconnect</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back to Menu</button>
                </div>
            </div>
            
            <!-- Help Panel -->
            <div id="helpPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">❓ Help</h2>
                <div style="text-align: left; font-size: 14px;">
                    <h3>🎮 Controls</h3>
                    <p>• <strong>Mouse/Touch:</strong> Move paddle up/down</p>
                    <p>• <strong>Multiplayer:</strong> W/S vs Arrow Keys</p>
                    
                    <h3>🎯 Game Modes</h3>
                    <p>• <strong>Classic:</strong> Traditional Pong</p>
                    <p>• <strong>Speedball:</strong> Increasing speed</p>
                    <p>• <strong>Survival:</strong> Limited lives</p>
                    <p>• <strong>Tournament:</strong> 5-round championship with rankings</p>
                    <p>• <strong>Practice:</strong> No scoring</p>
                    <p>• <strong>Multiplayer:</strong> Two players</p>
                    
                    <h3>🤖 AI Personalities</h3>
                    <p>• <strong>Balanced:</strong> Standard AI behavior</p>
                    <p>• <strong>Defensive:</strong> Cautious, center-focused play</p>
                    <p>• <strong>Aggressive:</strong> Fast & predictive attacks</p>
                    <p>• <strong>Perfect:</strong> Near-perfect ball tracking</p>
                    <p>• <strong>Unpredictable:</strong> Random movement patterns</p>
                    <p>• <strong>Trickster:</strong> Uses fake movements to confuse</p>
                    <p>• <strong>Copycat:</strong> Mimics your play style</p>
                    <p>• <strong>Adaptive:</strong> Learns and adapts to you</p>
                </div>
                <button class="menu-btn secondary" onclick="showPanel('menu')" style="margin-top: 15px;">🔙 Back</button>
            </div>
            
            <!-- About Panel -->
            <div id="aboutPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">ℹ️ About Enhanced Pong</h2>
                
                <div id="aboutContent">
                    <!-- Content will be dynamically loaded by version-manager.js -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h3 style="color: var(--secondary-color); margin-bottom: 5px;">🎮 Enhanced Pong - Ultimate Edition</h3>
                        <p style="margin: 5px 0; color: #aaa;">Loading version information...</p>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="menu-btn secondary" onclick="showPanel('help')">❓ Help</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back</button>
                </div>
            </div>
            
            <!-- Authentication Panel -->
            <div id="authPanel" class="menu-panel" style="display: none;">
                <div class="nav-breadcrumb">
                    <span>🏓 Main Menu</span>
                    <span class="separator">></span>
                    <span>🔐 Account</span>
                </div>
                <div class="menu-header">
                    <h1 class="menu-title">🔐 Account Login</h1>
                    <p class="menu-subtitle">Sign in to play online multiplayer</p>
                </div>
                
                <!-- Connection Status -->
                <div class="connection-status-bar" style="margin-bottom: 20px;">
                    <div class="status-item">
                        <span>Server: <span id="authServerStatus">🔄 Connecting...</span></span>
                    </div>
                </div>
                
                <!-- Auth Form Container -->
                <div id="authFormContainer">
                    <!-- Login Form -->
                    <div id="loginForm" class="auth-form">
                        <h3 style="color: var(--primary-color); margin-bottom: 20px; text-align: center;">🚪 Sign In</h3>
                        
                        <div class="form-group">
                            <label for="loginUsername">👤 Username:</label>
                            <input type="text" id="loginUsername" placeholder="Enter your username" maxlength="20" autocomplete="username">
                        </div>
                        
                        <div class="form-group">
                            <label for="loginPassword">🔒 Password:</label>
                            <input type="password" id="loginPassword" placeholder="Enter your password" autocomplete="current-password">
                            <div class="password-toggle" onclick="togglePasswordVisibility('loginPassword')">
                                <span id="loginPasswordToggle">👁️</span>
                            </div>
                        </div>
                        
                        <div class="form-actions">
                            <button class="menu-btn" onclick="performLogin()" id="loginBtn">
                                <span id="loginBtnText">🔐 Sign In</span>
                            </button>
                            <button class="menu-btn secondary" onclick="showRegisterForm()">
                                📝 Create Account
                            </button>
                        </div>
                        
                        <div class="quick-play-section">
                            <p style="text-align: center; margin: 15px 0; opacity: 0.7;">or</p>
                            <button class="menu-btn secondary" onclick="quickPlayAsGuest()">
                                🚀 Quick Play as Guest
                            </button>
                        </div>
                    </div>
                    
                    <!-- Registration Form -->
                    <div id="registerForm" class="auth-form" style="display: none;">
                        <h3 style="color: var(--primary-color); margin-bottom: 20px; text-align: center;">📝 Create Account</h3>
                        
                        <div class="form-group">
                            <label for="registerUsername">👤 Username:</label>
                            <input type="text" id="registerUsername" placeholder="Choose a username" maxlength="20" autocomplete="username">
                            <div class="input-hint">3-20 characters, letters and numbers only</div>
                        </div>
                        
                        <div class="form-group">
                            <label for="registerEmail">📧 Email:</label>
                            <input type="email" id="registerEmail" placeholder="Enter your email" autocomplete="email">
                            <div class="input-hint">Used for account recovery</div>
                        </div>
                        
                        <div class="form-group">
                            <label for="registerPassword">🔒 Password:</label>
                            <input type="password" id="registerPassword" placeholder="Create a password" autocomplete="new-password">
                            <div class="password-toggle" onclick="togglePasswordVisibility('registerPassword')">
                                <span id="registerPasswordToggle">👁️</span>
                            </div>
                            <div class="input-hint">At least 6 characters</div>
                        </div>
                        
                        <div class="form-group">
                            <label for="registerPasswordConfirm">🔒 Confirm Password:</label>
                            <input type="password" id="registerPasswordConfirm" placeholder="Confirm your password" autocomplete="new-password">
                            <div class="password-toggle" onclick="togglePasswordVisibility('registerPasswordConfirm')">
                                <span id="registerPasswordConfirmToggle">👁️</span>
                            </div>
                        </div>
                        
                        <div class="form-actions">
                            <button class="menu-btn" onclick="performRegistration()" id="registerBtn">
                                <span id="registerBtnText">📝 Create Account</span>
                            </button>
                            <button class="menu-btn secondary" onclick="showLoginForm()">
                                🔙 Back to Sign In
                            </button>
                        </div>
                    </div>
                    
                    <!-- User Profile (shown when logged in) -->
                    <div id="userProfileSection" class="auth-form" style="display: none;">
                        <h3 style="color: var(--primary-color); margin-bottom: 20px; text-align: center;">👋 Welcome Back!</h3>
                        
                        <div class="user-info">
                            <div class="user-avatar">👤</div>
                            <div class="user-details">
                                <h4 id="currentUserName">Player</h4>
                                <p id="currentUserEmail">player@example.com</p>
                            </div>
                        </div>
                        
                        <div class="user-stats-grid">
                            <div class="stat-card">
                                <div class="stat-value" id="userGamesPlayed">0</div>
                                <div class="stat-label">Games Played</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="userGamesWon">0</div>
                                <div class="stat-label">Games Won</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="userCurrentRating">1200</div>
                                <div class="stat-label">Current Rating</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="userWinRate">0%</div>
                                <div class="stat-label">Win Rate</div>
                            </div>
                        </div>
                        
                        <div class="form-actions">
                            <button class="menu-btn" onclick="showPanel('onlineMultiplayer')">
                                🌐 Play Online
                            </button>
                            <button class="menu-btn secondary" onclick="performLogout()">
                                🚪 Sign Out
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Error/Success Messages -->
                <div id="authMessages" style="margin-top: 15px;"></div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back to Menu</button>
                </div>
            </div>

            <!-- In-Game UI -->
            <div id="inGameUI">
                <div class="ui-top">
                    <div>
                        <span>Lives: <span id="livesCount">3</span></span>
                        <span style="margin-left: 20px;">Rally: <span id="rallyCount">0</span></span>
                    </div>
                    <div id="gameModeDisplay" style="font-weight: bold;"></div>
                    <div class="ui-controls">
                        <button class="ui-btn" onclick="pauseGame()">⏸️ Pause</button>
                        <button class="ui-btn" onclick="showPanel('menu'); gameEngine.gameState = 'menu';">📋 Menu</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== AUDIO SYSTEM =====
        class AudioSystem {
            constructor() {
                this.audioContext = null;
                this.muted = false;
                this.volume = 0.7;
                this.initAudio();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Audio not supported');
                }
            }
            
            beep(freq, duration, type = 'sine') {
                if (!this.audioContext || this.muted) return;
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                
                osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                osc.type = type;
                
                gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + duration);
            }
            
            play(type) {
                if (!this.audioContext || this.muted) return;
                
                switch(type) {
                    case 'paddleHit': this.beep(220, 0.1, 'square'); break;
                    case 'wallBounce': this.beep(330, 0.08, 'sine'); break;
                    case 'score': this.scoreSound(); break;
                    case 'win': this.winSound(); break;
                    case 'lose': this.loseSound(); break;
                    case 'menuClick': this.beep(150, 0.05, 'sine'); break;
                    case 'gameStart': this.startSound(); break;
                }
            }
            
            scoreSound() {
                [261.63, 329.63, 392.00].forEach((freq, i) => {
                    setTimeout(() => this.beep(freq, 0.15, 'sine'), i * 100);
                });
            }
            
            winSound() {
                [261.63, 329.63, 392.00, 523.25].forEach((freq, i) => {
                    setTimeout(() => this.beep(freq, 0.3, 'square'), i * 150);
                });
            }
            
            loseSound() {
                [392.00, 329.63, 261.63].forEach((freq, i) => {
                    setTimeout(() => this.beep(freq, 0.4, 'sawtooth'), i * 200);
                });
            }
            
            startSound() {
                setTimeout(() => this.beep(440, 0.1, 'square'), 0);
                setTimeout(() => this.beep(554, 0.1, 'square'), 100);
                setTimeout(() => this.beep(659, 0.2, 'square'), 200);
            }
        }

        // ===== BACKGROUND EFFECTS SYSTEM =====
        class BackgroundEffect {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.enabled = true;
                this.currentEffect = 'particles'; // particles, waves, geometric, starfield, pulsing, matrix, plasma, neural, galaxy, lightning, aurora, circuit, honeycomb, ripple, storm
                this.time = 0;
                this.intensity = 1; // 0-2, affects animation speed and density
                this.backgroundParticles = [];
                this.matrixColumns = [];
                this.plasmaData = [];
                this.neuralNodes = [];
                this.galaxyStars = [];
                this.lightningBranches = [];
                this.circuitPaths = [];
                this.hexagons = [];
                this.ripples = [];
                this.stormClouds = [];
                this.lightningBolts = [];
                this.rainDrops = [];
                this.initBackgroundParticles();
                this.initMatrixRain();
                this.initNeuralNetwork();
                this.initGalaxy();
                this.initCircuitBoard();
                this.initHoneycomb();
                this.initStorm();
            }
            
            initBackgroundParticles() {
                // Create floating background particles
                for (let i = 0; i < 25; i++) {
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20,
                        size: 1 + Math.random() * 2,
                        alpha: 0.1 + Math.random() * 0.2,
                        hue: Math.random() * 360
                    });
                }
            }
            
            initMatrixRain() {
                const columns = Math.floor(this.canvas.width / 20);
                for (let i = 0; i < columns; i++) {
                    this.matrixColumns.push({
                        x: i * 20,
                        y: Math.random() * this.canvas.height,
                        speed: 2 + Math.random() * 5,
                        chars: '01'.split(''),
                        currentChar: 0
                    });
                }
            }
            
            initNeuralNetwork() {
                for (let i = 0; i < 15; i++) {
                    this.neuralNodes.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        connections: [],
                        activity: Math.random()
                    });
                }
                // Create connections between nodes
                this.neuralNodes.forEach((node, i) => {
                    for (let j = i + 1; j < this.neuralNodes.length; j++) {
                        const other = this.neuralNodes[j];
                        const distance = Math.sqrt((node.x - other.x) ** 2 + (node.y - other.y) ** 2);
                        if (distance < 150 && Math.random() > 0.7) {
                            node.connections.push(j);
                        }
                    }
                });
            }
            
            initGalaxy() {
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * Math.min(this.canvas.width, this.canvas.height) / 3;
                    this.galaxyStars.push({
                        angle: angle,
                        radius: radius,
                        speed: 0.5 + Math.random(),
                        size: 0.5 + Math.random() * 2,
                        centerX: this.canvas.width / 2,
                        centerY: this.canvas.height / 2
                    });
                }
            }
            
            initCircuitBoard() {
                const gridSize = 40;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    for (let y = 0; y < this.canvas.height; y += gridSize) {
                        if (Math.random() > 0.7) {
                            this.circuitPaths.push({
                                x: x,
                                y: y,
                                width: gridSize * (0.5 + Math.random() * 2),
                                height: gridSize * (0.5 + Math.random() * 2),
                                type: Math.random() > 0.5 ? 'horizontal' : 'vertical',
                                pulse: Math.random() * Math.PI * 2
                            });
                        }
                    }
                }
            }
            
            initHoneycomb() {
                const hexSize = 30;
                const hexWidth = hexSize * Math.sqrt(3);
                const hexHeight = hexSize * 2;
                
                for (let row = 0; row < this.canvas.height / hexHeight + 2; row++) {
                    for (let col = 0; col < this.canvas.width / hexWidth + 2; col++) {
                        const x = col * hexWidth + (row % 2) * hexWidth / 2;
                        const y = row * hexHeight * 0.75;
                        
                        this.hexagons.push({
                            x: x,
                            y: y,
                            size: hexSize,
                            alpha: 0.1 + Math.random() * 0.2,
                            pulse: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
            
            initStorm() {
                // Create storm clouds
                for (let i = 0; i < 5; i++) {
                    this.stormClouds.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * (this.canvas.height * 0.3),
                        width: 80 + Math.random() * 120,
                        height: 40 + Math.random() * 60,
                        darkness: 0.3 + Math.random() * 0.4,
                        drift: (Math.random() - 0.5) * 20
                    });
                }
                
                // Initialize rain drops
                for (let i = 0; i < 50; i++) {
                    this.rainDrops.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        speed: 200 + Math.random() * 300,
                        length: 5 + Math.random() * 15,
                        opacity: 0.3 + Math.random() * 0.4
                    });
                }
            }
            
            update(dt) {
                if (!this.enabled) return;
                this.time += dt;
                
                // Update background particles
                this.backgroundParticles.forEach(particle => {
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;
                    
                    // Wrap around screen
                    if (particle.x < -10) particle.x = this.canvas.width + 10;
                    if (particle.x > this.canvas.width + 10) particle.x = -10;
                    if (particle.y < -10) particle.y = this.canvas.height + 10;
                    if (particle.y > this.canvas.height + 10) particle.y = -10;
                });
                
                // Update matrix rain
                this.matrixColumns.forEach(col => {
                    col.y += col.speed * 60 * dt;
                    if (col.y > this.canvas.height) {
                        col.y = -20;
                        col.x = Math.floor(Math.random() * (this.canvas.width / 20)) * 20;
                    }
                });
                
                // Update neural network activity
                this.neuralNodes.forEach(node => {
                    node.activity += (Math.random() - 0.5) * dt;
                    node.activity = Math.max(0.1, Math.min(1, node.activity));
                });
                
                // Update galaxy rotation
                this.galaxyStars.forEach(star => {
                    star.angle += star.speed * dt * 0.2;
                });
                
                // Update circuit board pulses
                this.circuitPaths.forEach(path => {
                    path.pulse += dt * 2;
                });
                
                // Update hexagon pulses
                this.hexagons.forEach(hex => {
                    hex.pulse += dt * (0.5 + Math.random());
                });
                
                // Update storm elements
                this.updateStormElements(dt);
            }
            
            draw() {
                if (!this.enabled) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.3;
                
                switch (this.currentEffect) {
                    case 'particles': this.drawFloatingParticles(); break;
                    case 'waves': this.drawWaves(); break;
                    case 'geometric': this.drawGeometric(); break;
                    case 'starfield': this.drawStarfield(); break;
                    case 'pulsing': this.drawPulsingGradient(); break;
                    case 'matrix': this.drawMatrix(); break;
                    case 'plasma': this.drawPlasma(); break;
                    case 'neural': this.drawNeuralNetwork(); break;
                    case 'galaxy': this.drawGalaxy(); break;
                    case 'lightning': this.drawLightning(); break;
                    case 'aurora': this.drawAurora(); break;
                    case 'circuit': this.drawCircuitBoard(); break;
                    case 'honeycomb': this.drawHoneycomb(); break;
                    case 'ripple': this.drawRipple(); break;
                    case 'storm': this.drawStorm(); break;
                }
                
                this.ctx.restore();
            }
            
            drawFloatingParticles() {
                this.backgroundParticles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.alpha * this.intensity;
                    this.ctx.fillStyle = `hsl(${particle.hue}, 60%, 70%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
            
            drawWaves() {
                const waveHeight = 30;
                const waveFreq = 0.005;
                const waveSpeed = 2;
                
                this.ctx.strokeStyle = `rgba(100, 200, 255, ${0.2 * this.intensity})`;
                this.ctx.lineWidth = 2;
                
                for (let wave = 0; wave < 3; wave++) {
                    this.ctx.beginPath();
                    for (let x = 0; x < this.canvas.width; x += 5) {
                        const y = this.canvas.height / 2 + 
                                 Math.sin((x * waveFreq) + (this.time * waveSpeed) + (wave * 2)) * waveHeight +
                                 Math.sin((x * waveFreq * 2) + (this.time * waveSpeed * 0.7) + (wave * 1.5)) * waveHeight * 0.5;
                        if (x === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                }
            }
            
            drawGeometric() {
                const time = this.time * 0.5;
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * this.intensity})`;
                this.ctx.lineWidth = 1;
                
                // Draw rotating geometric patterns
                for (let i = 0; i < 8; i++) {
                    const centerX = (i % 4) * (this.canvas.width / 3) + this.canvas.width / 6;
                    const centerY = Math.floor(i / 4) * (this.canvas.height / 2) + this.canvas.height / 4;
                    const rotation = time + (i * Math.PI / 4);
                    const size = 20 + Math.sin(time + i) * 10;
                    
                    this.ctx.save();
                    this.ctx.translate(centerX, centerY);
                    this.ctx.rotate(rotation);
                    
                    this.ctx.beginPath();
                    for (let side = 0; side < 6; side++) {
                        const angle = (side / 6) * Math.PI * 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (side === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.closePath();
                    this.ctx.stroke();
                    this.ctx.restore();
                }
            }
            
            drawStarfield() {
                // Create twinkling stars
                for (let i = 0; i < 50; i++) {
                    const x = (i * 73) % this.canvas.width;
                    const y = (i * 37) % this.canvas.height;
                    const twinkle = Math.sin(this.time * 3 + i) * 0.5 + 0.5;
                    const alpha = 0.1 + (twinkle * 0.3) * this.intensity;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(x, y, 1, 1);
                    
                    // Add cross sparkle to brighter stars
                    if (twinkle > 0.7) {
                        this.ctx.fillRect(x - 2, y, 5, 1);
                        this.ctx.fillRect(x, y - 2, 1, 5);
                    }
                    this.ctx.restore();
                }
            }
            
            drawPulsingGradient() {
                const pulse = Math.sin(this.time * 2) * 0.3 + 0.7;
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.width * pulse
                );
                
                gradient.addColorStop(0, `rgba(100, 150, 255, ${0.1 * this.intensity})`);
                gradient.addColorStop(0.5, `rgba(150, 100, 255, ${0.05 * this.intensity})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawMatrix() {
                this.ctx.fillStyle = `rgba(0, 255, 0, ${0.8 * this.intensity})`;
                this.ctx.font = '14px monospace';
                
                this.matrixColumns.forEach(col => {
                    const char = col.chars[Math.floor(this.time * 2) % col.chars.length];
                    this.ctx.fillText(char, col.x, col.y);
                });
            }
            
            drawPlasma() {
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let x = 0; x < this.canvas.width; x += 4) {
                    for (let y = 0; y < this.canvas.height; y += 4) {
                        const index = (y * this.canvas.width + x) * 4;
                        
                        const value = Math.sin(x * 0.01 + this.time) + 
                                    Math.sin(y * 0.01 + this.time * 0.7) + 
                                    Math.sin((x + y) * 0.01 + this.time * 0.5);
                        
                        const color = Math.floor((value + 3) * 42.5) % 256;
                        
                        data[index] = color * 0.3;     // Red
                        data[index + 1] = color * 0.6; // Green  
                        data[index + 2] = color;       // Blue
                        data[index + 3] = 50 * this.intensity; // Alpha
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }
            
            drawNeuralNetwork() {
                // Draw connections
                this.ctx.strokeStyle = `rgba(100, 255, 200, ${0.3 * this.intensity})`;
                this.ctx.lineWidth = 1;
                
                this.neuralNodes.forEach((node, i) => {
                    node.connections.forEach(connectionIndex => {
                        const connected = this.neuralNodes[connectionIndex];
                        const activity = (node.activity + connected.activity) / 2;
                        
                        this.ctx.globalAlpha = activity * this.intensity * 0.5;
                        this.ctx.beginPath();
                        this.ctx.moveTo(node.x, node.y);
                        this.ctx.lineTo(connected.x, connected.y);
                        this.ctx.stroke();
                    });
                });
                
                // Draw nodes
                this.neuralNodes.forEach(node => {
                    const pulse = Math.sin(this.time * 3 + node.x * 0.01) * 0.5 + 0.5;
                    this.ctx.globalAlpha = (node.activity * pulse + 0.3) * this.intensity;
                    this.ctx.fillStyle = `hsl(${180 + pulse * 60}, 70%, 60%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 3 + pulse * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawGalaxy() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.galaxyStars.forEach(star => {
                    const x = centerX + Math.cos(star.angle) * star.radius;
                    const y = centerY + Math.sin(star.angle) * star.radius;
                    
                    const distance = star.radius / (Math.min(this.canvas.width, this.canvas.height) / 3);
                    const alpha = (1 - distance) * 0.4 * this.intensity;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = `hsl(${240 + distance * 120}, 80%, 70%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
            
            drawLightning() {
                this.ctx.strokeStyle = `rgba(200, 200, 255, ${0.6 * this.intensity})`;
                this.ctx.lineWidth = 2;
                this.ctx.lineCap = 'round';
                
                // Generate random lightning bolts
                if (Math.random() < 0.05 * this.intensity) {
                    const startX = Math.random() * this.canvas.width;
                    const startY = 0;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    
                    let x = startX;
                    let y = startY;
                    
                    while (y < this.canvas.height) {
                        x += (Math.random() - 0.5) * 40;
                        y += Math.random() * 30 + 10;
                        this.ctx.lineTo(x, y);
                    }
                    
                    this.ctx.stroke();
                }
            }
            
            drawAurora() {
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                
                const time = this.time * 0.5;
                const wave1 = Math.sin(time) * 0.3 + 0.7;
                const wave2 = Math.sin(time * 0.7) * 0.3 + 0.7;
                
                gradient.addColorStop(0, `rgba(0, 255, 150, ${0.1 * wave1 * this.intensity})`);
                gradient.addColorStop(0.5, `rgba(150, 0, 255, ${0.15 * wave2 * this.intensity})`);
                gradient.addColorStop(1, `rgba(0, 150, 255, ${0.1 * wave1 * this.intensity})`);
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Add flowing streaks
                this.ctx.strokeStyle = `rgba(100, 255, 200, ${0.3 * this.intensity})`;
                this.ctx.lineWidth = 3;
                
                for (let i = 0; i < 5; i++) {
                    this.ctx.beginPath();
                    for (let x = 0; x < this.canvas.width; x += 10) {
                        const y = this.canvas.height * 0.3 + 
                                 Math.sin((x * 0.01) + (time * 2) + (i * 1.2)) * 30 + 
                                 Math.sin((x * 0.005) + (time * 1.5) + (i * 0.8)) * 20;
                        if (x === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                }
            }
            
            drawCircuitBoard() {
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.4 * this.intensity})`;
                this.ctx.lineWidth = 2;
                
                this.circuitPaths.forEach(path => {
                    const pulse = Math.sin(this.time * 2 + path.pulse) * 0.5 + 0.5;
                    this.ctx.globalAlpha = pulse * this.intensity * 0.6;
                    
                    this.ctx.beginPath();
                    if (path.type === 'horizontal') {
                        this.ctx.moveTo(path.x, path.y);
                        this.ctx.lineTo(path.x + path.width, path.y);
                    } else {
                        this.ctx.moveTo(path.x, path.y);
                        this.ctx.lineTo(path.x, path.y + path.height);
                    }
                    this.ctx.stroke();
                    
                    // Draw connection nodes
                    this.ctx.fillStyle = `rgba(255, 255, 0, ${pulse * this.intensity})`;
                    this.ctx.beginPath();
                    this.ctx.arc(path.x, path.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawHoneycomb() {
                this.ctx.strokeStyle = `rgba(255, 200, 0, ${0.3 * this.intensity})`;
                this.ctx.lineWidth = 1;
                
                this.hexagons.forEach(hex => {
                    const pulse = Math.sin(this.time + hex.pulse) * 0.3 + 0.7;
                    this.ctx.globalAlpha = hex.alpha * pulse * this.intensity;
                    
                    this.ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = hex.x + Math.cos(angle) * hex.size;
                        const y = hex.y + Math.sin(angle) * hex.size;
                        
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.closePath();
                    this.ctx.stroke();
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawRipple() {
                // Create ripples on game events
                this.ripples.forEach((ripple, index) => {
                    const progress = (this.time - ripple.startTime) / ripple.duration;
                    
                    if (progress >= 1) {
                        this.ripples.splice(index, 1);
                        return;
                    }
                    
                    const radius = progress * ripple.maxRadius;
                    const alpha = (1 - progress) * 0.4 * this.intensity;
                    
                    this.ctx.strokeStyle = `rgba(${ripple.color}, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
                
                // Background subtle ripples
                for (let i = 0; i < 3; i++) {
                    const radius = (Math.sin(this.time * 0.5 + i * 2) * 0.5 + 0.5) * 100;
                    const alpha = 0.1 * this.intensity;
                    
                    this.ctx.strokeStyle = `rgba(100, 150, 255, ${alpha})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            updateStormElements(dt) {
                // Update storm clouds drift
                this.stormClouds.forEach(cloud => {
                    cloud.x += cloud.drift * dt;
                    // Wrap around screen
                    if (cloud.x > this.canvas.width + cloud.width) cloud.x = -cloud.width;
                    if (cloud.x < -cloud.width) cloud.x = this.canvas.width + cloud.width;
                });
                
                // Update rain drops
                this.rainDrops.forEach(drop => {
                    drop.y += drop.speed * dt;
                    if (drop.y > this.canvas.height + drop.length) {
                        drop.y = -drop.length;
                        drop.x = Math.random() * this.canvas.width;
                    }
                });
                
                // Update lightning bolts (they fade over time)
                this.lightningBolts = this.lightningBolts.filter(bolt => {
                    bolt.life -= dt * 5; // Lightning fades quickly
                    bolt.alpha = Math.max(0, bolt.life);
                    return bolt.life > 0;
                });
            }
            
            drawStorm() {
                // Draw storm clouds
                this.stormClouds.forEach(cloud => {
                    const gradient = this.ctx.createRadialGradient(
                        cloud.x + cloud.width/2, cloud.y + cloud.height/2, 0,
                        cloud.x + cloud.width/2, cloud.y + cloud.height/2, cloud.width/2
                    );
                    
                    gradient.addColorStop(0, `rgba(40, 40, 60, ${cloud.darkness * this.intensity})`);
                    gradient.addColorStop(0.7, `rgba(20, 20, 40, ${cloud.darkness * 0.7 * this.intensity})`);
                    gradient.addColorStop(1, 'rgba(20, 20, 40, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.ellipse(cloud.x + cloud.width/2, cloud.y + cloud.height/2, cloud.width/2, cloud.height/2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw rain
                this.ctx.strokeStyle = `rgba(150, 180, 220, ${0.5 * this.intensity})`;
                this.ctx.lineWidth = 1;
                this.rainDrops.forEach(drop => {
                    this.ctx.globalAlpha = drop.opacity * this.intensity;
                    this.ctx.beginPath();
                    this.ctx.moveTo(drop.x, drop.y);
                    this.ctx.lineTo(drop.x - 3, drop.y + drop.length); // Angled rain
                    this.ctx.stroke();
                });
                this.ctx.globalAlpha = 1;
                
                // Draw lightning bolts
                this.lightningBolts.forEach(bolt => {
                    this.ctx.save();
                    this.ctx.globalAlpha = bolt.alpha * this.intensity;
                    this.ctx.strokeStyle = bolt.color;
                    this.ctx.lineWidth = bolt.width;
                    this.ctx.lineCap = 'round';
                    this.ctx.shadowColor = bolt.color;
                    this.ctx.shadowBlur = 15;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(bolt.points[0].x, bolt.points[0].y);
                    bolt.points.slice(1).forEach(point => {
                        this.ctx.lineTo(point.x, point.y);
                    });
                    this.ctx.stroke();
                    this.ctx.restore();
                });
            }
            
            createLightningBolt(startX, startY, endX, endY, intensity = 'normal') {
                const points = [{x: startX, y: startY}];
                const segments = Math.floor(Math.abs(endY - startY) / 20);
                
                for (let i = 1; i < segments; i++) {
                    const progress = i / segments;
                    const x = startX + (endX - startX) * progress + (Math.random() - 0.5) * 60;
                    const y = startY + (endY - startY) * progress;
                    points.push({x, y});
                }
                points.push({x: endX, y: endY});
                
                const bolt = {
                    points: points,
                    life: 1,
                    alpha: 1,
                    color: intensity === 'major' ? '#ffffff' : '#a0c4ff',
                    width: intensity === 'major' ? 4 : 2
                };
                
                this.lightningBolts.push(bolt);
                
                // Add branching for major lightning
                if (intensity === 'major' && points.length > 3) {
                    const branchPoint = points[Math.floor(points.length * 0.6)];
                    const branchEndX = branchPoint.x + (Math.random() - 0.5) * 200;
                    const branchEndY = Math.min(this.canvas.height, branchPoint.y + 50 + Math.random() * 100);
                    this.createLightningBolt(branchPoint.x, branchPoint.y, branchEndX, branchEndY, 'normal');
                }
            }
            
            triggerLightningBounce() {
                if (this.currentEffect !== 'storm') return;
                
                // Light lightning on bounce
                const startX = Math.random() * this.canvas.width;
                const endX = startX + (Math.random() - 0.5) * 100;
                const endY = this.canvas.height * (0.3 + Math.random() * 0.4);
                
                this.createLightningBolt(startX, 0, endX, endY, 'normal');
            }
            
            triggerLightningScore() {
                if (this.currentEffect !== 'storm') return;
                
                // Major lightning on score - multiple bolts
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const startX = Math.random() * this.canvas.width;
                        const endX = startX + (Math.random() - 0.5) * 150;
                        const endY = this.canvas.height * (0.4 + Math.random() * 0.5);
                        
                        this.createLightningBolt(startX, 0, endX, endY, 'major');
                    }, i * 100);
                }
            }
            
            // React to game events
            onBallHit() {
                this.intensity = Math.min(2, this.intensity + 0.3);
                setTimeout(() => {
                    this.intensity = Math.max(0.5, this.intensity - 0.3);
                }, 200);
                
                // Trigger light lightning on bounces
                this.triggerLightningBounce();
            }
            
            onScore() {
                this.intensity = 2;
                setTimeout(() => {
                    this.intensity = 1;
                }, 1000);
                
                // Trigger major lightning on scores
                this.triggerLightningScore();
            }
            
            onPowerUpCollected() {
                this.intensity = 1.5;
                setTimeout(() => {
                    this.intensity = 1;
                }, 500);
                
                // Add ripple effect for ripple background
                if (this.currentEffect === 'ripple') {
                    this.addRipple(Math.random() * this.canvas.width, Math.random() * this.canvas.height, '255, 200, 0', 2);
                }
            }
            
            addRipple(x, y, color = '100, 150, 255', duration = 1.5) {
                this.ripples.push({
                    x: x,
                    y: y,
                    startTime: this.time,
                    duration: duration,
                    maxRadius: 100,
                    color: color
                });
            }
            
            setEffect(effectName) {
                this.currentEffect = effectName;
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
            }
        }

        // ===== PARTICLE SYSTEM =====
        class Particle {
            constructor(x, y, vx, vy, life, color, size, type = 'circle') {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.life = life; this.maxLife = life;
                this.color = color; this.size = size; this.type = type;
                this.gravity = 0; this.alpha = 1; this.rotation = 0; this.rotationSpeed = 0;
            }
            
            update(dt) {
                this.x += this.vx * dt; this.y += this.vy * dt; this.vy += this.gravity * dt;
                this.rotation += this.rotationSpeed * dt; this.life -= dt;
                this.alpha = Math.max(0, this.life / this.maxLife);
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = this.alpha;
                ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                
                if (this.type === 'circle') {
                    ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                }
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor(ctx) { this.ctx = ctx; this.particles = []; this.enabled = true; }
            
            update(dt) {
                if (!this.enabled) return;
                this.particles = this.particles.filter(p => p.update(dt));
            }
            
            draw() {
                if (!this.enabled) return;
                this.particles.forEach(p => p.draw(this.ctx));
            }
            
            addParticle(particle) {
                if (this.enabled && this.particles.length < 500) this.particles.push(particle);
            }
            
            paddleHit(x, y, vx, vy) {
                const colors = ['#4ecdc4', '#44a08d', '#ffffff'];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI/3) * (Math.random()-0.5) + Math.atan2(vy, vx);
                    const speed = 100 + Math.random() * 100;
                    const p = new Particle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed,
                        0.3 + Math.random()*0.2, colors[Math.floor(Math.random()*colors.length)], 2+Math.random()*3);
                    p.gravity = 50; this.addParticle(p);
                }
            }
            
            wallBounce(x, y) {
                const colors = ['#ff6b6b', '#ffa726', '#ffffff'];
                for (let i = 0; i < 4; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 50;
                    this.addParticle(new Particle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed,
                        0.4, colors[Math.floor(Math.random()*colors.length)], 1+Math.random()*2));
                }
            }
            
            scoreEffect(x, y, isPlayer) {
                const colors = isPlayer ? ['#4ecdc4', '#44a08d'] : ['#ff6b6b', '#ee5a52'];
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 80 + Math.random() * 100;
                    const p = new Particle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed-100,
                        1+Math.random()*0.5, colors[Math.floor(Math.random()*colors.length)], 3+Math.random()*4);
                    p.gravity = 100; p.rotationSpeed = (Math.random()-0.5)*10; this.addParticle(p);
                }
            }
            
            winEffect(w, h) {
                const colors = ['#4ecdc4', '#44a08d', '#ffffff', '#ffd54f'];
                for (let i = 0; i < 20; i++) {
                    const p = new Particle(Math.random()*w, -20, (Math.random()-0.5)*100, 100+Math.random()*100,
                        3+Math.random()*2, colors[Math.floor(Math.random()*colors.length)], 4+Math.random()*6);
                    p.gravity = 150; p.rotationSpeed = (Math.random()-0.5)*15; this.addParticle(p);
                }
            }
        }

        // ===== MACHINE LEARNING AI =====
        class MachineLearningAI {
            constructor() {
                this.patterns = {
                    playerMovement: [], // Stores player Y positions over time
                    ballInterceptions: [], // Where player intercepts the ball
                    reactionTimes: [], // Player reaction time patterns
                    defensiveZones: [], // Where player tends to defend
                    aggressiveActions: [], // When player makes aggressive moves
                    weakSpots: [], // Areas where player misses
                    successfulHits: [] // Where player makes successful hits
                };
                
                this.learningModel = {
                    playerTendencies: {
                        favoritePosition: 200, // Default center
                        movementSpeed: 1.0,
                        reactionDelay: 0.3,
                        defensiveRatio: 0.5, // 0 = aggressive, 1 = defensive
                        consistencyLevel: 0.5,
                        predictability: 0.5
                    },
                    adaptations: {
                        targetingBias: 0, // -1 = target weak spots, 1 = avoid strengths
                        speedAdjustment: 1.0,
                        strategyPreference: 'balanced', // balanced, exploit, challenge
                        learningRate: 0.1
                    },
                    confidence: 0.5, // How confident the AI is in its learning
                    gamesAnalyzed: 0
                };
                
                this.minGamesForLearning = 3;
                this.maxPatternSize = 100; // Limit memory usage
            }
            
            // Record player behavior during gameplay
            recordPlayerAction(actionType, data) {
                if (!this.patterns[actionType]) return;
                
                this.patterns[actionType].push({
                    ...data,
                    timestamp: Date.now(),
                    gameNumber: this.learningModel.gamesAnalyzed
                });
                
                // Limit pattern size to prevent memory overflow
                if (this.patterns[actionType].length > this.maxPatternSize) {
                    this.patterns[actionType].shift();
                }
            }
            
            // Analyze patterns after each game
            analyzeGamePatterns(gameStats) {
                this.learningModel.gamesAnalyzed++;
                
                if (this.learningModel.gamesAnalyzed < this.minGamesForLearning) {
                    return; // Need more data
                }
                
                this.analyzeMovementPatterns();
                this.analyzeReactionPatterns();
                this.analyzeDefensivePatterns();
                this.analyzeWeakSpots();
                this.updateConfidence();
                this.adaptStrategy(gameStats);
            }
            
            analyzeMovementPatterns() {
                if (this.patterns.playerMovement.length < 10) return;
                
                const recentMovements = this.patterns.playerMovement.slice(-50);
                const positions = recentMovements.map(m => m.y);
                
                // Calculate favorite position
                this.learningModel.playerTendencies.favoritePosition = 
                    positions.reduce((sum, pos) => sum + pos, 0) / positions.length;
                
                // Calculate movement consistency
                const avgPosition = this.learningModel.playerTendencies.favoritePosition;
                const variance = positions.reduce((sum, pos) => sum + Math.pow(pos - avgPosition, 2), 0) / positions.length;
                this.learningModel.playerTendencies.consistencyLevel = Math.max(0, Math.min(1, 1 - (variance / 10000)));
                
                // Calculate predictability based on movement patterns
                let predictableSequences = 0;
                for (let i = 3; i < positions.length; i++) {
                    const pattern = positions.slice(i-3, i);
                    const prediction = this.predictNextPosition(pattern);
                    if (Math.abs(prediction - positions[i]) < 20) {
                        predictableSequences++;
                    }
                }
                this.learningModel.playerTendencies.predictability = predictableSequences / (positions.length - 3);
            }
            
            analyzeReactionPatterns() {
                if (this.patterns.reactionTimes.length < 5) return;
                
                const recentReactions = this.patterns.reactionTimes.slice(-20);
                const avgReactionTime = recentReactions.reduce((sum, r) => sum + r.time, 0) / recentReactions.length;
                
                this.learningModel.playerTendencies.reactionDelay = avgReactionTime / 1000; // Convert to seconds
                
                // Analyze if player has faster reactions in certain situations
                const urgentReactions = recentReactions.filter(r => r.ballSpeed > 6);
                if (urgentReactions.length > 0) {
                    const urgentAvg = urgentReactions.reduce((sum, r) => sum + r.time, 0) / urgentReactions.length;
                    this.learningModel.playerTendencies.stressResponse = urgentAvg / avgReactionTime;
                }
            }
            
            analyzeDefensivePatterns() {
                if (this.patterns.defensiveZones.length < 5) return;
                
                const recentDefensive = this.patterns.defensiveZones.slice(-30);
                const centerZone = recentDefensive.filter(d => Math.abs(d.y - 200) < 60).length;
                const totalDefensive = recentDefensive.length;
                
                this.learningModel.playerTendencies.defensiveRatio = centerZone / totalDefensive;
            }
            
            analyzeWeakSpots() {
                if (this.patterns.weakSpots.length < 3) return;
                
                const recentMisses = this.patterns.weakSpots.slice(-20);
                const missZones = {};
                
                recentMisses.forEach(miss => {
                    const zone = Math.floor(miss.y / 50); // Divide field into zones
                    missZones[zone] = (missZones[zone] || 0) + 1;
                });
                
                // Find the zone with most misses
                let maxMisses = 0;
                let weakestZone = 4; // Default to center
                for (const zone in missZones) {
                    if (missZones[zone] > maxMisses) {
                        maxMisses = missZones[zone];
                        weakestZone = parseInt(zone);
                    }
                }
                
                this.learningModel.playerTendencies.weakestZone = weakestZone;
            }
            
            updateConfidence() {
                const dataPoints = Object.values(this.patterns).reduce((sum, arr) => sum + arr.length, 0);
                const targetDataPoints = 200; // Ideal amount of data
                
                this.learningModel.confidence = Math.min(1, dataPoints / targetDataPoints);
            }
            
            adaptStrategy(gameStats) {
                const playerWinRate = gameStats.gamesWon / gameStats.gamesPlayed;
                const learningRate = this.learningModel.adaptations.learningRate;
                
                // Adjust strategy based on player performance
                if (playerWinRate > 0.7) {
                    // Player is winning too much, make AI more challenging
                    this.learningModel.adaptations.strategyPreference = 'exploit';
                    this.learningModel.adaptations.targetingBias = Math.min(0.8, 
                        this.learningModel.adaptations.targetingBias + learningRate);
                } else if (playerWinRate < 0.3) {
                    // Player is struggling, make AI less aggressive
                    this.learningModel.adaptations.strategyPreference = 'challenge';
                    this.learningModel.adaptations.targetingBias = Math.max(-0.5, 
                        this.learningModel.adaptations.targetingBias - learningRate);
                } else {
                    // Balanced game, maintain current strategy
                    this.learningModel.adaptations.strategyPreference = 'balanced';
                }
                
                // Adjust speed based on player's reaction time
                if (this.learningModel.playerTendencies.reactionDelay > 0.4) {
                    this.learningModel.adaptations.speedAdjustment = Math.max(0.7, 
                        this.learningModel.adaptations.speedAdjustment - learningRate * 0.5);
                } else if (this.learningModel.playerTendencies.reactionDelay < 0.2) {
                    this.learningModel.adaptations.speedAdjustment = Math.min(1.3, 
                        this.learningModel.adaptations.speedAdjustment + learningRate * 0.5);
                }
            }
            
            // Predict where player will be based on patterns
            predictPlayerPosition(currentY, ballY, ballVy) {
                if (this.learningModel.confidence < 0.3) {
                    return currentY; // Not enough data, return current position
                }
                
                const tendencies = this.learningModel.playerTendencies;
                const adaptations = this.learningModel.adaptations;
                
                // Base prediction on favorite position and ball trajectory
                let predictedY = tendencies.favoritePosition * 0.3 + ballY * 0.7;
                
                // Adjust for player's defensive ratio
                if (tendencies.defensiveRatio > 0.6) {
                    // Defensive player, predict they'll move toward center
                    predictedY = predictedY * 0.7 + 200 * 0.3;
                }
                
                // Factor in reaction delay
                const delayFactor = Math.max(0, 1 - tendencies.reactionDelay * 2);
                predictedY = currentY * (1 - delayFactor) + predictedY * delayFactor;
                
                // Allow full range movement - paddle center can be from 40 (paddle top at 0) to 360 (paddle bottom at 320)
                const paddleHeight = 80;
                const canvasHeight = 400;
                const minY = paddleHeight / 2;
                const maxY = canvasHeight - paddleHeight / 2;
                return Math.max(minY, Math.min(maxY, predictedY));
            }
            
            // Get AI target position based on learning
            getAdaptiveTarget(ballX, ballY, ballVx, ballVy, playerY, aiY) {
                if (this.learningModel.confidence < 0.3) {
                    return ballY; // Default behavior
                }
                
                const tendencies = this.learningModel.playerTendencies;
                const adaptations = this.learningModel.adaptations;
                
                let targetY = ballY;
                
                // Predict where player will be
                const predictedPlayerY = this.predictPlayerPosition(playerY, ballY, ballVy);
                
                // SAFETY CHECK: If ball is moving away from AI (toward player), default to ball tracking
                if (ballVx < 0) {
                    targetY = ballY + ballVy * 0.3; // Basic ball tracking
                } else {
                    // Ball is coming toward AI, apply learned behavior
                    switch (adaptations.strategyPreference) {
                        case 'exploit':
                            // Target player's weak spots
                            if (tendencies.weakestZone !== undefined) {
                                const weakSpotY = tendencies.weakestZone * 50 + 25;
                                targetY = weakSpotY * 0.4 + ballY * 0.6; // Reduced exploit factor
                            }
                            break;
                            
                        case 'challenge':
                            // Play to player's strengths to provide good gameplay
                            targetY = predictedPlayerY * 0.2 + ballY * 0.8; // More ball-focused
                            break;
                            
                        default: // 'balanced'
                            // Mix of challenging and exploiting
                            const exploitFactor = Math.min(0.5, adaptations.targetingBias); // Cap exploit factor
                            if (exploitFactor > 0 && tendencies.weakestZone !== undefined) {
                                const weakSpotY = tendencies.weakestZone * 50 + 25;
                                targetY = weakSpotY * exploitFactor + ballY * (1 - exploitFactor);
                            } else {
                                targetY = predictedPlayerY * 0.1 + ballY * 0.9; // More conservative
                            }
                    }
                }
                
                // Add some unpredictability if player is too predictable
                if (tendencies.predictability > 0.8 && Math.random() < 0.2) {
                    targetY += (Math.random() - 0.5) * 40; // Reduced randomness
                }
                
                // Ensure target is within screen bounds (but allow full range)
                const canvasHeight = 400; // Standard game height
                const paddleHeight = 80;
                const minY = paddleHeight / 2; // Paddle center minimum (top of paddle at y=0)
                const maxY = canvasHeight - paddleHeight / 2; // Paddle center maximum (bottom of paddle at y=320)
                
                // Only clamp if absolutely outside bounds (no artificial margins)
                return Math.max(minY, Math.min(maxY, targetY));
            }
            
            // Utility function to predict next position based on pattern
            predictNextPosition(positionHistory) {
                if (positionHistory.length < 2) return positionHistory[positionHistory.length - 1];
                
                // Simple linear prediction
                const last = positionHistory[positionHistory.length - 1];
                const secondLast = positionHistory[positionHistory.length - 2];
                const velocity = last - secondLast;
                
                return last + velocity;
            }
            
            // Get learning statistics for display
            getLearningStats() {
                return {
                    confidence: (this.learningModel.confidence * 100).toFixed(1),
                    gamesAnalyzed: this.learningModel.gamesAnalyzed,
                    strategy: this.learningModel.adaptations.strategyPreference,
                    playerTendencies: {
                        favoritePosition: Math.round(this.learningModel.playerTendencies.favoritePosition),
                        consistency: (this.learningModel.playerTendencies.consistencyLevel * 100).toFixed(1),
                        defensiveRatio: (this.learningModel.playerTendencies.defensiveRatio * 100).toFixed(1),
                        avgReactionTime: (this.learningModel.playerTendencies.reactionDelay * 1000).toFixed(0)
                    },
                    totalDataPoints: Object.values(this.patterns).reduce((sum, arr) => sum + arr.length, 0)
                };
            }
            
            // Save/Load learning data
            saveToStorage() {
                const data = {
                    patterns: this.patterns,
                    learningModel: this.learningModel
                };
                localStorage.setItem('pongMLAI', JSON.stringify(data));
            }
            
            loadFromStorage() {
                const saved = localStorage.getItem('pongMLAI');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.patterns = { ...this.patterns, ...data.patterns };
                        this.learningModel = { ...this.learningModel, ...data.learningModel };
                    } catch (e) {
                        console.warn('Failed to load ML AI data:', e);
                    }
                }
            }
            
            // Reset learning data
            resetLearning() {
                this.patterns = {
                    playerMovement: [],
                    ballInterceptions: [],
                    reactionTimes: [],
                    defensiveZones: [],
                    aggressiveActions: [],
                    weakSpots: [],
                    successfulHits: []
                };
                
                this.learningModel = {
                    playerTendencies: {
                        favoritePosition: 200,
                        movementSpeed: 1.0,
                        reactionDelay: 0.3,
                        defensiveRatio: 0.5,
                        consistencyLevel: 0.5,
                        predictability: 0.5
                    },
                    adaptations: {
                        targetingBias: 0,
                        speedAdjustment: 1.0,
                        strategyPreference: 'balanced',
                        learningRate: 0.1
                    },
                    confidence: 0.5,
                    gamesAnalyzed: 0
                };
                
                this.saveToStorage();
            }
        }
        
        // ===== HEAT MAP VISUALIZER =====
        class HeatMapVisualizer {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.gameWidth = 800;
                this.gameHeight = 400;
                this.heatmapWidth = 400;
                this.heatmapHeight = 200;
                this.scaleX = this.heatmapWidth / this.gameWidth;
                this.scaleY = this.heatmapHeight / this.gameHeight;
                this.gridSize = 10; // Size of each heat map cell
                this.maxIntensity = 0;
            }
            
            initialize(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                }
            }
            
            getIntensityColor(intensity, maxIntensity) {
                if (maxIntensity === 0) return 'rgba(0,0,0,0)';
                
                const normalizedIntensity = intensity / maxIntensity;
                const alpha = Math.min(0.8, normalizedIntensity * 0.8 + 0.2);
                
                // Heat map color progression: Blue -> Cyan -> Green -> Yellow -> Orange -> Red
                if (normalizedIntensity < 0.2) {
                    // Blue to Cyan
                    const ratio = normalizedIntensity / 0.2;
                    return `rgba(${Math.floor(ratio * 0)}, ${Math.floor(ratio * 255)}, 255, ${alpha})`;
                } else if (normalizedIntensity < 0.4) {
                    // Cyan to Green
                    const ratio = (normalizedIntensity - 0.2) / 0.2;
                    return `rgba(0, 255, ${Math.floor(255 - ratio * 255)}, ${alpha})`;
                } else if (normalizedIntensity < 0.6) {
                    // Green to Yellow
                    const ratio = (normalizedIntensity - 0.4) / 0.2;
                    return `rgba(${Math.floor(ratio * 255)}, 255, 0, ${alpha})`;
                } else if (normalizedIntensity < 0.8) {
                    // Yellow to Orange
                    const ratio = (normalizedIntensity - 0.6) / 0.2;
                    return `rgba(255, ${Math.floor(255 - ratio * 128)}, 0, ${alpha})`;
                } else {
                    // Orange to Red
                    const ratio = (normalizedIntensity - 0.8) / 0.2;
                    return `rgba(255, ${Math.floor(127 - ratio * 127)}, 0, ${alpha})`;
                }
            }
            
            drawPlayerHits(analytics) {
                if (!this.ctx || !analytics.heatMap.playerHits.length) return;
                
                this.clearCanvas();
                
                // Create intensity grid
                const grid = this.createIntensityGrid(analytics.heatMap.playerHits);
                this.drawHeatMapGrid(grid);
                
                // Draw game field outline
                this.drawGameField();
                
                return {
                    totalHits: analytics.heatMap.playerHits.length,
                    avgIntensity: this.calculateAverageIntensity(analytics.heatMap.playerHits),
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawAIHits(analytics) {
                if (!this.ctx || !analytics.heatMap.aiHits.length) return;
                
                this.clearCanvas();
                
                const grid = this.createIntensityGrid(analytics.heatMap.aiHits);
                this.drawHeatMapGrid(grid);
                this.drawGameField();
                
                return {
                    totalHits: analytics.heatMap.aiHits.length,
                    avgIntensity: this.calculateAverageIntensity(analytics.heatMap.aiHits),
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawBallTrajectory(analytics) {
                if (!this.ctx || !analytics.heatMap.ballTrajectories.length) return;
                
                this.clearCanvas();
                
                const grid = this.createIntensityGrid(analytics.heatMap.ballTrajectories);
                this.drawHeatMapGrid(grid);
                this.drawGameField();
                
                return {
                    totalSamples: analytics.heatMap.ballTrajectories.length,
                    avgIntensity: this.calculateAverageIntensity(analytics.heatMap.ballTrajectories),
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawPlayerMovement(playerMovementSamples) {
                if (!this.ctx || !playerMovementSamples.length) return;
                
                this.clearCanvas();
                
                // Convert movement samples to heat map format
                const movementData = playerMovementSamples.map(sample => ({
                    x: 20, // Player paddle X position
                    y: sample.y,
                    intensity: 1
                }));
                
                const grid = this.createIntensityGrid(movementData);
                this.drawHeatMapGrid(grid);
                this.drawGameField();
                
                return {
                    totalSamples: playerMovementSamples.length,
                    avgPosition: movementData.reduce((sum, d) => sum + d.y, 0) / movementData.length,
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawCombined(analytics, playerMovementSamples) {
                if (!this.ctx) return;
                
                this.clearCanvas();
                
                // Combine all data with different colors
                const allData = [];
                
                // Player hits (red tint)
                if (analytics.heatMap.playerHits.length > 0) {
                    allData.push(...analytics.heatMap.playerHits.map(hit => ({...hit, type: 'playerHit'})));
                }
                
                // AI hits (blue tint)
                if (analytics.heatMap.aiHits.length > 0) {
                    allData.push(...analytics.heatMap.aiHits.map(hit => ({...hit, type: 'aiHit'})));
                }
                
                // Ball trajectory (green tint)
                if (analytics.heatMap.ballTrajectories.length > 0) {
                    allData.push(...analytics.heatMap.ballTrajectories.map(traj => ({...traj, type: 'ballTrajectory'})));
                }
                
                this.drawCombinedHeatMap(allData);
                this.drawGameField();
                
                return {
                    playerHits: analytics.heatMap.playerHits.length,
                    aiHits: analytics.heatMap.aiHits.length,
                    ballSamples: analytics.heatMap.ballTrajectories.length,
                    maxIntensity: this.maxIntensity
                };
            }
            
            createIntensityGrid(data) {
                const gridCols = Math.ceil(this.heatmapWidth / this.gridSize);
                const gridRows = Math.ceil(this.heatmapHeight / this.gridSize);
                const grid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                
                this.maxIntensity = 0;
                
                data.forEach(point => {
                    const gridX = Math.floor((point.x * this.scaleX) / this.gridSize);
                    const gridY = Math.floor((point.y * this.scaleY) / this.gridSize);
                    
                    if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
                        grid[gridY][gridX] += point.intensity || 1;
                        this.maxIntensity = Math.max(this.maxIntensity, grid[gridY][gridX]);
                    }
                });
                
                return grid;
            }
            
            drawHeatMapGrid(grid) {
                if (!this.ctx) return;
                
                for (let row = 0; row < grid.length; row++) {
                    for (let col = 0; col < grid[row].length; col++) {
                        const intensity = grid[row][col];
                        if (intensity > 0) {
                            const color = this.getIntensityColor(intensity, this.maxIntensity);
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(
                                col * this.gridSize,
                                row * this.gridSize,
                                this.gridSize,
                                this.gridSize
                            );
                        }
                    }
                }
            }
            
            drawCombinedHeatMap(data) {
                if (!this.ctx) return;
                
                const gridCols = Math.ceil(this.heatmapWidth / this.gridSize);
                const gridRows = Math.ceil(this.heatmapHeight / this.gridSize);
                
                // Separate grids for different data types
                const playerGrid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                const aiGrid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                const ballGrid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                
                data.forEach(point => {
                    const gridX = Math.floor((point.x * this.scaleX) / this.gridSize);
                    const gridY = Math.floor((point.y * this.scaleY) / this.gridSize);
                    
                    if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
                        const intensity = point.intensity || 1;
                        
                        switch (point.type) {
                            case 'playerHit':
                                playerGrid[gridY][gridX] += intensity;
                                break;
                            case 'aiHit':
                                aiGrid[gridY][gridX] += intensity;
                                break;
                            case 'ballTrajectory':
                                ballGrid[gridY][gridX] += intensity;
                                break;
                        }
                    }
                });
                
                // Find max intensity across all grids
                this.maxIntensity = 0;
                [playerGrid, aiGrid, ballGrid].forEach(grid => {
                    grid.forEach(row => {
                        row.forEach(cell => {
                            this.maxIntensity = Math.max(this.maxIntensity, cell);
                        });
                    });
                });
                
                // Draw combined visualization
                for (let row = 0; row < gridRows; row++) {
                    for (let col = 0; col < gridCols; col++) {
                        const playerIntensity = playerGrid[row][col];
                        const aiIntensity = aiGrid[row][col];
                        const ballIntensity = ballGrid[row][col];
                        
                        if (playerIntensity > 0 || aiIntensity > 0 || ballIntensity > 0) {
                            // Blend colors based on different data types
                            const alpha = Math.min(0.8, (playerIntensity + aiIntensity + ballIntensity) / this.maxIntensity * 0.8 + 0.2);
                            const r = Math.min(255, (playerIntensity / this.maxIntensity) * 255);
                            const g = Math.min(255, (ballIntensity / this.maxIntensity) * 255);
                            const b = Math.min(255, (aiIntensity / this.maxIntensity) * 255);
                            
                            this.ctx.fillStyle = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, ${alpha})`;
                            this.ctx.fillRect(
                                col * this.gridSize,
                                row * this.gridSize,
                                this.gridSize,
                                this.gridSize
                            );
                        }
                    }
                }
            }
            
            drawGameField() {
                if (!this.ctx) return;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                
                // Draw center line
                this.ctx.setLineDash([2, 2]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.heatmapWidth / 2, 0);
                this.ctx.lineTo(this.heatmapWidth / 2, this.heatmapHeight);
                this.ctx.stroke();
                
                // Draw paddles
                this.ctx.setLineDash([]);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                
                // Player paddle (left)
                const playerPaddleX = 20 * this.scaleX;
                const paddleWidth = 10 * this.scaleX;
                const paddleHeight = 80 * this.scaleY;
                const centerY = (this.heatmapHeight - paddleHeight) / 2;
                
                this.ctx.fillRect(playerPaddleX, centerY, paddleWidth, paddleHeight);
                
                // AI paddle (right)
                const aiPaddleX = (800 - 30) * this.scaleX;
                this.ctx.fillRect(aiPaddleX, centerY, paddleWidth, paddleHeight);
            }
            
            clearCanvas() {
                if (!this.ctx) return;
                this.ctx.clearRect(0, 0, this.heatmapWidth, this.heatmapHeight);
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.heatmapWidth, this.heatmapHeight);
            }
            
            calculateAverageIntensity(data) {
                if (data.length === 0) return 0;
                const totalIntensity = data.reduce((sum, point) => sum + (point.intensity || 1), 0);
                return (totalIntensity / data.length).toFixed(2);
            }
        }
        
        // ===== POWER-UP SYSTEM =====
        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.width = 20; this.height = 20;
                this.life = 10; // seconds before despawn
                this.pulse = 0; // for visual pulsing effect
                this.collected = false;
                
                // Power-up definitions
                this.types = {
                    speedBoost: {color: '#ff6b6b', icon: '⚡', effect: 'Speed Boost!'},
                    sizeChange: {color: '#4ecdc4', icon: '📏', effect: 'Size Change!'},
                    freeze: {color: '#a8e6cf', icon: '❄️', effect: 'Freeze!'},
                    ballSize: {color: '#ffd54f', icon: '🔍', effect: 'Ball Size!'},
                    magnetic: {color: '#ff69b4', icon: '🧲', effect: 'Magnetic Ball!'}
                };
            }
            
            update(dt) {
                this.life -= dt;
                this.pulse += dt * 6; // pulsing animation speed
                return this.life > 0 && !this.collected;
            }
            
            draw(ctx) {
                const powerType = this.types[this.type];
                const pulseFactor = 1 + Math.sin(this.pulse) * 0.2;
                const size = this.width * pulseFactor;
                
                ctx.save();
                ctx.globalAlpha = Math.max(0.3, this.life / 10);
                
                // Glow effect
                ctx.shadowColor = powerType.color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = powerType.color;
                
                // Draw power-up background
                ctx.fillRect(this.x + (this.width - size)/2, this.y + (this.height - size)/2, size, size);
                
                // Draw icon
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.font = `${size * 0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(powerType.icon, this.x + this.width/2, this.y + this.height/2 + size * 0.2);
                
                ctx.restore();
            }
            
            checkCollision(paddle) {
                return this.x < paddle.x + paddle.width &&
                       this.x + this.width > paddle.x &&
                       this.y < paddle.y + paddle.height &&
                       this.y + this.height > paddle.y;
            }
        }

        // ===== GAME ENGINE =====
        class GameEngine {
            constructor(canvas, ctx) {
                this.canvas = canvas; this.ctx = ctx;
                this.gameMode = 'classic'; this.gameState = 'menu';
                
                // Game objects
                this.player = {x: 20, y: canvas.height/2-40, width: 10, height: 80, score: 0, lives: 3, 
                              prevY: canvas.height/2-40, velocity: 0};
                this.ai = {x: canvas.width-30, y: canvas.height/2-40, width: 10, height: 80, score: 0, 
                          difficulty: 'medium', personality: 'balanced', reactionTime: 0.1, errorRate: 0.1,
                          prevY: canvas.height/2-40, velocity: 0, targetY: canvas.height/2-40};
                this.ball = {x: canvas.width/2, y: canvas.height/2, width: 10, height: 10, 
                           vx: 5, vy: 3, maxSpeed: 15, speedIncrease: 0.02, trail: [], 
                           spin: 0, spinDecay: 0.95}; // spin: + = clockwise, - = counterclockwise
                
                // Machine Learning AI System
                this.mlAI = new MachineLearningAI();
                this.mlAI.loadFromStorage();
                this.lastPlayerPosition = canvas.height/2;
                this.ballDirectionChangeTime = 0;
                
                // Settings & effects
                this.settings = {winScore: 10, ballTrail: true, screenShake: true, particles: true, sound: true};
                this.screenShake = {x: 0, y: 0, intensity: 0, duration: 0};
                this.slowMotion = {active: false, factor: 1, duration: 0};
                
                // Power-ups system
                this.powerUps = [];
                this.playerEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.aiEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.lastPowerUpSpawn = 0;
                this.powerUpSpawnDelay = 8; // seconds
                this.ballSizeEffect = 0; // Timer for ball size effect
                this.magneticEffect = 0; // Timer for magnetic ball effect
                
                // Stats
                this.stats = {gamesPlayed: 0, gamesWon: 0, gamesLost: 0, longestRally: 0, 
                            currentRally: 0, totalHits: 0, perfectGames: 0};
                
                // Advanced Analytics
                this.analytics = {
                    playerBehavior: {
                        movementPattern: [], // Track player Y positions over time
                        reactionTimes: [], // Time between ball direction change and player response
                        hitZones: [], // Where player hits the ball (top, middle, bottom)
                        averagePosition: 0, // Player's average paddle position
                        defensiveStyle: 0, // How defensive vs aggressive (0-1)
                        consistency: 0 // How consistent player movement is (0-1)
                    },
                    heatMap: {
                        playerHits: [], // {x, y, intensity} for player paddle hits
                        aiHits: [], // {x, y, intensity} for AI paddle hits
                        ballTrajectories: [], // Ball position samples
                        scoringZones: [] // Where goals are scored from
                    },
                    gameFlow: {
                        rallyLengths: [],
                        gameRhythm: [], // Time between hits
                        intensityMoments: [], // High-action periods
                        comebackAttempts: 0
                    },
                    aiLearning: {
                        playerPreferences: {}, // What player tends to do in situations
                        successfulStrategies: [], // What works against this player
                        adaptationLevel: 0 // How much AI has learned (0-1)
                    }
                };
                this.loadStats();
                this.loadAnalytics();
                this.loadAchievements();
                
                // Achievement System
                this.achievements = {
                    unlocked: new Set(),
                    definitions: {
                        'first_win': {title: '🏆 First Victory', description: 'Win your first game', condition: () => this.stats.gamesWon >= 1},
                        'perfect_game': {title: '🎯 Flawless', description: 'Win without opponent scoring', condition: () => this.stats.perfectGames >= 1},
                        'streak_5': {title: '🔥 Hot Streak', description: 'Win 5 games in a row', condition: () => this.checkWinStreak(5)},
                        'rally_master': {title: '🏓 Rally Master', description: 'Achieve 50+ hit rally', condition: () => this.stats.longestRally >= 50},
                        'consistency': {title: '📏 Consistent Player', description: 'Maintain 80%+ movement consistency', condition: () => this.analytics.playerBehavior.consistency >= 0.8},
                        'quick_reflexes': {title: '⚡ Lightning Reflexes', description: 'Average reaction time under 200ms', condition: () => this.getAverageReactionTime() < 200},
                        'defensive_master': {title: '🛡️ Defensive Wall', description: 'Spend 80%+ time in center court', condition: () => this.analytics.playerBehavior.defensiveStyle >= 0.8},
                        'power_user': {title: '💪 Power Player', description: 'Collect 25 power-ups', condition: () => this.stats.powerUpsCollected >= 25},
                        'survivor': {title: '💀 Survivor', description: 'Win a survival mode game', condition: () => this.stats.survivalWins >= 1},
                        'speed_demon': {title: '🏃 Speed Demon', description: 'Win a speedball mode game', condition: () => this.stats.speedballWins >= 1},
                        'ai_tamer': {title: '🤖 AI Tamer', description: 'Beat all AI personalities', condition: () => this.checkAllPersonalitiesBeaten()},
                        'marathon': {title: '🏃‍♂️ Marathon Player', description: 'Play 100 games', condition: () => this.stats.gamesPlayed >= 100},
                        'dedication': {title: '⏰ Dedicated', description: 'Play for 60+ minutes total', condition: () => this.stats.totalPlayTime >= 3600000},
                        'comeback_king': {title: '👑 Comeback King', description: 'Win after being 5+ points behind', condition: () => this.stats.comebacks >= 1},
                        'tournament_winner': {title: '🏆 Tournament Champion', description: 'Win your first tournament', condition: () => this.checkTournamentVictory()},
                        'round_warrior': {title: '⚔️ Round Warrior', description: 'Reach tournament semi-finals', condition: () => this.checkTournamentRound(2)},
                        'bracket_buster': {title: '💥 Bracket Buster', description: 'Complete 5 tournaments', condition: () => this.checkTournamentCount(5)},
                        'tournament_master': {title: '👑 Tournament Master', description: 'Win 3 tournaments', condition: () => this.checkTournamentWins(3)},
                        'perfect_bracket': {title: '✨ Perfect Bracket', description: 'Win tournament without losing a match', condition: () => this.checkPerfectTournament()},
                        'ai_dominator': {title: '🤖 AI Dominator', description: 'Defeat all AI personalities in tournaments', condition: () => this.checkAllTournamentPersonalities()}
                    },
                    newlyUnlocked: [] // For showing achievement notifications
                };
                
                // Extended stats for achievements
                if (!this.stats.powerUpsCollected) this.stats.powerUpsCollected = 0;
                if (!this.stats.survivalWins) this.stats.survivalWins = 0;
                if (!this.stats.speedballWins) this.stats.speedballWins = 0;
                if (!this.stats.personalitiesBeaten) this.stats.personalitiesBeaten = new Set();
                if (!this.stats.currentWinStreak) this.stats.currentWinStreak = 0;
                if (!this.stats.maxWinStreak) this.stats.maxWinStreak = 0;
                if (!this.stats.comebacks) this.stats.comebacks = 0;
                if (!this.stats.totalPlayTime) this.stats.totalPlayTime = 0;
                if (!this.stats.gameStartTime) this.stats.gameStartTime = 0;
                
                // Tournament-specific stats
                if (!this.stats.tournamentsPlayed) this.stats.tournamentsPlayed = 0;
                if (!this.stats.tournamentWins) this.stats.tournamentWins = 0;
                if (!this.stats.tournamentBestRound) this.stats.tournamentBestRound = 0;
                if (!this.stats.perfectTournaments) this.stats.perfectTournaments = 0;
                if (!this.stats.tournamentPersonalitiesBeaten) this.stats.tournamentPersonalitiesBeaten = new Set();
                
                // Analytics tracking variables
                this.lastBallDirectionChange = 0;
                this.lastPlayerMove = 0;
                this.currentRallyStartTime = 0;
                this.lastHitTime = 0;
                this.playerMovementSamples = [];
                this.ballPositionSamples = [];
                
                this.setupControls();
            }
            
            setupControls() {
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.gameState === 'playing') {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseY = e.clientY - rect.top;
                        let targetY = mouseY - this.player.height / 2;
                        
                        // Apply freeze effect to player movement
                        if (this.playerEffects.freeze > 0) {
                            const currentCenter = this.player.y + this.player.height / 2;
                            const targetCenter = targetY + this.player.height / 2;
                            const diff = targetCenter - currentCenter;
                            targetY = this.player.y + diff * 0.2; // Slow movement when frozen
                        }
                        
                        const newY = Math.max(0, Math.min(this.canvas.height - this.player.height, targetY));
                        this.player.y = newY;
                        
                        // Send input to server for online multiplayer
                        if (this.gameMode === 'online' && socketManager && socketManager.isConnected) {
                            socketManager.sendPlayerInput({
                                type: 'paddle_move',
                                y: newY,
                                timestamp: Date.now()
                            });
                        }
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.gameState === 'playing') {
                        const rect = this.canvas.getBoundingClientRect();
                        const touchY = e.touches[0].clientY - rect.top;
                        const newY = Math.max(0, Math.min(this.canvas.height - this.player.height, 
                            touchY - this.player.height / 2));
                        this.player.y = newY;
                        
                        // Send input to server for online multiplayer
                        if (this.gameMode === 'online' && socketManager && socketManager.isConnected) {
                            socketManager.sendPlayerInput({
                                type: 'paddle_move',
                                y: newY,
                                timestamp: Date.now()
                            });
                        }
                    }
                }, { passive: false });
                
                document.addEventListener('keydown', (e) => {
                    if (this.gameMode === 'multiplayer' && this.gameState === 'playing') {
                        switch (e.key) {
                            case 'w': case 'W': this.player.y = Math.max(0, this.player.y - 20); break;
                            case 's': case 'S': this.player.y = Math.min(this.canvas.height - this.player.height, this.player.y + 20); break;
                            case 'ArrowUp': this.ai.y = Math.max(0, this.ai.y - 20); break;
                            case 'ArrowDown': this.ai.y = Math.min(this.canvas.height - this.ai.height, this.ai.y + 20); break;
                        }
                    }
                });
            }
            
            getDifficultySettings() {
                const difficulties = {
                    easy: { aiSpeed: 150, ballSpeed: 3, aiReactionTime: 0.2, aiError: 0.2 },
                    medium: { aiSpeed: 200, ballSpeed: 5, aiReactionTime: 0.1, aiError: 0.1 },
                    hard: { aiSpeed: 250, ballSpeed: 7, aiReactionTime: 0.05, aiError: 0.05 }
                };
                return difficulties[this.ai.difficulty] || difficulties.medium;
            }
            
            updateAI(dt) {
                if (this.gameMode === 'multiplayer') return;
                
                const ballCenterY = this.ball.y + this.ball.height / 2;
                let newTargetY = ballCenterY;
                let speed = this.getDifficultySettings().aiSpeed;
                
                // Initialize AI stuck detection if not exists
                if (!this.ai.stuckDetection) {
                    this.ai.stuckDetection = {
                        lastPosition: this.ai.y,
                        stuckTimer: 0,
                        resetThreshold: 2.0 // seconds
                    };
                }
                
                // Track if AI paddle is stuck
                const positionDiff = Math.abs(this.ai.y - this.ai.stuckDetection.lastPosition);
                if (positionDiff < 2) { // Less than 2 pixels movement
                    this.ai.stuckDetection.stuckTimer += dt;
                } else {
                    this.ai.stuckDetection.stuckTimer = 0;
                    this.ai.stuckDetection.lastPosition = this.ai.y;
                }
                
                // If stuck for too long, reset AI position and ML data
                if (this.ai.stuckDetection.stuckTimer > this.ai.stuckDetection.resetThreshold) {
                    console.log('AI paddle stuck detected - resetting position and ML data');
                    const centerY = this.canvas.height / 2 - this.ai.height / 2;
                    this.ai.y = centerY;
                    this.ai.targetY = ballCenterY;
                    
                    // Reset ML AI if it's the adaptive personality causing issues
                    if (this.ai.personality === 'adaptive' && this.mlAI) {
                        this.mlAI.learningModel.confidence = Math.max(0.2, this.mlAI.learningModel.confidence - 0.3);
                        console.log('Reduced ML AI confidence due to stuck behavior');
                    }
                    
                    this.ai.stuckDetection.stuckTimer = 0;
                    this.ai.stuckDetection.lastPosition = this.ai.y;
                }
                
                // Apply power-up effects
                if (this.aiEffects.speedBoost > 0) speed *= 1.8;
                if (this.aiEffects.freeze > 0) speed *= 0.2;
                
                // Record player movement for ML AI
                this.recordPlayerMovementData();
                
                // AI personality behavior
                switch (this.ai.personality) {
                    case 'defensive':
                        newTargetY = ballCenterY * 0.7 + (this.canvas.height / 2) * 0.3;
                        speed *= 0.8; break;
                    case 'aggressive':
                        if (this.ball.vx > 0) newTargetY = this.predictBallPosition();
                        speed *= 1.2; break;
                    case 'perfect':
                        speed *= 1.5; this.ai.errorRate = 0.01; break;
                    case 'unpredictable':
                        if (Math.random() < 0.1) newTargetY += (Math.random() - 0.5) * 50; break;
                    case 'trickster':
                        this.applyTricksterBehavior(newTargetY, dt); break;
                    case 'copycat':
                        newTargetY = this.applyCopycatBehavior(); break;
                    case 'adaptive':
                        // Use Machine Learning AI for adaptive behavior
                        newTargetY = this.mlAI.getAdaptiveTarget(
                            this.ball.x, this.ball.y, this.ball.vx, this.ball.vy,
                            this.player.y + this.player.height / 2,
                            this.ai.y + this.ai.height / 2
                        );
                        // Apply ML AI speed adjustment
                        speed *= this.mlAI.learningModel.adaptations.speedAdjustment;
                        break;
                    default:
                        if (this.ball.vx > 0) newTargetY = ballCenterY + this.ball.vy * 0.3;
                }
                
                // Apply reaction time and error
                if (Math.random() < this.ai.reactionTime) return;
                if (Math.random() < this.ai.errorRate) newTargetY += (Math.random() - 0.5) * 30;
                
                // Smooth interpolation to new target (prevents sudden jerky movements)
                const targetInterpolation = 0.1; // How quickly AI adjusts target (lower = smoother)
                this.ai.targetY = this.ai.targetY + (newTargetY - this.ai.targetY) * targetInterpolation;
                
                const targetPaddleY = this.ai.targetY - this.ai.height / 2;
                const difference = targetPaddleY - this.ai.y;
                
                // Add dead zone to prevent micro-adjustments and vibration
                const deadZone = 8; // pixels - increased for smoother movement
                if (Math.abs(difference) < deadZone) return;
                
                // Smooth movement with speed limiting
                const maxMoveDistance = speed * dt;
                const moveAmount = Math.sign(difference) * Math.min(Math.abs(difference), maxMoveDistance);
                
                this.ai.y += moveAmount;
                
                // Normal bounds checking - allow full movement range
                this.ai.y = Math.max(0, Math.min(this.canvas.height - this.ai.height, this.ai.y));
            }
            
            predictBallPosition() {
                const distanceToAI = this.ai.x - this.ball.x;
                const timeToReach = distanceToAI / Math.abs(this.ball.vx);
                return this.ball.y + this.ball.vy * timeToReach;
            }
            
            recordPlayerMovementData() {
                const currentPlayerY = this.player.y + this.player.height / 2;
                
                // Record basic movement pattern
                this.mlAI.recordPlayerAction('playerMovement', {
                    y: currentPlayerY,
                    ballX: this.ball.x,
                    ballY: this.ball.y,
                    ballVx: this.ball.vx,
                    ballVy: this.ball.vy
                });
                
                // Detect if player is in defensive zone
                const centerY = this.canvas.height / 2;
                if (Math.abs(currentPlayerY - centerY) < 60) {
                    this.mlAI.recordPlayerAction('defensiveZones', {
                        y: currentPlayerY,
                        ballDistance: Math.abs(this.ball.x - this.player.x)
                    });
                }
                
                // Record reaction time when ball direction changes
                if (this.ballDirectionChangeTime > 0 && Math.abs(currentPlayerY - this.lastPlayerPosition) > 5) {
                    const reactionTime = Date.now() - this.ballDirectionChangeTime;
                    this.mlAI.recordPlayerAction('reactionTimes', {
                        time: reactionTime,
                        ballSpeed: Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy),
                        playerMovement: Math.abs(currentPlayerY - this.lastPlayerPosition)
                    });
                    this.ballDirectionChangeTime = 0;
                }
                
                this.lastPlayerPosition = currentPlayerY;
            }
            
            update(dt) {
                if (this.gameState !== 'playing') return;
                
                // Screen shake
                if (this.screenShake.duration > 0) {
                    this.screenShake.duration -= dt;
                    const intensity = this.screenShake.intensity * (this.screenShake.duration / 0.5);
                    this.screenShake.x = (Math.random() - 0.5) * intensity;
                    this.screenShake.y = (Math.random() - 0.5) * intensity;
                } else {
                    this.screenShake.x = 0; this.screenShake.y = 0;
                }
                
                // Slow motion
                if (this.slowMotion.active) {
                    this.slowMotion.duration -= dt;
                    if (this.slowMotion.duration <= 0) {
                        this.slowMotion.active = false; this.slowMotion.factor = 1;
                    }
                }
                
                const effectiveDt = dt * this.slowMotion.factor;
                this.updatePowerUps(effectiveDt);
                this.updatePlayerEffects(effectiveDt);
                this.updatePaddleVelocities(effectiveDt);
                this.updateAI(effectiveDt);
                this.updateBall(effectiveDt);
                this.updateBallTrail();
                this.updateAnalytics(effectiveDt);
            }
            
            updateBall(dt) {
                // Apply magnetic effect before movement
                if (this.magneticEffect > 0) {
                    this.applyMagneticForce(dt);
                }
                
                // Apply spin effect to ball trajectory
                if (Math.abs(this.ball.spin) > 0.1) {
                    this.applySpinEffect(dt);
                }
                
                this.ball.x += this.ball.vx * dt * 60;
                this.ball.y += this.ball.vy * dt * 60;
                
                // Apply spin decay
                this.ball.spin *= this.ball.spinDecay;
                
                // Wall collision
                if (this.ball.y <= 0 || this.ball.y >= this.canvas.height - this.ball.height) {
                    this.ball.vy = -this.ball.vy;
                    this.ball.y = Math.max(0, Math.min(this.canvas.height - this.ball.height, this.ball.y));
                    this.addScreenShake(3);
                    audioSystem?.play('wallBounce');
                    particleSystem?.wallBounce(this.ball.x + this.ball.width/2, this.ball.y + this.ball.height/2);
                }
                
                this.checkPaddleCollision();
                this.checkBallPowerUpCollision();
                
                // Scoring
                if (this.ball.x < -this.ball.width) this.aiScored();
                else if (this.ball.x > this.canvas.width) this.playerScored();
                
                // Speed increase in speedball mode
                if (this.gameMode === 'speedball') {
                    const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                    if (speed < this.ball.maxSpeed) {
                        this.ball.vx *= (1 + this.ball.speedIncrease);
                        this.ball.vy *= (1 + this.ball.speedIncrease);
                    }
                }
            }
            
            checkBallPowerUpCollision() {
                // Check if ball collides with any power-ups
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    if (this.ball.x < powerUp.x + powerUp.width &&
                        this.ball.x + this.ball.width > powerUp.x &&
                        this.ball.y < powerUp.y + powerUp.height &&
                        this.ball.y + this.ball.height > powerUp.y) {
                        
                        // Randomly assign power-up to player or AI
                        const collector = Math.random() > 0.5 ? 'player' : 'ai';
                        this.collectPowerUp(powerUp, collector);
                        this.powerUps.splice(i, 1); // Remove the power-up
                    }
                }
            }
            
            checkPaddleCollision() {
                // Player paddle
                if (this.ball.x <= this.player.x + this.player.width &&
                    this.ball.x + this.ball.width >= this.player.x &&
                    this.ball.y <= this.player.y + this.player.height &&
                    this.ball.y + this.ball.height >= this.player.y &&
                    this.ball.vx < 0) {
                    
                    this.ball.vx = Math.abs(this.ball.vx);
                    this.ball.x = this.player.x + this.player.width;
                    const hitPos = (this.ball.y + this.ball.height/2) - (this.player.y + this.player.height/2);
                    this.ball.vy += hitPos * 0.15;
                    
                    // Add spin based on paddle velocity and hit position
                    const spinFactor = 0.02;
                    const paddleMovementSpin = this.player.velocity * spinFactor;
                    const hitPositionSpin = hitPos * 0.01; // Hit position affects spin
                    this.ball.spin = paddleMovementSpin + hitPositionSpin;
                    
                    this.stats.currentRally++; this.stats.totalHits++;
                    this.addScreenShake(5); this.addSlowMotion(0.3, 0.1);
                    audioSystem?.play('paddleHit');
                    particleSystem?.paddleHit(this.ball.x, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    backgroundEffect?.onBallHit();
                    
                    // Record analytics
                    this.recordHit(true, this.ball.x, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    this.lastBallDirectionChange = Date.now();
                    
                    // Record ML AI data for player hits
                    this.mlAI.recordPlayerAction('ballInterceptions', {
                        x: this.ball.x,
                        y: this.ball.y + this.ball.height/2,
                        paddleY: this.player.y + this.player.height/2,
                        hitPosition: hitPos,
                        ballSpeed: Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy)
                    });
                    
                    this.mlAI.recordPlayerAction('successfulHits', {
                        x: this.ball.x,
                        y: this.ball.y + this.ball.height/2,
                        zone: Math.floor((this.ball.y + this.ball.height/2) / 50)
                    });
                    
                    // Mark ball direction change for reaction time tracking
                    this.ballDirectionChangeTime = Date.now();
                }
                
                // AI paddle
                if (this.ball.x + this.ball.width >= this.ai.x &&
                    this.ball.x <= this.ai.x + this.ai.width &&
                    this.ball.y <= this.ai.y + this.ai.height &&
                    this.ball.y + this.ball.height >= this.ai.y &&
                    this.ball.vx > 0) {
                    
                    this.ball.vx = -Math.abs(this.ball.vx);
                    this.ball.x = this.ai.x - this.ball.width;
                    const hitPos = (this.ball.y + this.ball.height/2) - (this.ai.y + this.ai.height/2);
                    this.ball.vy += hitPos * 0.15;
                    
                    // Add spin based on paddle velocity and hit position (opposite direction from player)
                    const spinFactor = 0.02;
                    const paddleMovementSpin = -this.ai.velocity * spinFactor; // Negative for AI paddle
                    const hitPositionSpin = -hitPos * 0.01; // Opposite spin direction
                    this.ball.spin = paddleMovementSpin + hitPositionSpin;
                    
                    this.stats.currentRally++; this.stats.totalHits++;
                    this.addScreenShake(5); this.addSlowMotion(0.3, 0.1);
                    audioSystem?.play('paddleHit');
                    particleSystem?.paddleHit(this.ball.x + this.ball.width, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    backgroundEffect?.onBallHit();
                    
                    // Record analytics
                    this.recordHit(false, this.ball.x + this.ball.width, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    this.lastBallDirectionChange = Date.now();
                }
            }
            
            updateBallTrail() {
                if (!this.settings.ballTrail) return;
                this.ball.trail.push({x: this.ball.x + this.ball.width/2, y: this.ball.y + this.ball.height/2, age: 0});
                this.ball.trail = this.ball.trail.filter(point => { point.age += 1; return point.age < 20; });
            }
            
            playerScored() {
                this.player.score++;
                if (this.stats.currentRally > this.stats.longestRally) this.stats.longestRally = this.stats.currentRally;
                this.stats.currentRally = 0;
                audioSystem?.play('score');
                particleSystem?.scoreEffect(this.canvas.width / 4, this.canvas.height / 2, true);
                backgroundEffect?.onScore();
                this.resetBall(); this.addSlowMotion(0.5, 0.5);
                if (this.player.score >= this.settings.winScore) this.playerWon();
            }
            
            aiScored() {
                this.ai.score++;
                
                // Record player miss (weak spot) for ML AI
                this.mlAI.recordPlayerAction('weakSpots', {
                    x: this.ball.x,
                    y: this.ball.y + this.ball.height/2,
                    playerY: this.player.y + this.player.height/2,
                    missDistance: Math.abs((this.ball.y + this.ball.height/2) - (this.player.y + this.player.height/2))
                });
                
                if (this.gameMode === 'survival') {
                    this.player.lives--;
                    if (this.player.lives <= 0) { this.aiWon(); return; }
                }
                if (this.stats.currentRally > this.stats.longestRally) this.stats.longestRally = this.stats.currentRally;
                this.stats.currentRally = 0;
                audioSystem?.play('score');
                particleSystem?.scoreEffect(this.canvas.width * 3/4, this.canvas.height / 2, false);
                backgroundEffect?.onScore();
                this.resetBall();
                if (this.ai.score >= this.settings.winScore) this.aiWon();
            }
            
            playerWon() {
                this.gameState = 'gameOver'; this.stats.gamesPlayed++; this.stats.gamesWon++;
                if (this.ai.score === 0) this.stats.perfectGames++;
                
                // Track win streak
                this.stats.currentWinStreak++;
                if (this.stats.currentWinStreak > this.stats.maxWinStreak) {
                    this.stats.maxWinStreak = this.stats.currentWinStreak;
                }
                
                // Track personality beaten
                this.stats.personalitiesBeaten.add(this.ai.personality);
                
                // Track game mode victories
                if (this.gameMode === 'survival') this.stats.survivalWins++;
                if (this.gameMode === 'speedball') this.stats.speedballWins++;
                
                // ML AI analysis after game
                if (this.ai.personality === 'adaptive') {
                    this.mlAI.analyzeGamePatterns({
                        gamesPlayed: this.stats.gamesPlayed,
                        gamesWon: this.stats.gamesWon,
                        gameResult: 'win',
                        finalScore: {player: this.player.score, ai: this.ai.score}
                    });
                    this.mlAI.saveToStorage();
                }
                
                this.addScreenShake(10);
                audioSystem?.play('win');
                particleSystem?.winEffect(this.canvas.width, this.canvas.height);
                this.saveStats();
                this.saveAnalytics();
                
                // Track game completion for advanced analytics
                trackGameCompletion({
                    won: true,
                    playerScore: this.player.score,
                    aiScore: this.ai.score,
                    gameMode: this.gameMode,
                    aiPersonality: this.ai.personality,
                    timestamp: new Date().toISOString()
                });
                
                // Check achievements after game ends
                this.checkAchievements();
                
                // Handle tournament match completion
                if (this.gameMode === 'tournament' && enhancedTournamentSystem && enhancedTournamentSystem.currentMatch) {
                    const finalScore = { player: this.player.score, opponent: this.ai.score };
                    enhancedTournamentSystem.completeMatch(true, finalScore);
                    
                    // Don't auto-reset for tournaments - let tournament system handle flow
                    return;
                }
                
                setTimeout(() => this.resetGame(), 3000);
            }
            
            aiWon() {
                this.gameState = 'gameOver'; this.stats.gamesPlayed++; this.stats.gamesLost++;
                
                // Reset win streak on loss
                this.stats.currentWinStreak = 0;
                
                // ML AI analysis after game
                if (this.ai.personality === 'adaptive') {
                    this.mlAI.analyzeGamePatterns({
                        gamesPlayed: this.stats.gamesPlayed,
                        gamesWon: this.stats.gamesWon,
                        gameResult: 'loss',
                        finalScore: {player: this.player.score, ai: this.ai.score}
                    });
                    this.mlAI.saveToStorage();
                }
                
                this.addScreenShake(8);
                audioSystem?.play('lose');
                this.saveStats();
                this.saveAnalytics();
                
                // Track game completion for advanced analytics
                trackGameCompletion({
                    won: false,
                    playerScore: this.player.score,
                    aiScore: this.ai.score,
                    gameMode: this.gameMode,
                    aiPersonality: this.ai.personality,
                    timestamp: new Date().toISOString()
                });
                
                // Check achievements even on loss (some achievements might be reached)
                this.checkAchievements();
                
                // Handle tournament match completion
                if (this.gameMode === 'tournament' && enhancedTournamentSystem && enhancedTournamentSystem.currentMatch) {
                    const finalScore = { player: this.player.score, opponent: this.ai.score };
                    enhancedTournamentSystem.completeMatch(false, finalScore);
                    
                    // Don't auto-reset for tournaments - let tournament system handle flow
                    return;
                }
                
                setTimeout(() => this.resetGame(), 3000);
            }
            
            resetBall() {
                this.ball.x = this.canvas.width / 2 - this.ball.width / 2;
                this.ball.y = this.canvas.height / 2 - this.ball.height / 2;
                const settings = this.getDifficultySettings();
                this.ball.vx = (Math.random() > 0.5 ? 1 : -1) * settings.ballSpeed;
                this.ball.vy = (Math.random() - 0.5) * settings.ballSpeed;
                this.ball.trail = [];
            }
            
            resetGame() {
                this.player.score = 0; this.ai.score = 0; this.player.lives = 3;
                this.stats.currentRally = 0;
                this.player.y = this.canvas.height / 2 - this.player.height / 2;
                this.ai.y = this.canvas.height / 2 - this.ai.height / 2;
                
                // Clear power-ups and effects
                this.powerUps = [];
                this.playerEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.aiEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.ballSizeEffect = 0;
                this.magneticEffect = 0;
                this.lastPowerUpSpawn = 0;
                this.player.height = 80;
                this.ai.height = 80;
                this.ball.width = 10;
                this.ball.height = 10;
                
                this.resetBall(); this.gameState = 'playing';
                audioSystem?.play('gameStart');
            }
            
            setGameMode(mode) {
                this.gameMode = mode;
                switch (mode) {
                    case 'speedball': this.ball.speedIncrease = 0.02; break;
                    case 'survival': this.player.lives = 5; this.settings.winScore = 999; break;
                    case 'tournament': this.settings.winScore = 7; break;
                    case 'practice': this.settings.winScore = 999; break;
                }
                this.resetGame();
            }
            
            setAIPersonality(personality) {
                this.ai.personality = personality;
                switch (personality) {
                    case 'defensive': this.ai.reactionTime = 0.15; this.ai.errorRate = 0.12; break;
                    case 'aggressive': this.ai.reactionTime = 0.08; this.ai.errorRate = 0.08; break;
                    case 'perfect': this.ai.reactionTime = 0.02; this.ai.errorRate = 0.01; break;
                    case 'unpredictable': this.ai.reactionTime = 0.1 + Math.random() * 0.1; this.ai.errorRate = 0.15; break;
                    case 'trickster': 
                        this.ai.reactionTime = 0.12; this.ai.errorRate = 0.1;
                        this.ai.tricksterState = {fakeDirection: 0, fakeTimer: 0, realTarget: 0}; break;
                    case 'copycat':
                        this.ai.reactionTime = 0.1; this.ai.errorRate = 0.08;
                        this.ai.copycatMemory = []; break;
                    case 'adaptive':
                        this.ai.reactionTime = 0.1; this.ai.errorRate = 0.1;
                        this.ai.adaptiveStrategy = {currentStrategy: 'balanced', confidence: 0.5}; break;
                    default: this.ai.reactionTime = 0.1; this.ai.errorRate = 0.1;
                }
            }
            
            applyTricksterBehavior(targetY, dt) {
                // Trickster AI uses fake movements to confuse the player
                if (!this.ai.tricksterState) {
                    this.ai.tricksterState = {fakeDirection: 0, fakeTimer: 0, realTarget: targetY};
                }
                
                this.ai.tricksterState.fakeTimer -= dt;
                
                // Occasionally start a fake movement
                if (this.ai.tricksterState.fakeTimer <= 0 && Math.random() < 0.3) {
                    this.ai.tricksterState.fakeDirection = (Math.random() - 0.5) * 100;
                    this.ai.tricksterState.fakeTimer = 0.5 + Math.random() * 0.5;
                    this.ai.tricksterState.realTarget = targetY;
                }
                
                // Apply fake movement or real movement
                if (this.ai.tricksterState.fakeTimer > 0) {
                    return this.ai.y + this.ai.tricksterState.fakeDirection;
                } else {
                    return this.ai.tricksterState.realTarget;
                }
            }
            
            applyCopycatBehavior() {
                // Copycat AI mimics player movement patterns
                if (!this.ai.copycatMemory) this.ai.copycatMemory = [];
                
                // Record player positions
                this.ai.copycatMemory.push({
                    playerY: this.player.y,
                    ballY: this.ball.y,
                    time: Date.now()
                });
                
                // Keep only recent memory (last 3 seconds)
                const now = Date.now();
                this.ai.copycatMemory = this.ai.copycatMemory.filter(m => now - m.time < 3000);
                
                // Find similar ball position in memory and copy player response
                const currentBallY = this.ball.y;
                let bestMatch = null;
                let bestDistance = Infinity;
                
                this.ai.copycatMemory.forEach(memory => {
                    const distance = Math.abs(memory.ballY - currentBallY);
                    if (distance < bestDistance && distance < 50) {
                        bestDistance = distance;
                        bestMatch = memory;
                    }
                });
                
                if (bestMatch) {
                    // Mirror the player's position relative to ball
                    const mirrorOffset = bestMatch.playerY - bestMatch.ballY;
                    return currentBallY + mirrorOffset;
                } else {
                    // Fall back to normal behavior if no pattern found
                    return this.ball.y + this.ball.height / 2;
                }
            }
            
            applyAdaptiveBehavior(ballCenterY) {
                // Adaptive AI learns from player patterns and adjusts strategy
                if (!this.ai.adaptiveStrategy) {
                    this.ai.adaptiveStrategy = {currentStrategy: 'balanced', confidence: 0.5};
                }
                
                // Analyze recent player performance
                const recentPerformance = this.analyzePlayerPerformance();
                
                // Adjust strategy based on what's working
                if (recentPerformance.playerWinRate < 0.3) {
                    this.ai.adaptiveStrategy.currentStrategy = 'defensive';
                    this.ai.adaptiveStrategy.confidence = Math.min(1, this.ai.adaptiveStrategy.confidence + 0.1);
                } else if (recentPerformance.playerWinRate > 0.7) {
                    this.ai.adaptiveStrategy.currentStrategy = 'aggressive';
                    this.ai.adaptiveStrategy.confidence = Math.min(1, this.ai.adaptiveStrategy.confidence + 0.1);
                } else {
                    this.ai.adaptiveStrategy.currentStrategy = 'balanced';
                }
                
                // Apply the current strategy with confidence weighting
                let targetY = ballCenterY;
                const confidence = this.ai.adaptiveStrategy.confidence;
                
                switch (this.ai.adaptiveStrategy.currentStrategy) {
                    case 'defensive':
                        targetY = ballCenterY * (0.6 + confidence * 0.2) + (this.canvas.height / 2) * (0.4 - confidence * 0.2);
                        break;
                    case 'aggressive':
                        if (this.ball.vx > 0) {
                            targetY = this.predictBallPosition() * (0.8 + confidence * 0.2);
                        }
                        break;
                    default:
                        targetY = ballCenterY + this.ball.vy * (0.2 + confidence * 0.3);
                }
                
                return targetY;
            }
            
            analyzePlayerPerformance() {
                // Analyze recent player performance for adaptive AI
                const recentGames = Math.min(5, this.stats.gamesPlayed);
                if (recentGames === 0) {
                    return {playerWinRate: 0.5, averageRally: 0, consistency: 0.5};
                }
                
                const playerWinRate = this.stats.gamesWon / this.stats.gamesPlayed;
                const averageRally = this.stats.totalHits / this.stats.gamesPlayed;
                const consistency = this.analytics.playerBehavior.consistency || 0.5;
                
                return {playerWinRate, averageRally, consistency};
            }
            
            addScreenShake(intensity) {
                if (this.settings.screenShake) {
                    this.screenShake.intensity = intensity; this.screenShake.duration = 0.5;
                }
            }
            
            addSlowMotion(factor, duration) {
                this.slowMotion.active = true; this.slowMotion.factor = factor; this.slowMotion.duration = duration;
            }
            
            applyMagneticForce(dt) {
                const ballCenterX = this.ball.x + this.ball.width / 2;
                const ballCenterY = this.ball.y + this.ball.height / 2;
                const magneticStrength = 80; // Adjust this for stronger/weaker attraction
                const maxDistance = 100; // Maximum distance for magnetic effect
                
                // Check attraction to player paddle
                const playerCenterX = this.player.x + this.player.width / 2;
                const playerCenterY = this.player.y + this.player.height / 2;
                const distanceToPlayer = Math.sqrt(
                    Math.pow(ballCenterX - playerCenterX, 2) + 
                    Math.pow(ballCenterY - playerCenterY, 2)
                );
                
                if (distanceToPlayer < maxDistance && distanceToPlayer > 0) {
                    const forceStrength = (1 - distanceToPlayer / maxDistance) * magneticStrength;
                    const forceX = (playerCenterX - ballCenterX) / distanceToPlayer * forceStrength;
                    const forceY = (playerCenterY - ballCenterY) / distanceToPlayer * forceStrength;
                    
                    this.ball.vx += forceX * dt;
                    this.ball.vy += forceY * dt;
                }
                
                // Check attraction to AI paddle
                const aiCenterX = this.ai.x + this.ai.width / 2;
                const aiCenterY = this.ai.y + this.ai.height / 2;
                const distanceToAI = Math.sqrt(
                    Math.pow(ballCenterX - aiCenterX, 2) + 
                    Math.pow(ballCenterY - aiCenterY, 2)
                );
                
                if (distanceToAI < maxDistance && distanceToAI > 0) {
                    const forceStrength = (1 - distanceToAI / maxDistance) * magneticStrength;
                    const forceX = (aiCenterX - ballCenterX) / distanceToAI * forceStrength;
                    const forceY = (aiCenterY - ballCenterY) / distanceToAI * forceStrength;
                    
                    this.ball.vx += forceX * dt;
                    this.ball.vy += forceY * dt;
                }
                
                // Limit ball speed to prevent it from going too fast
                const maxSpeed = this.ball.maxSpeed * 1.2;
                const currentSpeed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                if (currentSpeed > maxSpeed) {
                    this.ball.vx = (this.ball.vx / currentSpeed) * maxSpeed;
                    this.ball.vy = (this.ball.vy / currentSpeed) * maxSpeed;
                }
            }
            
            applySpinEffect(dt) {
                // Spin creates a perpendicular force (Magnus effect)
                const spinStrength = 0.3;
                const currentSpeed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                
                if (currentSpeed > 0) {
                    // Normalize velocity vector
                    const normalizedVx = this.ball.vx / currentSpeed;
                    const normalizedVy = this.ball.vy / currentSpeed;
                    
                    // Calculate perpendicular force (spin effect)
                    const spinForceX = -normalizedVy * this.ball.spin * spinStrength;
                    const spinForceY = normalizedVx * this.ball.spin * spinStrength;
                    
                    // Apply spin force
                    this.ball.vx += spinForceX * dt * 60;
                    this.ball.vy += spinForceY * dt * 60;
                }
            }
            
            updatePaddleVelocities(dt) {
                // Calculate paddle velocities for spin effects
                this.player.velocity = (this.player.y - this.player.prevY) / dt;
                this.ai.velocity = (this.ai.y - this.ai.prevY) / dt;
                
                // Store previous positions
                this.player.prevY = this.player.y;
                this.ai.prevY = this.ai.y;
                
                // Smooth velocity to avoid jitter
                this.player.velocity *= 0.8;
                this.ai.velocity *= 0.8;
            }
            
            updatePowerUps(dt) {
                // Spawn new power-ups periodically
                this.lastPowerUpSpawn += dt;
                if (this.lastPowerUpSpawn >= this.powerUpSpawnDelay) {
                    this.spawnPowerUp();
                    this.lastPowerUpSpawn = 0;
                }
                
                // Update existing power-ups
                this.powerUps = this.powerUps.filter(powerUp => {
                    const alive = powerUp.update(dt);
                    if (alive) {
                        // Check collisions with paddles
                        if (powerUp.checkCollision(this.player)) {
                            this.collectPowerUp(powerUp, 'player');
                            return false;
                        } else if (powerUp.checkCollision(this.ai)) {
                            this.collectPowerUp(powerUp, 'ai');
                            return false;
                        }
                    }
                    return alive;
                });
            }
            
            spawnPowerUp() {
                const types = ['speedBoost', 'sizeChange', 'freeze', 'ballSize', 'magnetic'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = this.canvas.width * 0.3 + Math.random() * this.canvas.width * 0.4;
                const y = 50 + Math.random() * (this.canvas.height - 100);
                this.powerUps.push(new PowerUp(x, y, type));
            }
            
            collectPowerUp(powerUp, collector) {
                powerUp.collected = true;
                const effectDuration = 5; // seconds
                
                // Track power-up collection for achievements
                this.stats.powerUpsCollected++;
                
                switch (powerUp.type) {
                    case 'speedBoost':
                        if (collector === 'player') this.playerEffects.speedBoost = effectDuration;
                        else this.aiEffects.speedBoost = effectDuration;
                        break;
                    case 'sizeChange':
                        if (collector === 'player') this.playerEffects.sizeChange = effectDuration;
                        else this.aiEffects.sizeChange = effectDuration;
                        break;
                    case 'freeze':
                        // Freeze effect affects the opponent
                        if (collector === 'player') this.aiEffects.freeze = effectDuration;
                        else this.playerEffects.freeze = effectDuration;
                        break;
                    case 'ballSize':
                        // Ball size effect is global (affects the ball itself)
                        this.ballSizeEffect = effectDuration;
                        const sizeMultiplier = Math.random() > 0.5 ? 1.8 : 0.6; // Bigger or smaller
                        this.ball.width *= sizeMultiplier;
                        this.ball.height *= sizeMultiplier;
                        break;
                    case 'magnetic':
                        // Magnetic effect is global (affects ball movement)
                        this.magneticEffect = effectDuration;
                        break;
                }
                
                audioSystem?.play('score');
                particleSystem?.scoreEffect(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, collector === 'player');
                backgroundEffect?.onPowerUpCollected();
            }
            
            updatePlayerEffects(dt) {
                // Update player effects
                Object.keys(this.playerEffects).forEach(effect => {
                    if (this.playerEffects[effect] > 0) {
                        this.playerEffects[effect] -= dt;
                        if (this.playerEffects[effect] <= 0) {
                            this.playerEffects[effect] = 0;
                        }
                    }
                });
                
                // Update AI effects
                Object.keys(this.aiEffects).forEach(effect => {
                    if (this.aiEffects[effect] > 0) {
                        this.aiEffects[effect] -= dt;
                        if (this.aiEffects[effect] <= 0) {
                            this.aiEffects[effect] = 0;
                        }
                    }
                });
                
                // Update ball size effect
                if (this.ballSizeEffect > 0) {
                    this.ballSizeEffect -= dt;
                    if (this.ballSizeEffect <= 0) {
                        // Reset ball to original size
                        this.ball.width = 10;
                        this.ball.height = 10;
                    }
                }
                
                // Update magnetic effect
                if (this.magneticEffect > 0) {
                    this.magneticEffect -= dt;
                    if (this.magneticEffect <= 0) {
                        this.magneticEffect = 0;
                    }
                }
                
                // Apply size changes
                const playerBaseHeight = 80;
                const aiBaseHeight = 80;
                this.player.height = playerBaseHeight * (this.playerEffects.sizeChange > 0 ? 1.5 : 1);
                this.ai.height = aiBaseHeight * (this.aiEffects.sizeChange > 0 ? 1.5 : 1);
            }
            
            saveStats() { 
                const statsToSave = { ...this.stats };
                // Convert Set to Array for storage
                if (this.stats.personalitiesBeaten instanceof Set) {
                    statsToSave.personalitiesBeaten = Array.from(this.stats.personalitiesBeaten);
                }
                localStorage.setItem('pongStats', JSON.stringify(statsToSave)); 
            }
            loadStats() {
                const saved = localStorage.getItem('pongStats');
                if (saved) {
                    const loadedStats = JSON.parse(saved);
                    this.stats = { ...this.stats, ...loadedStats };
                    // Convert Array back to Set if needed
                    if (Array.isArray(this.stats.personalitiesBeaten)) {
                        this.stats.personalitiesBeaten = new Set(this.stats.personalitiesBeaten);
                    }
                }
            }
            
            saveAnalytics() { 
                localStorage.setItem('pongAnalytics', JSON.stringify(this.analytics)); 
            }
            
            loadAnalytics() {
                const saved = localStorage.getItem('pongAnalytics');
                if (saved) {
                    const savedAnalytics = JSON.parse(saved);
                    this.analytics = { ...this.analytics, ...savedAnalytics };
                }
            }
            
            updateAnalytics(dt) {
                // Track player movement patterns
                this.playerMovementSamples.push({
                    y: this.player.y + this.player.height / 2,
                    time: Date.now()
                });
                
                // Keep only recent samples (last 10 seconds)
                const now = Date.now();
                this.playerMovementSamples = this.playerMovementSamples.filter(s => now - s.time < 10000);
                
                // Track ball trajectory for heat map
                this.ballPositionSamples.push({
                    x: this.ball.x + this.ball.width / 2,
                    y: this.ball.y + this.ball.height / 2,
                    time: now
                });
                
                // Keep recent ball samples
                this.ballPositionSamples = this.ballPositionSamples.filter(s => now - s.time < 5000);
                
                // Add to heat map trajectories
                if (this.analytics.heatMap.ballTrajectories.length < 1000) {
                    this.analytics.heatMap.ballTrajectories.push({
                        x: this.ball.x + this.ball.width / 2,
                        y: this.ball.y + this.ball.height / 2,
                        intensity: 1
                    });
                }
                
                // Calculate player behavior metrics
                this.calculateBehaviorMetrics();
            }
            
            calculateBehaviorMetrics() {
                if (this.playerMovementSamples.length < 10) return;
                
                // Calculate average position
                const totalY = this.playerMovementSamples.reduce((sum, sample) => sum + sample.y, 0);
                this.analytics.playerBehavior.averagePosition = totalY / this.playerMovementSamples.length;
                
                // Calculate movement consistency (lower variance = higher consistency)
                const avgY = this.analytics.playerBehavior.averagePosition;
                const variance = this.playerMovementSamples.reduce((sum, sample) => 
                    sum + Math.pow(sample.y - avgY, 2), 0) / this.playerMovementSamples.length;
                this.analytics.playerBehavior.consistency = Math.max(0, Math.min(1, 1 - (variance / 10000)));
                
                // Calculate defensive style (how much time spent in defensive vs aggressive positions)
                const defensivePositions = this.playerMovementSamples.filter(s => 
                    Math.abs(s.y - this.canvas.height / 2) < this.canvas.height * 0.25).length;
                this.analytics.playerBehavior.defensiveStyle = defensivePositions / this.playerMovementSamples.length;
            }
            
            recordHit(isPlayer, x, y, ballVx, ballVy) {
                // Record hit for heat map
                const hitData = {
                    x: x,
                    y: y,
                    intensity: Math.abs(ballVx) + Math.abs(ballVy), // Intensity based on ball speed
                    time: Date.now()
                };
                
                if (isPlayer) {
                    this.analytics.heatMap.playerHits.push(hitData);
                    // Keep only recent hits (last 100)
                    if (this.analytics.heatMap.playerHits.length > 100) {
                        this.analytics.heatMap.playerHits.shift();
                    }
                    
                    // Record hit zone (top, middle, bottom of paddle)
                    const paddleCenter = this.player.y + this.player.height / 2;
                    const hitOffset = y - paddleCenter;
                    let zone = 'middle';
                    if (hitOffset < -this.player.height * 0.25) zone = 'top';
                    else if (hitOffset > this.player.height * 0.25) zone = 'bottom';
                    
                    this.analytics.playerBehavior.hitZones.push(zone);
                    if (this.analytics.playerBehavior.hitZones.length > 50) {
                        this.analytics.playerBehavior.hitZones.shift();
                    }
                } else {
                    this.analytics.heatMap.aiHits.push(hitData);
                    if (this.analytics.heatMap.aiHits.length > 100) {
                        this.analytics.heatMap.aiHits.shift();
                    }
                }
                
                // Record game rhythm
                const timeSinceLastHit = Date.now() - this.lastHitTime;
                if (this.lastHitTime > 0) {
                    this.analytics.gameFlow.gameRhythm.push(timeSinceLastHit);
                    if (this.analytics.gameFlow.gameRhythm.length > 50) {
                        this.analytics.gameFlow.gameRhythm.shift();
                    }
                }
                this.lastHitTime = Date.now();
                
                // Track reaction time for player hits
                if (isPlayer && this.lastBallDirectionChange > 0) {
                    const reactionTime = Date.now() - this.lastBallDirectionChange;
                    this.analytics.playerBehavior.reactionTimes.push(reactionTime);
                    if (this.analytics.playerBehavior.reactionTimes.length > 20) {
                        this.analytics.playerBehavior.reactionTimes.shift();
                    }
                }
            }
            
            // Achievement System Methods
            loadAchievements() {
                const saved = localStorage.getItem('pongAchievements');
                if (saved) {
                    const savedAchievements = JSON.parse(saved);
                    this.achievements.unlocked = new Set(savedAchievements.unlocked || []);
                }
            }
            
            saveAchievements() {
                const achievementsData = {
                    unlocked: Array.from(this.achievements.unlocked)
                };
                localStorage.setItem('pongAchievements', JSON.stringify(achievementsData));
            }
            
            checkAchievements() {
                Object.keys(this.achievements.definitions).forEach(achievementId => {
                    if (!this.achievements.unlocked.has(achievementId)) {
                        const achievement = this.achievements.definitions[achievementId];
                        try {
                            if (achievement.condition()) {
                                this.unlockAchievement(achievementId);
                            }
                        } catch (e) {
                            // Silently fail if condition check fails
                            console.warn(`Achievement condition failed for ${achievementId}:`, e);
                        }
                    }
                });
            }
            
            unlockAchievement(achievementId) {
                if (!this.achievements.unlocked.has(achievementId)) {
                    this.achievements.unlocked.add(achievementId);
                    this.achievements.newlyUnlocked.push(achievementId);
                    this.saveAchievements();
                    
                    // Show achievement notification
                    this.showAchievementNotification(achievementId);
                }
            }
            
            showAchievementNotification(achievementId) {
                const achievement = this.achievements.definitions[achievementId];
                if (achievement && typeof console !== 'undefined') {
                    console.log(`🏆 Achievement Unlocked: ${achievement.title} - ${achievement.description}`);
                }
            }
            
            getAverageReactionTime() {
                const reactionTimes = this.analytics.playerBehavior.reactionTimes;
                if (reactionTimes.length === 0) return 1000;
                return reactionTimes.reduce((sum, time) => sum + time, 0) / reactionTimes.length;
            }
            
            checkWinStreak(targetStreak) {
                return this.stats.maxWinStreak >= targetStreak;
            }
            
            checkAllPersonalitiesBeaten() {
                const personalities = ['balanced', 'defensive', 'aggressive', 'perfect', 'unpredictable', 'trickster', 'copycat', 'adaptive'];
                return personalities.every(personality => this.stats.personalitiesBeaten.has(personality));
            }
            
            checkTournamentVictory() {
                return (this.stats.tournamentWins || 0) >= 1;
            }
            
            checkTournamentRound(targetRound) {
                return (this.stats.tournamentBestRound || 0) >= targetRound;
            }
            
            checkTournamentCount(count) {
                return (this.stats.tournamentsPlayed || 0) >= count;
            }
            
            checkTournamentWins(wins) {
                return (this.stats.tournamentWins || 0) >= wins;
            }
            
            checkPerfectTournament() {
                return (this.stats.perfectTournaments || 0) >= 1;
            }
            
            checkAllTournamentPersonalities() {
                const tournamentPersonalities = this.stats.tournamentPersonalitiesBeaten || new Set();
                const personalities = ['balanced', 'defensive', 'aggressive', 'perfect', 'unpredictable', 'trickster', 'copycat', 'adaptive'];
                return personalities.every(personality => tournamentPersonalities.has(personality));
            }
            
            getStats() {
                return {
                    ...this.stats,
                    winRate: this.stats.gamesPlayed > 0 ? (this.stats.gamesWon / this.stats.gamesPlayed * 100).toFixed(1) : 0,
                    averageRally: this.stats.gamesPlayed > 0 ? (this.stats.totalHits / this.stats.gamesPlayed).toFixed(1) : 0
                };
            }
        }

        // ===== SOCKET MANAGER =====
        class SocketManager {
            constructor() {
                this.socket = null;
                this.isConnected = false;
                this.user = null;
                this.currentRoom = null;
                this.latency = 0;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.eventHandlers = new Map();
                this.serverUrl = 'http://localhost:3001'; // Backend server URL
                
                // Heartbeat for latency calculation
                this.lastPingTime = 0;
                this.pingInterval = null;
                
                this.init();
            }
            
            init() {
                this.connect();
            }
            
            connect() {
                try {
                    // Initialize Socket.io connection
                    this.socket = io(this.serverUrl, {
                        autoConnect: true,
                        timeout: 5000,
                        transports: ['websocket', 'polling']
                    });
                    
                    this.setupEventListeners();
                    console.log('🔌 Attempting to connect to multiplayer server...');
                } catch (error) {
                    console.error('❌ Failed to initialize socket connection:', error);
                    this.updateConnectionStatus('error');
                }
            }
            
            setupEventListeners() {
                // Connection events
                this.socket.on('connect', () => {
                    console.log('✅ Connected to multiplayer server');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.updateConnectionStatus('connected');
                    this.startPingPong();
                });
                
                this.socket.on('disconnect', (reason) => {
                    console.log('❌ Disconnected from server:', reason);
                    this.isConnected = false;
                    this.updateConnectionStatus('disconnected');
                    this.stopPingPong();
                    
                    // Attempt to reconnect if not intentional
                    if (reason === 'io server disconnect') {
                        this.attemptReconnect();
                    }
                });
                
                this.socket.on('connect_error', (error) => {
                    console.error('❌ Connection error:', error);
                    this.updateConnectionStatus('error');
                    this.attemptReconnect();
                });
                
                // Latency monitoring
                this.socket.on('pong', () => {
                    this.latency = Date.now() - this.lastPingTime;
                    this.updateLatencyDisplay();
                });
                
                // Authentication responses
                this.socket.on('auth:success', (userData) => {
                    console.log('🔐 Authentication successful:', userData.user.username);
                    this.user = userData.user;
                    this.updateUserDisplay();
                    this.emit('userAuthenticated', userData.user);
                });
                
                this.socket.on('auth:error', (error) => {
                    console.error('❌ Authentication failed:', error);
                    this.emit('authError', error);
                });
                
                // Matchmaking events
                this.socket.on('matchmaking:found', (matchData) => {
                    console.log('🎮 Match found:', matchData);
                    this.emit('matchFound', matchData);
                });
                
                this.socket.on('matchmaking:cancelled', () => {
                    console.log('⏹️ Matchmaking cancelled');
                    this.emit('matchmakingCancelled');
                });
                
                // Game events
                this.socket.on('game:start', (gameData) => {
                    console.log('🚀 Game starting:', gameData);
                    this.emit('gameStart', gameData);
                });
                
                this.socket.on('game:update', (gameState) => {
                    this.emit('gameUpdate', gameState);
                });
                
                this.socket.on('game:end', (result) => {
                    console.log('🏁 Game ended:', result);
                    this.emit('gameEnd', result);
                });
                
                // Chat events
                this.socket.on('chat:message', (messageData) => {
                    this.emit('chatMessage', messageData);
                });
                
                // Friend system events
                this.socket.on('friend:request', (friendData) => {
                    this.emit('friendRequest', friendData);
                });
                
                this.socket.on('friend:accepted', (friendData) => {
                    this.emit('friendAccepted', friendData);
                });
                
                // Error handling
                this.socket.on('error', (error) => {
                    console.error('🔴 Socket error:', error);
                    this.emit('socketError', error);
                });
            }
            
            // Event system for internal communication
            on(event, handler) {
                if (!this.eventHandlers.has(event)) {
                    this.eventHandlers.set(event, []);
                }
                this.eventHandlers.get(event).push(handler);
            }
            
            emit(event, data) {
                if (this.eventHandlers.has(event)) {
                    this.eventHandlers.get(event).forEach(handler => {
                        try {
                            handler(data);
                        } catch (error) {
                            console.error(`Error in event handler for ${event}:`, error);
                        }
                    });
                }
            }
            
            // Authentication methods
            async authenticate(token) {
                if (!this.isConnected) {
                    throw new Error('Not connected to server');
                }
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Authentication timeout'));
                    }, 5000);
                    
                    this.socket.emit('auth:token', { token });
                    
                    this.socket.once('auth:success', (userData) => {
                        clearTimeout(timeout);
                        resolve(userData);
                    });
                    
                    this.socket.once('auth:error', (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });
            }
            
            async register(userData) {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Registration timeout'));
                    }, 10000);
                    
                    this.socket.emit('auth:register', userData);
                    
                    this.socket.once('auth:success', (result) => {
                        clearTimeout(timeout);
                        resolve(result);
                    });
                    
                    this.socket.once('auth:error', (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });
            }
            
            async login(credentials) {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Login timeout'));
                    }, 10000);
                    
                    this.socket.emit('auth:login', credentials);
                    
                    this.socket.once('auth:success', (result) => {
                        clearTimeout(timeout);
                        resolve(result);
                    });
                    
                    this.socket.once('auth:error', (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });
            }
            
            // Matchmaking methods
            startMatchmaking(preferences = {}) {
                if (!this.isConnected || !this.user) {
                    throw new Error('Must be connected and authenticated');
                }
                
                this.socket.emit('matchmaking:join', preferences);
            }
            
            cancelMatchmaking() {
                this.socket.emit('matchmaking:leave');
            }
            
            // Game methods
            sendPlayerInput(inputData) {
                if (this.currentRoom) {
                    this.socket.emit('game:input', {
                        roomId: this.currentRoom,
                        input: inputData
                    });
                }
            }
            
            // Chat methods
            sendChatMessage(message, type = 'lobby') {
                this.socket.emit('chat:send', {
                    message: message,
                    type: type,
                    roomId: this.currentRoom
                });
            }
            
            // Friend system methods
            sendFriendRequest(username) {
                this.socket.emit('friend:request', { username });
            }
            
            acceptFriendRequest(friendId) {
                this.socket.emit('friend:accept', { friendId });
            }
            
            // Utility methods
            startPingPong() {
                this.pingInterval = setInterval(() => {
                    if (this.isConnected) {
                        this.lastPingTime = Date.now();
                        this.socket.emit('ping');
                    }
                }, 1000);
            }
            
            stopPingPong() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }
            
            attemptReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    console.error('❌ Max reconnection attempts reached');
                    this.updateConnectionStatus('failed');
                    return;
                }
                
                this.reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
                
                console.log(`🔄 Reconnecting attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms`);
                
                setTimeout(() => {
                    this.socket.connect();
                }, delay);
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('multiplayerStatus');
                if (statusElement) {
                    let statusText, statusEmoji;
                    
                    switch (status) {
                        case 'connected':
                            statusText = 'Connected';
                            statusEmoji = '✅';
                            break;
                        case 'connecting':
                            statusText = 'Connecting...';
                            statusEmoji = '🔄';
                            break;
                        case 'disconnected':
                            statusText = 'Disconnected';
                            statusEmoji = '❌';
                            break;
                        case 'error':
                            statusText = 'Connection Error';
                            statusEmoji = '🔴';
                            break;
                        case 'failed':
                            statusText = 'Connection Failed';
                            statusEmoji = '💀';
                            break;
                        default:
                            statusText = 'Unknown';
                            statusEmoji = '❓';
                    }
                    
                    statusElement.textContent = `${statusEmoji} ${statusText}`;
                }
                
                // Also update auth panel status
                updateAuthServerStatus();
            }
            
            updateLatencyDisplay() {
                const latencyElement = document.getElementById('latencyDisplay');
                if (latencyElement) {
                    latencyElement.textContent = `${this.latency}ms`;
                }
            }
            
            updateUserDisplay() {
                const playerNameElement = document.getElementById('playerDisplayName');
                if (playerNameElement && this.user) {
                    playerNameElement.textContent = this.user.username;
                }
            }
            
            disconnect() {
                this.stopPingPong();
                if (this.socket) {
                    this.socket.disconnect();
                }
                this.isConnected = false;
                this.user = null;
                this.currentRoom = null;
                this.updateConnectionStatus('disconnected');
            }
            
            // Getters
            getConnectionState() {
                return {
                    isConnected: this.isConnected,
                    user: this.user,
                    latency: this.latency,
                    currentRoom: this.currentRoom
                };
            }
        }

        // ===== GAME INITIALIZATION =====
        let gameEngine, audioSystem, particleSystem, backgroundEffect, heatMapVisualizer, socketManager;
        let canvas, ctx, lastTime = 0;
        let currentPanel = 'menu';
        let gameSettings = {volume: 0.7, theme: 'neon', particles: true, screenShake: true, ballTrail: true, backgroundEffects: true, backgroundType: 'particles'};

        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            audioSystem = new AudioSystem();
            particleSystem = new ParticleSystem(ctx);
            backgroundEffect = new BackgroundEffect(ctx, canvas);
            gameEngine = new GameEngine(canvas, ctx);
            heatMapVisualizer = new HeatMapVisualizer();
            enhancedTournamentSystem = new EnhancedTournamentSystem();
            mobileControlSystem = new MobileControlSystem();
            accessibilitySystem = new AccessibilitySystem();
            
            // Initialize Socket.io for real-time multiplayer
            socketManager = new SocketManager();
            setupSocketEvents();
            
            // Initialize heat map visualizer after DOM is ready
            heatMapVisualizer.initialize('heatmapCanvas');
            
            // Initialize mobile and accessibility features
            setupDeviceOrientation();
            optimizeForMobile();
            
            loadSettings();
            loadAnalyticsData();
            initializeSession();
            
            // Apply background settings after initialization
            backgroundEffect.setEnabled(gameSettings.backgroundEffects);
            backgroundEffect.setEffect(gameSettings.backgroundType);
            
            startGameLoop();
        });

        function startGameLoop() {
            function gameLoop(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw background effects first (behind everything)
                backgroundEffect.update(deltaTime);
                backgroundEffect.draw();
                
                if (gameEngine.screenShake.duration > 0) {
                    ctx.save();
                    ctx.translate(gameEngine.screenShake.x, gameEngine.screenShake.y);
                }
                
                gameEngine.update(deltaTime);
                drawGame();
                particleSystem.update(deltaTime);
                particleSystem.draw();
                
                if (gameEngine.screenShake.duration > 0) ctx.restore();
                
                updateInGameUI();
                requestAnimationFrame(gameLoop);
            }
            requestAnimationFrame(gameLoop);
        }
        
        // ===== SOCKET EVENT SETUP =====
        function setupSocketEvents() {
            if (!socketManager) return;
            
            // Authentication events
            socketManager.on('userAuthenticated', (user) => {
                console.log('User authenticated:', user);
                updatePlayerProfileFromServer(user);
            });
            
            socketManager.on('authError', (error) => {
                console.error('Authentication error:', error);
                showError('Authentication failed: ' + error.message);
            });
            
            // Matchmaking events
            socketManager.on('matchFound', (matchData) => {
                console.log('Match found:', matchData);
                handleMatchFound(matchData);
            });
            
            socketManager.on('matchmakingCancelled', () => {
                console.log('Matchmaking cancelled');
                showMatchmakingUI(false);
            });
            
            // Game events
            socketManager.on('gameStart', (gameData) => {
                console.log('Online game starting:', gameData);
                socketManager.currentRoom = gameData.roomId;
                startNetworkedGame(gameData);
            });
            
            socketManager.on('gameUpdate', (gameState) => {
                if (gameEngine.gameState === 'playing' && gameEngine.gameMode === 'online') {
                    updateGameFromNetwork(gameState);
                }
            });
            
            socketManager.on('gameEnd', (result) => {
                console.log('Online game ended:', result);
                handleOnlineGameEnd(result);
            });
            
            // Chat events
            socketManager.on('chatMessage', (messageData) => {
                displayChatMessage(messageData);
            });
            
            // Friend system events
            socketManager.on('friendRequest', (friendData) => {
                showFriendRequestNotification(friendData);
            });
            
            socketManager.on('friendAccepted', (friendData) => {
                showFriendAcceptedNotification(friendData);
            });
            
            // Socket error handling
            socketManager.on('socketError', (error) => {
                console.error('Socket error:', error);
                showError('Connection error: ' + error.message);
            });
        }
        
        // ===== MULTIPLAYER EVENT HANDLERS =====
        function updatePlayerProfileFromServer(user) {
            document.getElementById('playerDisplayName').textContent = user.username;
            document.getElementById('displayNameInput').value = user.username;
            
            // Update stats if available
            if (user.stats) {
                document.getElementById('onlineGamesPlayed').textContent = user.stats.gamesPlayed || 0;
                document.getElementById('onlineGamesWon').textContent = user.stats.gamesWon || 0;
                document.getElementById('playerRating').textContent = user.stats.rating || 1200;
            }
            
            // Also update auth panel if open
            updateAuthServerStatus();
            if (document.getElementById('authPanel').style.display !== 'none') {
                showUserProfile(user);
            }
        }
        
        function handleMatchFound(matchData) {
            // Show match found UI
            showSuccess('Match found! Connecting to game...');
            audioSystem?.play('gameStart');
            
            // Update opponent info
            const opponentNameElement = document.getElementById('opponentPlayerName');
            if (opponentNameElement && matchData.opponent) {
                opponentNameElement.textContent = matchData.opponent.username;
            }
            
            // Show ready section
            const gameReadySection = document.getElementById('gameReadySection');
            if (gameReadySection) {
                gameReadySection.style.display = 'block';
            }
        }
        
        function startNetworkedGame(gameData) {
            // Set up multiplayer game mode
            gameEngine.gameMode = 'online';
            gameEngine.gameState = 'playing';
            
            // Determine which side the player is on
            const isPlayer1 = gameData.players[0].id === socketManager.user.id;
            
            // Hide multiplayer panel and show game
            showPanel(null);
            
            // Initialize game state based on server data
            if (gameData.initialState) {
                gameEngine.ball = { ...gameEngine.ball, ...gameData.initialState.ball };
                gameEngine.player = { ...gameEngine.player, ...gameData.initialState.player };
                gameEngine.ai = { ...gameEngine.ai, ...gameData.initialState.opponent };
            }
            
            // Reset scores
            gameEngine.player.score = 0;
            gameEngine.ai.score = 0;
            
            console.log('Started networked game as', isPlayer1 ? 'Player 1' : 'Player 2');
        }
        
        function updateGameFromNetwork(gameState) {
            // Update game state from server
            if (gameState.ball) {
                gameEngine.ball.x = gameState.ball.x;
                gameEngine.ball.y = gameState.ball.y;
                gameEngine.ball.vx = gameState.ball.vx;
                gameEngine.ball.vy = gameState.ball.vy;
            }
            
            if (gameState.players) {
                // Update opponent paddle position (not our own)
                const opponentData = gameState.players.find(p => p.id !== socketManager.user.id);
                if (opponentData) {
                    gameEngine.ai.y = opponentData.paddle.y;
                    gameEngine.ai.score = opponentData.score;
                }
                
                // Update our score
                const playerData = gameState.players.find(p => p.id === socketManager.user.id);
                if (playerData) {
                    gameEngine.player.score = playerData.score;
                }
            }
        }
        
        function handleOnlineGameEnd(result) {
            gameEngine.gameState = 'menu';
            gameEngine.gameMode = 'classic';
            socketManager.currentRoom = null;
            
            // Show result
            const won = result.winner === socketManager.user.id;
            const message = won ? 'You Won! 🏆' : 'You Lost! 😢';
            showSuccess(message + ' Final Score: ' + result.finalScore.player + ' - ' + result.finalScore.opponent);
            
            // Update stats
            if (result.playerStats) {
                updatePlayerProfileFromServer({ stats: result.playerStats });
            }
            
            // Show menu
            showPanel('menu');
            audioSystem?.play(won ? 'win' : 'lose');
        }
        
        function displayChatMessage(messageData) {
            // TODO: Implement chat UI display
            console.log('Chat message:', messageData);
        }
        
        function showFriendRequestNotification(friendData) {
            showSuccess(`Friend request from ${friendData.username}`);
        }
        
        function showFriendAcceptedNotification(friendData) {
            showSuccess(`${friendData.username} accepted your friend request!`);
        }
        
        function showMatchmakingUI(show) {
            // TODO: Implement matchmaking UI states
            if (show) {
                console.log('Showing matchmaking UI...');
            } else {
                console.log('Hiding matchmaking UI...');
            }
        }

        function drawGame() {
            if (gameEngine.gameState !== 'playing' && gameEngine.gameState !== 'paused') return;
            
            // Center line
            ctx.setLineDash([5, 15]); ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke();
            ctx.setLineDash([]);
            
            // Ball trail
            if (gameEngine.settings.ballTrail && gameEngine.ball.trail.length > 0) {
                ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.beginPath();
                gameEngine.ball.trail.forEach((point, index) => {
                    const alpha = (gameEngine.ball.trail.length - point.age) / gameEngine.ball.trail.length;
                    ctx.globalAlpha = alpha * 0.5;
                    if (index === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke(); ctx.globalAlpha = 1;
            }
            
            // Paddles & ball with glow
            ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
            ctx.shadowBlur = 10; ctx.fillStyle = '#fff';
            ctx.fillRect(gameEngine.player.x, gameEngine.player.y, gameEngine.player.width, gameEngine.player.height);
            ctx.fillRect(gameEngine.ai.x, gameEngine.ai.y, gameEngine.ai.width, gameEngine.ai.height);
            
            ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
            ctx.shadowBlur = 15;
            ctx.fillRect(gameEngine.ball.x, gameEngine.ball.y, gameEngine.ball.width, gameEngine.ball.height);
            ctx.shadowBlur = 0;
            
            // Scores
            ctx.fillStyle = '#fff'; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center';
            ctx.fillText(gameEngine.player.score, canvas.width / 4, 60);
            ctx.fillText(gameEngine.ai.score, canvas.width * 3/4, 60);
            
            // Power-ups
            gameEngine.powerUps.forEach(powerUp => powerUp.draw(ctx));
            
            // Power-up effect indicators
            if (gameEngine.playerEffects.speedBoost > 0 || gameEngine.playerEffects.sizeChange > 0) {
                ctx.fillStyle = '#ff6b6b'; ctx.shadowBlur = 5; ctx.shadowColor = '#ff6b6b';
                if (gameEngine.playerEffects.speedBoost > 0) ctx.fillText('⚡', gameEngine.player.x, gameEngine.player.y - 10);
                if (gameEngine.playerEffects.sizeChange > 0) ctx.fillText('📏', gameEngine.player.x + 15, gameEngine.player.y - 10);
            }
            if (gameEngine.aiEffects.speedBoost > 0 || gameEngine.aiEffects.sizeChange > 0) {
                ctx.fillStyle = '#4ecdc4'; ctx.shadowBlur = 5; ctx.shadowColor = '#4ecdc4';
                if (gameEngine.aiEffects.speedBoost > 0) ctx.fillText('⚡', gameEngine.ai.x, gameEngine.ai.y - 10);
                if (gameEngine.aiEffects.sizeChange > 0) ctx.fillText('📏', gameEngine.ai.x + 15, gameEngine.ai.y - 10);
            }
            if (gameEngine.playerEffects.freeze > 0) {
                ctx.fillStyle = '#a8e6cf'; ctx.shadowBlur = 5; ctx.shadowColor = '#a8e6cf';
                ctx.fillText('❄️', gameEngine.player.x, gameEngine.player.y - 25);
            }
            if (gameEngine.aiEffects.freeze > 0) {
                ctx.fillStyle = '#a8e6cf'; ctx.shadowBlur = 5; ctx.shadowColor = '#a8e6cf';
                ctx.fillText('❄️', gameEngine.ai.x, gameEngine.ai.y - 25);
            }
            
            // Magnetic effect indicator
            if (gameEngine.magneticEffect > 0) {
                ctx.fillStyle = '#ff69b4'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff69b4';
                ctx.font = '16px Arial'; ctx.textAlign = 'center';
                ctx.fillText('🧲', canvas.width / 2, 30);
                
                // Draw magnetic field lines
                const ballCenterX = gameEngine.ball.x + gameEngine.ball.width / 2;
                const ballCenterY = gameEngine.ball.y + gameEngine.ball.height / 2;
                ctx.strokeStyle = 'rgba(255, 105, 180, 0.3)';
                ctx.lineWidth = 2;
                
                // Lines to player paddle
                const playerCenterX = gameEngine.player.x + gameEngine.player.width / 2;
                const playerCenterY = gameEngine.player.y + gameEngine.player.height / 2;
                const distanceToPlayer = Math.sqrt(Math.pow(ballCenterX - playerCenterX, 2) + Math.pow(ballCenterY - playerCenterY, 2));
                if (distanceToPlayer < 100) {
                    ctx.beginPath();
                    ctx.moveTo(ballCenterX, ballCenterY);
                    ctx.lineTo(playerCenterX, playerCenterY);
                    ctx.stroke();
                }
                
                // Lines to AI paddle
                const aiCenterX = gameEngine.ai.x + gameEngine.ai.width / 2;
                const aiCenterY = gameEngine.ai.y + gameEngine.ai.height / 2;
                const distanceToAI = Math.sqrt(Math.pow(ballCenterX - aiCenterX, 2) + Math.pow(ballCenterY - aiCenterY, 2));
                if (distanceToAI < 100) {
                    ctx.beginPath();
                    ctx.moveTo(ballCenterX, ballCenterY);
                    ctx.lineTo(aiCenterX, aiCenterY);
                    ctx.stroke();
                }
            }
            
            ctx.shadowBlur = 0;
            
            // Lives in survival mode
            if (gameEngine.gameMode === 'survival') {
                ctx.font = '20px Arial'; ctx.fillStyle = '#ff6b6b'; ctx.textAlign = 'left';
                ctx.fillText('❤️'.repeat(gameEngine.player.lives), 20, canvas.height - 20);
            }
            
            // Pause overlay
            if (gameEngine.gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 36px Arial'; ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
            
            // Game over overlay
            if (gameEngine.gameState === 'gameOver') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                const winner = gameEngine.player.score >= gameEngine.settings.winScore ? 'PLAYER WINS!' : 'AI WINS!';
                const color = gameEngine.player.score >= gameEngine.settings.winScore ? '#4ecdc4' : '#ff6b6b';
                ctx.fillStyle = color; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center';
                ctx.fillText(winner, canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = '#fff'; ctx.font = '20px Arial';
                ctx.fillText('Restarting in 3 seconds...', canvas.width / 2, canvas.height / 2 + 60);
            }
        }

        // ===== UI FUNCTIONS =====
        function showPanel(panelName, skipAnimation = false) {
            const panels = ['gameMenu', 'settingsPanel', 'statsPanel', 'helpPanel', 'aboutPanel', 'inGameUI', 'heatmapPanel', 'mlstatsPanel', 'analyticsPanel'];
            const currentVisiblePanel = panels.find(id => document.getElementById(id).style.display !== 'none');
            
            // If we have a visible panel and animations are enabled, slide it out first
            if (currentVisiblePanel && !skipAnimation) {
                const currentElement = document.getElementById(currentVisiblePanel);
                currentElement.classList.add('slide-out');
                
                // Wait for slide out animation to complete before showing new panel
                setTimeout(() => {
                    showPanelImmediate(panelName);
                }, 300);
            } else {
                showPanelImmediate(panelName);
            }
            
            audioSystem?.play('menuClick');
        }
        
        function showPanelImmediate(panelName) {
            const panels = ['gameMenu', 'settingsPanel', 'statsPanel', 'helpPanel', 'aboutPanel', 'inGameUI', 'heatmapPanel', 'mlstatsPanel', 'analyticsPanel'];
            
            // Hide all panels and remove animation classes
            panels.forEach(id => {
                const element = document.getElementById(id);
                element.style.display = 'none';
                element.classList.remove('slide-out');
            });
            
            currentPanel = panelName;
            
            // Show the requested panel with fresh animation
            let targetElement;
            switch (panelName) {
                case 'menu': 
                    targetElement = document.getElementById('gameMenu');
                    gameEngine.gameState = 'menu'; 
                    break;
                case 'settings': 
                    targetElement = document.getElementById('settingsPanel');
                    updateSettingsUI(); 
                    break;
                case 'stats': 
                    updateStatsPanel();
                    targetElement = document.getElementById('statsPanel');
                    break;
                case 'help': 
                    targetElement = document.getElementById('helpPanel');
                    break;
                case 'about': 
                    targetElement = document.getElementById('aboutPanel');
                    break;
                case 'game': 
                    targetElement = document.getElementById('inGameUI');
                    initMobileControls();
                    break;
                case 'heatmap': 
                    targetElement = document.getElementById('heatmapPanel');
                    setTimeout(() => updateHeatMap(), 150);
                    break;
                case 'mlstats':
                    targetElement = document.getElementById('mlstatsPanel');
                    updateMLStatsPanel();
                    break;
                case 'analytics':
                    targetElement = document.getElementById('analyticsPanel');
                    setTimeout(() => initializeAnalyticsCharts(), 150);
                    break;
                case 'tournamentBracket':
                    targetElement = document.getElementById('tournamentBracketPanel');
                    setTimeout(() => showTournamentBracket(), 50);
                    break;
                case 'tournamentCustomize':
                    targetElement = document.getElementById('tournamentCustomizePanel');
                    setTimeout(() => updateTournamentPreview(), 50);
                    break;
                case 'onlineMultiplayer':
                    targetElement = document.getElementById('onlineMultiplayerPanel');
                    setTimeout(() => initializeMultiplayerUI(), 50);
                    break;
            }
            
            if (targetElement) {
                targetElement.style.display = 'block';
                // Trigger reflow to ensure animation plays
                targetElement.offsetHeight;
            }
        }
        
        // Initialize mobile-specific controls
        function initMobileControls() {
            if (isMobileDevice()) {
                // Enhance touch controls for mobile
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            }
        }
        
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768 && 'ontouchstart' in window);
        }
        
        let touchStartY = 0;
        function handleTouchStart(e) {
            if (gameEngine.gameState !== 'playing') return;
            touchStartY = e.touches[0].clientY;
        }
        
        function handleTouchMove(e) {
            if (gameEngine.gameState !== 'playing') return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touchY = e.touches[0].clientY - rect.top;
            const scaleY = canvas.height / rect.height;
            const gameY = touchY * scaleY;
            gameEngine.player.y = Math.max(0, Math.min(canvas.height - gameEngine.player.height, gameY - gameEngine.player.height / 2));
        }
        
        function handleTouchEnd(e) {
            // Could add touch gestures here
        }

        function startGame(mode) {
            gameEngine.setGameMode(mode);
            gameEngine.gameState = 'playing';
            showPanel('game');
            document.getElementById('gameModeDisplay').textContent = mode.toUpperCase() + ' MODE';
            audioSystem?.play('gameStart');
        }

        function changeDifficulty(difficulty) {
            gameEngine.ai.difficulty = difficulty;
            audioSystem?.play('menuClick');
        }

        function changePersonality(personality) {
            gameEngine.setAIPersonality(personality);
            audioSystem?.play('menuClick');
        }

        function updateVolume(value) {
            document.getElementById('volumeValue').textContent = value + '%';
            audioSystem.volume = value / 100;
        }

        function changeTheme(theme) {
            gameSettings.theme = theme;
            applyTheme(theme);
            audioSystem?.play('menuClick');
        }

        function toggleParticles(enabled) {
            gameSettings.particles = enabled;
            gameEngine.settings.particles = enabled;
            particleSystem.enabled = enabled;
            audioSystem?.play('menuClick');
        }

        function toggleScreenShake(enabled) {
            gameSettings.screenShake = enabled;
            gameEngine.settings.screenShake = enabled;
            audioSystem?.play('menuClick');
        }

        function toggleBallTrail(enabled) {
            gameSettings.ballTrail = enabled;
            gameEngine.settings.ballTrail = enabled;
            audioSystem?.play('menuClick');
        }

        function toggleMute(muted) {
            audioSystem.muted = muted;
        }
        
        function toggleBackgroundEffects(enabled) {
            gameSettings.backgroundEffects = enabled;
            backgroundEffect.setEnabled(enabled);
            audioSystem?.play('menuClick');
        }
        
        function changeBackgroundType(type) {
            gameSettings.backgroundType = type;
            backgroundEffect.setEffect(type);
            audioSystem?.play('menuClick');
        }

        function saveSettings() {
            localStorage.setItem('enhancedPongSettings', JSON.stringify(gameSettings));
            audioSystem?.play('menuClick');
        }

        function loadSettings() {
            const saved = localStorage.getItem('enhancedPongSettings');
            if (saved) gameSettings = { ...gameSettings, ...JSON.parse(saved) };
            applyTheme(gameSettings.theme);
            
            // Apply background settings
            if (backgroundEffect) {
                backgroundEffect.setEnabled(gameSettings.backgroundEffects);
                backgroundEffect.setEffect(gameSettings.backgroundType);
            }
        }

        function updateSettingsUI() {
            document.getElementById('volumeSlider').value = gameSettings.volume * 100;
            document.getElementById('volumeValue').textContent = Math.round(gameSettings.volume * 100) + '%';
            document.getElementById('themeSelect').value = gameSettings.theme;
            document.getElementById('particlesCheck').checked = gameSettings.particles;
            document.getElementById('shakeCheck').checked = gameSettings.screenShake;
            document.getElementById('trailCheck').checked = gameSettings.ballTrail;
            document.getElementById('backgroundCheck').checked = gameSettings.backgroundEffects;
            document.getElementById('backgroundTypeSelect').value = gameSettings.backgroundType;
        }

        function updateStatsPanel() {
            const stats = gameEngine.getStats();
            const analytics = gameEngine.analytics;
            const achievements = gameEngine.achievements;
            
            // Helper function to format time
            const formatTime = (ms) => {
                if (ms < 60000) return Math.round(ms/1000) + 's';
                const minutes = Math.floor(ms/60000);
                const seconds = Math.floor((ms%60000)/1000);
                return minutes + 'm ' + seconds + 's';
            };
            
            // Calculate additional metrics
            const reactionTime = gameEngine.getAverageReactionTime();
            const consistency = Math.round(analytics.playerBehavior.consistency * 100);
            const defensiveStyle = Math.round(analytics.playerBehavior.defensiveStyle * 100);
            const personalitiesBeaten = stats.personalitiesBeaten ? stats.personalitiesBeaten.size : 0;
            const totalAchievements = Object.keys(achievements.definitions).length;
            const unlockedAchievements = achievements.unlocked.size;
            const achievementProgress = Math.round((unlockedAchievements / totalAchievements) * 100);
            
            document.getElementById('statsContent').innerHTML = `
                <div class="stats-grid">
                    <!-- Game Statistics -->
                    <div class="stats-section">
                        <h3>🎮 Game Statistics</h3>
                        <div class="stats-item">
                            <span class="stats-label">Games Played</span>
                            <span class="stats-value">${stats.gamesPlayed}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Games Won</span>
                            <span class="stats-value" style="color: #4ecdc4;">${stats.gamesWon}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Games Lost</span>
                            <span class="stats-value" style="color: #ff6b6b;">${stats.gamesLost}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Win Rate</span>
                            <span class="stats-value">${stats.winRate}%</span>
                        </div>
                        <div class="stats-bar">
                            <div class="stats-bar-fill" style="width: ${stats.winRate}%"></div>
                        </div>
                    </div>
                    
                    <!-- Performance Records -->
                    <div class="stats-section">
                        <h3>🏆 Performance Records</h3>
                        <div class="stats-item">
                            <span class="stats-label">Longest Rally</span>
                            <span class="stats-value">${stats.longestRally} hits</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Total Hits</span>
                            <span class="stats-value">${stats.totalHits}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Perfect Games</span>
                            <span class="stats-value">${stats.perfectGames}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Average Rally</span>
                            <span class="stats-value">${stats.averageRally} hits</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Current Win Streak</span>
                            <span class="stats-value">${stats.currentWinStreak || 0}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Best Win Streak</span>
                            <span class="stats-value">${stats.maxWinStreak || 0}</span>
                        </div>
                    </div>
                    
                    <!-- Player Behavior Analytics -->
                    <div class="stats-section">
                        <h3>📊 Player Analytics</h3>
                        <div class="stats-item">
                            <span class="stats-label">Avg. Reaction Time</span>
                            <span class="stats-value">${Math.round(reactionTime)}ms</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Movement Consistency</span>
                            <span class="stats-value">${consistency}%</span>
                        </div>
                        <div class="stats-bar">
                            <div class="stats-bar-fill" style="width: ${consistency}%"></div>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Defensive Style</span>
                            <span class="stats-value">${defensiveStyle}%</span>
                        </div>
                        <div class="stats-bar">
                            <div class="stats-bar-fill" style="width: ${defensiveStyle}%"></div>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Power-ups Collected</span>
                            <span class="stats-value">${stats.powerUpsCollected || 0}</span>
                        </div>
                    </div>
                    
                    <!-- Game Mode Statistics -->
                    <div class="stats-section">
                        <h3>🎯 Game Mode Progress</h3>
                        <div class="stats-item">
                            <span class="stats-label">Survival Mode Wins</span>
                            <span class="stats-value">${stats.survivalWins || 0}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Speedball Mode Wins</span>
                            <span class="stats-value">${stats.speedballWins || 0}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Comeback Victories</span>
                            <span class="stats-value">${stats.comebacks || 0}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">AI Personalities Beaten</span>
                            <span class="stats-value">${personalitiesBeaten}/8</span>
                        </div>
                        <div class="stats-bar">
                            <div class="stats-bar-fill" style="width: ${(personalitiesBeaten/8)*100}%"></div>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Total Play Time</span>
                            <span class="stats-value">${formatTime(stats.totalPlayTime || 0)}</span>
                        </div>
                    </div>
                    
                    <!-- Achievement Progress -->
                    <div class="stats-section">
                        <h3>🏅 Achievement Progress</h3>
                        <div class="stats-item">
                            <span class="stats-label">Achievements Unlocked</span>
                            <span class="stats-value">${unlockedAchievements}/${totalAchievements}</span>
                        </div>
                        <div class="stats-bar">
                            <div class="stats-bar-fill" style="width: ${achievementProgress}%"></div>
                        </div>
                        <div style="margin-top: 10px;">
                            ${Array.from(achievements.unlocked).slice(0, 6).map(id => {
                                const achievement = achievements.definitions[id];
                                return achievement ? `<span class="achievement-badge">${achievement.title}</span>` : '';
                            }).join('')}
                            ${unlockedAchievements > 6 ? `<span class="achievement-badge">+${unlockedAchievements - 6} more</span>` : ''}
                        </div>
                    </div>
                    
                    <!-- Quick Analytics Summary -->
                    <div class="stats-section">
                        <h3>⚡ Quick Summary</h3>
                        <div class="stats-item">
                            <span class="stats-label">Skill Level</span>
                            <span class="stats-value">${getSkillLevel(stats.winRate, stats.gamesPlayed)}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Play Style</span>
                            <span class="stats-value">${getPlayStyle(defensiveStyle, consistency)}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Best Quality</span>
                            <span class="stats-value">${getBestQuality(stats, analytics)}</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Next Goal</span>
                            <span class="stats-value">${getNextGoal(stats, achievements)}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getSkillLevel(winRate, gamesPlayed) {
            if (gamesPlayed < 5) return '🆕 Newcomer';
            if (winRate >= 80) return '🏆 Master';
            if (winRate >= 65) return '⭐ Expert';
            if (winRate >= 50) return '💪 Skilled';
            if (winRate >= 35) return '📈 Improving';
            return '🎯 Learning';
        }
        
        function getPlayStyle(defensive, consistency) {
            if (consistency > 80) {
                return defensive > 70 ? '🛡️ Steady Guardian' : '⚔️ Consistent Striker';
            } else if (consistency > 60) {
                return defensive > 70 ? '🏰 Defensive' : '⚖️ Balanced';
            } else {
                return defensive > 70 ? '🎲 Cautious' : '⚡ Aggressive';
            }
        }
        
        function getBestQuality(stats, analytics) {
            const qualities = [];
            if (stats.longestRally >= 30) qualities.push('🏓 Rally Master');
            if (stats.perfectGames >= 3) qualities.push('🎯 Precision');
            if (analytics.playerBehavior.consistency >= 0.8) qualities.push('📏 Consistency');
            if (gameEngine.getAverageReactionTime() < 300) qualities.push('⚡ Quick Reflexes');
            if (stats.comebacks >= 2) qualities.push('👑 Resilience');
            return qualities[0] || '🌟 Potential';
        }
        
        function getNextGoal(stats, achievements) {
            const unlockedCount = achievements.unlocked.size;
            const totalAchievements = Object.keys(achievements.definitions).length;
            
            if (stats.gamesPlayed < 10) return '🎮 Play 10 games';
            if (stats.winRate < 50) return '📈 Reach 50% win rate';
            if (stats.longestRally < 25) return '🏓 25-hit rally';
            if (stats.perfectGames === 0) return '🎯 Perfect game';
            if (unlockedCount < totalAchievements * 0.5) return '🏅 50% achievements';
            return '🏆 Master all modes';
        }

        function clearStats() {
            if (confirm('Clear all statistics?')) {
                gameEngine.stats = {gamesPlayed: 0, gamesWon: 0, gamesLost: 0, longestRally: 0, 
                                 currentRally: 0, totalHits: 0, perfectGames: 0};
                gameEngine.saveStats(); updateStatsPanel();
                audioSystem?.play('menuClick');
            }
        }

        function applyTheme(theme) {
            document.body.className = 'theme-' + theme;
            const themes = {
                neon: {bg: 'linear-gradient(135deg, #1e3c72, #2a5298)', primary: '#4ecdc4', secondary: '#ff6b6b'},
                retro: {bg: 'linear-gradient(135deg, #2d1b69, #11998e)', primary: '#f38ba8', secondary: '#a6e3a1'},
                classic: {bg: 'linear-gradient(135deg, #000000, #434343)', primary: '#ffffff', secondary: '#cccccc'},
                cyberpunk: {bg: 'linear-gradient(135deg, #0f0f0f, #1a0033)', primary: '#ff0080', secondary: '#00ff80'},
                synthwave: {bg: 'linear-gradient(135deg, #2d1b4e, #ff006e, #8338ec)', primary: '#ff006e', secondary: '#8338ec'},
                ocean: {bg: 'linear-gradient(135deg, #0f3460, #16537e, #005c98)', primary: '#00d4ff', secondary: '#0099cc'},
                forest: {bg: 'linear-gradient(135deg, #0f2027, #203a43, #2c5530)', primary: '#66ff66', secondary: '#44cc44'},
                sunset: {bg: 'linear-gradient(135deg, #f2994a, #f2c94c, #eb5757)', primary: '#f2994a', secondary: '#eb5757'},
                galaxy: {bg: 'linear-gradient(135deg, #1a0033, #330066, #660099)', primary: '#cc66ff', secondary: '#9933ff'},
                volcanic: {bg: 'linear-gradient(135deg, #1a0000, #cc0000, #ff3300)', primary: '#ff6600', secondary: '#ff3300'},
                arctic: {bg: 'linear-gradient(135deg, #e6f7ff, #b3e5fc, #81d4fa)', primary: '#0066cc', secondary: '#0099ff'},
                matrix: {bg: 'linear-gradient(135deg, #000000, #003300, #006600)', primary: '#00ff00', secondary: '#66ff66'},
                crimson: {bg: 'linear-gradient(135deg, #330000, #660000, #990000)', primary: '#ff3366', secondary: '#cc0033'},
                highcontrast: {bg: 'linear-gradient(135deg, #ffffff, #f0f0f0)', primary: '#000000', secondary: '#333333'},
                protanopia: {bg: 'linear-gradient(135deg, #0066cc, #004499)', primary: '#ffaa00', secondary: '#0088ff'},
                deuteranopia: {bg: 'linear-gradient(135deg, #cc6600, #994400)', primary: '#0066ff', secondary: '#ffcc00'},
                // New themes
                midnight: {bg: 'linear-gradient(135deg, #000428, #004e92)', primary: '#00d4ff', secondary: '#0099cc'},
                'aurora-green': {bg: 'linear-gradient(135deg, #00f260, #0575e6)', primary: '#00ff88', secondary: '#00ccff'},
                'rose-gold': {bg: 'linear-gradient(135deg, #f093fb, #f5576c)', primary: '#ff69b4', secondary: '#ff1493'},
                'deep-space': {bg: 'linear-gradient(135deg, #0c0c0c, #1a0033, #4a0080)', primary: '#9966ff', secondary: '#cc66ff'},
                'golden-hour': {bg: 'linear-gradient(135deg, #ff9a9e, #fecfef)', primary: '#ff6b6b', secondary: '#ffa726'},
                'electric-blue': {bg: 'linear-gradient(135deg, #667eea, #764ba2)', primary: '#4fc3f7', secondary: '#29b6f6'},
                emerald: {bg: 'linear-gradient(135deg, #11998e, #38ef7d)', primary: '#00e676', secondary: '#26a69a'},
                'cosmic-purple': {bg: 'linear-gradient(135deg, #667db6, #0082c8, #667db6)', primary: '#ab47bc', secondary: '#7e57c2'}
            };
            const t = themes[theme] || themes.neon;
            document.body.style.background = t.bg;
            document.documentElement.style.setProperty('--primary-color', t.primary);
            document.documentElement.style.setProperty('--secondary-color', t.secondary);
        }

        function pauseGame() {
            if (gameEngine.gameState === 'playing') {
                gameEngine.gameState = 'paused';
                event.target.textContent = '▶️ Resume';
            } else if (gameEngine.gameState === 'paused') {
                gameEngine.gameState = 'playing';
                event.target.textContent = '⏸️ Pause';
            }
            audioSystem?.play('menuClick');
        }

        function updateInGameUI() {
            if (document.getElementById('inGameUI').style.display !== 'none') {
                document.getElementById('livesCount').textContent = gameEngine.player.lives;
                document.getElementById('rallyCount').textContent = gameEngine.stats.currentRally;
            }
        }
        
        // ===== HEAT MAP FUNCTIONS =====
        function updateHeatMap() {
            if (!heatMapVisualizer || !gameEngine) return;
            
            const heatmapType = document.getElementById('heatmapTypeSelect').value;
            let stats = null;
            
            switch (heatmapType) {
                case 'playerHits':
                    stats = heatMapVisualizer.drawPlayerHits(gameEngine.analytics);
                    displayHeatMapStats(stats, 'Player Paddle Hits');
                    break;
                    
                case 'aiHits':
                    stats = heatMapVisualizer.drawAIHits(gameEngine.analytics);
                    displayHeatMapStats(stats, 'AI Paddle Hits');
                    break;
                    
                case 'ballTrajectory':
                    stats = heatMapVisualizer.drawBallTrajectory(gameEngine.analytics);
                    displayHeatMapStats(stats, 'Ball Trajectory', 'totalSamples');
                    break;
                    
                case 'playerMovement':
                    stats = heatMapVisualizer.drawPlayerMovement(gameEngine.playerMovementSamples);
                    displayHeatMapStats(stats, 'Player Movement', 'totalSamples');
                    break;
                    
                case 'combined':
                    stats = heatMapVisualizer.drawCombined(gameEngine.analytics, gameEngine.playerMovementSamples);
                    displayCombinedHeatMapStats(stats);
                    break;
                    
                default:
                    document.getElementById('heatmapStats').innerHTML = '<p>Select a heat map type to view data.</p>';
            }
        }
        
        function displayHeatMapStats(stats, title, countKey = 'totalHits') {
            if (!stats) {
                document.getElementById('heatmapStats').innerHTML = `
                    <h3>${title}</h3>
                    <p>No data available yet. Play some games to generate heat map data!</p>
                `;
                return;
            }
            
            const count = stats[countKey] || 0;
            const avgIntensity = stats.avgIntensity || '0.00';
            const maxIntensity = stats.maxIntensity || 0;
            
            let extraStats = '';
            if (stats.avgPosition !== undefined) {
                extraStats = `<p><strong>Average Position:</strong> ${Math.round(stats.avgPosition)}px</p>`;
            }
            
            document.getElementById('heatmapStats').innerHTML = `
                <h3>📊 ${title}</h3>
                <p><strong>Total Points:</strong> ${count}</p>
                <p><strong>Average Intensity:</strong> ${avgIntensity}</p>
                <p><strong>Max Intensity:</strong> ${maxIntensity}</p>
                ${extraStats}
            `;
        }
        
        function displayCombinedHeatMapStats(stats) {
            if (!stats) {
                document.getElementById('heatmapStats').innerHTML = `
                    <h3>🌈 Combined View</h3>
                    <p>No data available yet. Play some games to generate heat map data!</p>
                `;
                return;
            }
            
            document.getElementById('heatmapStats').innerHTML = `
                <h3>📊 Combined Heat Map</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 12px;">
                    <div>
                        <p><strong>🔴 Player Hits:</strong> ${stats.playerHits || 0}</p>
                        <p><strong>🔵 AI Hits:</strong> ${stats.aiHits || 0}</p>
                    </div>
                    <div>
                        <p><strong>🟢 Ball Samples:</strong> ${stats.ballSamples || 0}</p>
                        <p><strong>Max Intensity:</strong> ${stats.maxIntensity || 0}</p>
                    </div>
                </div>
                <p style="margin-top: 10px; font-size: 11px; color: #aaa;">
                    🔴 Red = Player hits, 🔵 Blue = AI hits, 🟢 Green = Ball trajectory
                </p>
            `;
        }
        
        function clearHeatMapData() {
            if (confirm('Clear all heat map data? This will reset hit locations, ball trajectories, and movement patterns.')) {
                // Clear analytics heat map data
                gameEngine.analytics.heatMap = {
                    playerHits: [],
                    aiHits: [],
                    ballTrajectories: [],
                    scoringZones: []
                };
                
                // Clear movement samples
                gameEngine.playerMovementSamples = [];
                
                // Save the cleared analytics
                gameEngine.saveAnalytics();
                
                // Refresh the current heat map view
                updateHeatMap();
                
                audioSystem?.play('menuClick');
            }
        }
        
        // ===== ML AI STATS FUNCTIONS =====
        function updateMLStatsPanel() {
            if (!gameEngine || !gameEngine.mlAI) {
                document.getElementById('mlstatsContent').innerHTML = `
                    <p>ML AI system not available.</p>
                `;
                return;
            }
            
            const stats = gameEngine.mlAI.getLearningStats();
            
            if (stats.gamesAnalyzed === 0) {
                document.getElementById('mlstatsContent').innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <p><strong>🤖 Machine Learning AI</strong></p>
                        <p>No learning data yet. Play some games with the <strong>🧠 Adaptive</strong> AI personality to start generating learning statistics.</p>
                        <p style="font-size: 12px; color: #aaa; margin-top: 15px;">The ML AI analyzes your gameplay patterns and adapts its strategy accordingly. It needs at least 3 games to start learning effectively.</p>
                    </div>
                `;
                return;
            }
            
            const confidenceColor = stats.confidence >= 70 ? '#4ecdc4' : stats.confidence >= 40 ? '#ffd54f' : '#ff6b6b';
            const strategyEmoji = {
                'balanced': '⚖️',
                'exploit': '🎯', 
                'challenge': '🏋️'
            };
            
            document.getElementById('mlstatsContent').innerHTML = `
                <div style="font-size: 14px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <h3 style="color: var(--primary-color); margin-bottom: 10px;">🧠 Learning Progress</h3>
                            <p><strong>Games Analyzed:</strong> ${stats.gamesAnalyzed}</p>
                            <p><strong>Confidence Level:</strong> <span style="color: ${confidenceColor};">${stats.confidence}%</span></p>
                            <p><strong>Data Points:</strong> ${stats.totalDataPoints}</p>
                            <p><strong>Current Strategy:</strong> ${strategyEmoji[stats.strategy] || '⚖️'} ${stats.strategy.charAt(0).toUpperCase() + stats.strategy.slice(1)}</p>
                        </div>
                        <div>
                            <h3 style="color: var(--secondary-color); margin-bottom: 10px;">🎮 Player Profile</h3>
                            <p><strong>Favorite Position:</strong> ${stats.playerTendencies.favoritePosition}px</p>
                            <p><strong>Movement Consistency:</strong> ${stats.playerTendencies.consistency}%</p>
                            <p><strong>Defensive Ratio:</strong> ${stats.playerTendencies.defensiveRatio}%</p>
                            <p><strong>Avg Reaction Time:</strong> ${stats.playerTendencies.avgReactionTime}ms</p>
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; font-size: 12px;">
                        <h4 style="margin-top: 0; color: var(--primary-color);">🔬 How ML AI Works</h4>
                        <p><strong>Learning:</strong> The AI tracks your movement patterns, reaction times, defensive zones, and successful hits.</p>
                        <p><strong>Analysis:</strong> After each game, it analyzes your tendencies to find patterns and weaknesses.</p>
                        <p><strong>Adaptation:</strong> It adjusts its targeting, speed, and strategy based on your play style and performance.</p>
                        <p><strong>Strategy Types:</strong></p>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li><strong>⚖️ Balanced:</strong> Mixed approach based on your skill level</li>
                            <li><strong>🎯 Exploit:</strong> Targets your weak spots when you're performing well</li>
                            <li><strong>🏋️ Challenge:</strong> Provides good practice when you're struggling</li>
                        </ul>
                        <p style="margin-top: 10px; font-style: italic;">The more you play with Adaptive AI, the better it becomes at providing the right level of challenge!</p>
                    </div>
                </div>
            `;
        }
        
        function resetMLAI() {
            if (confirm('Reset all Machine Learning AI data? This will clear all learned patterns and start fresh.')) {
                if (gameEngine && gameEngine.mlAI) {
                    gameEngine.mlAI.resetLearning();
                    updateMLStatsPanel(); // Refresh the display
                    audioSystem?.play('menuClick');
                } else {
                    console.warn('ML AI system not available');
                }
            }
        }
        
        // ===== CACHE CLEAR FUNCTION =====
        function clearGameCache() {
            if (confirm('Clear ALL game data? This will reset everything including:\n\n• Game statistics and records\n• Heat map data\n• Machine Learning AI data\n• Settings and preferences\n• Achievement progress\n\nThis action cannot be undone. Continue?')) {
                try {
                    // Clear all localStorage items
                    localStorage.removeItem('pongStats');
                    localStorage.removeItem('pongAnalytics');
                    localStorage.removeItem('pongMLAI');
                    localStorage.removeItem('pongAchievements');
                    localStorage.removeItem('enhancedPongSettings');
                    
                    // Reset game engine if available
                    if (gameEngine) {
                        // Reset stats
                        gameEngine.stats = {gamesPlayed: 0, gamesWon: 0, gamesLost: 0, longestRally: 0, 
                                         currentRally: 0, totalHits: 0, perfectGames: 0, powerUpsCollected: 0,
                                         survivalWins: 0, speedballWins: 0, personalitiesBeaten: new Set(),
                                         currentWinStreak: 0, maxWinStreak: 0, comebacks: 0, totalPlayTime: 0};
                        
                        // Reset analytics
                        gameEngine.analytics = {
                            playerBehavior: {
                                movementPattern: [],
                                reactionTimes: [],
                                hitZones: [],
                                averagePosition: 0,
                                defensiveStyle: 0,
                                consistency: 0
                            },
                            heatMap: {
                                playerHits: [],
                                aiHits: [],
                                ballTrajectories: [],
                                scoringZones: []
                            },
                            gameFlow: {
                                rallyLengths: [],
                                gameRhythm: [],
                                intensityMoments: [],
                                comebackAttempts: 0
                            },
                            aiLearning: {
                                playerPreferences: {},
                                successfulStrategies: [],
                                adaptationLevel: 0
                            }
                        };
                        
                        // Reset ML AI
                        if (gameEngine.mlAI) {
                            gameEngine.mlAI.resetLearning();
                        }
                        
                        // Reset achievements
                        gameEngine.achievements.unlocked = new Set();
                        gameEngine.achievements.newlyUnlocked = [];
                        
                        // Clear movement samples
                        gameEngine.playerMovementSamples = [];
                        gameEngine.ballPositionSamples = [];
                    }
                    
                    // Reset settings to defaults
                    gameSettings = {volume: 0.7, theme: 'neon', particles: true, screenShake: true, 
                                  ballTrail: true, backgroundEffects: true, backgroundType: 'particles'};
                    
                    // Apply default theme
                    applyTheme('neon');
                    
                    // Update UI to reflect changes
                    updateSettingsUI();
                    
                    // Reload page to ensure clean state
                    setTimeout(() => {
                        alert('Cache cleared successfully! The page will reload to apply changes.');
                        location.reload();
                    }, 500);
                    
                    audioSystem?.play('menuClick');
                    
                } catch (error) {
                    console.error('Error clearing cache:', error);
                    alert('Error clearing cache. Please try again or refresh the page manually.');
                }
            }
        }
        
        // ===== ENHANCED ANALYTICS DATA SYSTEM =====
        let analyticsData = {
            sessionHistory: [],
            performanceHistory: [],
            tournamentHistory: [],
            aiPersonalityStats: {},
            heatMapIntensity: [],
            currentSession: null
        };
        
        let analyticsCharts = {};
        
        // Initialize session tracking
        function initializeSession() {
            analyticsData.currentSession = {
                id: Date.now(),
                startTime: new Date().toISOString(),
                gamesPlayed: 0,
                wins: 0,
                losses: 0,
                totalScore: 0,
                gameMode: null,
                aiPersonality: null,
                performanceSnapshots: []
            };
        }
        
        // Track game completion for analytics
        function trackGameCompletion(gameResult) {
            if (!analyticsData.currentSession) initializeSession();
            
            const session = analyticsData.currentSession;
            session.gamesPlayed++;
            session.totalScore += gameResult.playerScore;
            
            if (gameResult.won) {
                session.wins++;
            } else {
                session.losses++;
            }
            
            // Take performance snapshot
            const stats = gameEngine.getStats();
            const analytics = gameEngine.analytics;
            session.performanceSnapshots.push({
                timestamp: new Date().toISOString(),
                winRate: stats.winRate,
                reactionTime: gameEngine.getAverageReactionTime(),
                consistency: analytics.playerBehavior.consistency * 100,
                gameMode: gameEngine.gameMode,
                aiPersonality: gameEngine.ai.personality
            });
            
            // Track AI personality performance
            const aiKey = gameEngine.ai.personality;
            if (!analyticsData.aiPersonalityStats[aiKey]) {
                analyticsData.aiPersonalityStats[aiKey] = { wins: 0, losses: 0, totalGames: 0 };
            }
            analyticsData.aiPersonalityStats[aiKey].totalGames++;
            if (gameResult.won) {
                analyticsData.aiPersonalityStats[aiKey].wins++;
            } else {
                analyticsData.aiPersonalityStats[aiKey].losses++;
            }
            
            // Track tournament performance
            if (gameEngine.gameMode === 'tournament' && gameEngine.tournament) {
                trackTournamentProgress(gameResult);
            }
            
            saveAnalyticsData();
        }
        
        // Track tournament progress
        function trackTournamentProgress(gameResult) {
            const tournament = gameEngine.tournament;
            if (!tournament) return;
            
            const currentTournament = {
                id: tournament.id || Date.now(),
                round: tournament.currentRound,
                roundResult: gameResult,
                aiPersonality: gameEngine.ai.personality,
                playerScore: gameResult.playerScore,
                aiScore: gameResult.aiScore,
                timestamp: new Date().toISOString()
            };
            
            if (tournament.isComplete) {
                // Tournament finished, save complete tournament data
                const tournamentData = {
                    id: currentTournament.id,
                    startTime: tournament.startTime,
                    endTime: new Date().toISOString(),
                    totalRounds: tournament.rounds || 5,
                    won: tournament.playerWon,
                    finalScore: tournament.finalScore,
                    rounds: tournament.roundHistory || [],
                    achievements: tournament.achievementsUnlocked || []
                };
                analyticsData.tournamentHistory.push(tournamentData);
            }
        }
        
        // Save analytics data to localStorage
        function saveAnalyticsData() {
            localStorage.setItem('enhancedPongAnalyticsData', JSON.stringify(analyticsData));
        }
        
        // Load analytics data from localStorage
        function loadAnalyticsData() {
            const saved = localStorage.getItem('enhancedPongAnalyticsData');
            if (saved) {
                try {
                    const loadedData = JSON.parse(saved);
                    analyticsData = { ...analyticsData, ...loadedData };
                } catch (e) {
                    console.warn('Failed to load analytics data:', e);
                }
            }
        }
        
        // ===== MOBILE & ACCESSIBILITY ENHANCEMENTS =====
        
        class MobileControlSystem {
            constructor() {
                this.touchState = {
                    isActive: false,
                    startY: 0,
                    currentY: 0,
                    lastY: 0,
                    velocity: 0,
                    gestureStartTime: 0,
                    multiTouchActive: false,
                    pinchStart: 0,
                    pinchScale: 1
                };
                
                this.hapticSupported = 'vibrate' in navigator;
                this.gestureThresholds = {
                    swipeMinDistance: 50,
                    swipeMaxTime: 300,
                    tapMaxDistance: 10,
                    tapMaxTime: 250
                };
                
                this.setupAdvancedTouchControls();
            }
            
            setupAdvancedTouchControls() {
                if (!gameEngine) return;
                
                // Enhanced touch controls for gameplay
                gameEngine.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                gameEngine.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                gameEngine.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                
                // Gesture recognition
                gameEngine.canvas.addEventListener('gesturestart', this.handleGestureStart.bind(this), { passive: false });
                gameEngine.canvas.addEventListener('gesturechange', this.handleGestureChange.bind(this), { passive: false });
                gameEngine.canvas.addEventListener('gestureend', this.handleGestureEnd.bind(this), { passive: false });
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                const touch = e.touches[0];
                const rect = gameEngine.canvas.getBoundingClientRect();
                
                this.touchState.isActive = true;
                this.touchState.startY = touch.clientY - rect.top;
                this.touchState.currentY = this.touchState.startY;
                this.touchState.lastY = this.touchState.startY;
                this.touchState.gestureStartTime = Date.now();
                this.touchState.multiTouchActive = e.touches.length > 1;
                
                // Haptic feedback for touch start
                this.triggerHapticFeedback('light');
                
                // Multi-touch detection
                if (e.touches.length > 1) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    this.touchState.pinchStart = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                }
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                if (!this.touchState.isActive) return;
                
                const touch = e.touches[0];
                const rect = gameEngine.canvas.getBoundingClientRect();
                const scaleY = gameEngine.canvas.height / rect.height;
                
                this.touchState.lastY = this.touchState.currentY;
                this.touchState.currentY = touch.clientY - rect.top;
                
                // Calculate velocity for smooth movement
                this.touchState.velocity = (this.touchState.currentY - this.touchState.lastY) * 0.3 + this.touchState.velocity * 0.7;
                
                if (gameEngine.gameState === 'playing') {
                    // Enhanced paddle control with momentum
                    const gameY = this.touchState.currentY * scaleY;
                    const targetY = gameY - gameEngine.player.height / 2;
                    
                    // Apply momentum for smoother movement
                    const smoothedY = targetY + this.touchState.velocity;
                    gameEngine.player.y = Math.max(0, Math.min(gameEngine.canvas.height - gameEngine.player.height, smoothedY));
                    
                    // Haptic feedback for paddle movement
                    if (Math.abs(this.touchState.velocity) > 5) {
                        this.triggerHapticFeedback('selection');
                    }
                }
                
                // Handle multi-touch pinch gestures
                if (e.touches.length > 1) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    if (this.touchState.pinchStart > 0) {
                        this.touchState.pinchScale = currentDistance / this.touchState.pinchStart;
                        // Could be used for zoom functionality in future
                    }
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                if (!this.touchState.isActive) return;
                
                const gestureTime = Date.now() - this.touchState.gestureStartTime;
                const gestureDistance = Math.abs(this.touchState.currentY - this.touchState.startY);
                
                // Gesture recognition
                this.recognizeGesture(gestureTime, gestureDistance, this.touchState.velocity);
                
                // Reset touch state
                this.touchState.isActive = false;
                this.touchState.velocity = 0;
                this.touchState.multiTouchActive = false;
                this.touchState.pinchStart = 0;
                this.touchState.pinchScale = 1;
            }
            
            recognizeGesture(time, distance, velocity) {
                // Quick tap gesture
                if (time < this.gestureThresholds.tapMaxTime && distance < this.gestureThresholds.tapMaxDistance) {
                    this.handleTapGesture();
                    return;
                }
                
                // Swipe gestures
                if (time < this.gestureThresholds.swipeMaxTime && distance > this.gestureThresholds.swipeMinDistance) {
                    if (velocity > 0) {
                        this.handleSwipeDown();
                    } else {
                        this.handleSwipeUp();
                    }
                    return;
                }
                
                // Long press gesture
                if (time > 500 && distance < this.gestureThresholds.tapMaxDistance) {
                    this.handleLongPress();
                }
            }
            
            handleTapGesture() {
                // Tap to pause/resume game
                if (gameEngine.gameState === 'playing') {
                    gameEngine.gameState = 'paused';
                    this.triggerHapticFeedback('medium');
                } else if (gameEngine.gameState === 'paused') {
                    gameEngine.gameState = 'playing';
                    this.triggerHapticFeedback('medium');
                }
            }
            
            handleSwipeUp() {
                // Swipe up for quick paddle movement
                if (gameEngine.gameState === 'playing') {
                    gameEngine.player.y = Math.max(0, gameEngine.player.y - 60);
                    this.triggerHapticFeedback('light');
                }
            }
            
            handleSwipeDown() {
                // Swipe down for quick paddle movement
                if (gameEngine.gameState === 'playing') {
                    gameEngine.player.y = Math.min(gameEngine.canvas.height - gameEngine.player.height, gameEngine.player.y + 60);
                    this.triggerHapticFeedback('light');
                }
            }
            
            handleLongPress() {
                // Long press to access quick menu
                if (gameEngine.gameState === 'playing') {
                    this.showQuickMenu();
                    this.triggerHapticFeedback('heavy');
                }
            }
            
            handleGestureStart(e) {
                e.preventDefault();
            }
            
            handleGestureChange(e) {
                e.preventDefault();
                // Handle pinch-to-zoom or other gestures
            }
            
            handleGestureEnd(e) {
                e.preventDefault();
            }
            
            triggerHapticFeedback(intensity = 'medium') {
                if (!this.hapticSupported) return;
                
                const patterns = {
                    light: [10],
                    medium: [50],
                    heavy: [100],
                    selection: [25],
                    success: [50, 100, 50],
                    error: [200, 100, 200]
                };
                
                const pattern = patterns[intensity] || patterns.medium;
                navigator.vibrate(pattern);
            }
            
            showQuickMenu() {
                // Future enhancement: Quick access menu for mobile
                console.log('Quick menu triggered - future enhancement');
            }
            
            // Utility methods for detecting device capabilities
            isTouchDevice() {
                return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            }
            
            supportsGestures() {
                return 'ongesturestart' in window;
            }
            
            // Enhanced paddle control for mobile
            updatePaddleWithPhysics(targetY) {
                if (!gameEngine) return;
                
                const paddle = gameEngine.player;
                const currentY = paddle.y + paddle.height / 2;
                const difference = targetY - currentY;
                
                // Apply physics-based movement
                const acceleration = difference * 0.05;
                const maxSpeed = 400; // pixels per second
                
                paddle.velocity = Math.max(-maxSpeed, Math.min(maxSpeed, (paddle.velocity || 0) + acceleration));
                paddle.velocity *= 0.85; // Friction
                
                const newY = currentY + paddle.velocity * (1/60) - paddle.height / 2;
                paddle.y = Math.max(0, Math.min(gameEngine.canvas.height - paddle.height, newY));
            }
        }
        
        // ===== ACCESSIBILITY SYSTEM =====
        
        class AccessibilitySystem {
            constructor() {
                this.screenReaderActive = this.detectScreenReader();
                this.keyboardNavigationEnabled = true;
                this.highContrastMode = false;
                this.voiceControlEnabled = false;
                this.setupAccessibilityFeatures();
            }
            
            setupAccessibilityFeatures() {
                this.setupKeyboardNavigation();
                this.setupScreenReaderSupport();
                this.setupHighContrastMode();
                this.setupVoiceControl();
                this.setupFocusManagement();
            }
            
            detectScreenReader() {
                // Detect if screen reader is active
                return window.speechSynthesis !== undefined || 
                       navigator.userAgent.includes('NVDA') || 
                       navigator.userAgent.includes('JAWS') || 
                       window.navigator.userAgent.includes('VoiceOver');
            }
            
            setupKeyboardNavigation() {
                document.addEventListener('keydown', (e) => {
                    if (!this.keyboardNavigationEnabled) return;
                    
                    switch (e.key) {
                        case 'Tab':
                            this.handleTabNavigation(e);
                            break;
                        case 'Enter':
                        case ' ':
                            this.handleActivation(e);
                            break;
                        case 'Escape':
                            this.handleEscape(e);
                            break;
                        case 'ArrowUp':
                        case 'ArrowDown':
                        case 'ArrowLeft':
                        case 'ArrowRight':
                            this.handleArrowNavigation(e);
                            break;
                    }
                });
            }
            
            setupScreenReaderSupport() {
                // Add ARIA labels and live regions
                this.createLiveRegion();
                this.updateARIALabels();
            }
            
            createLiveRegion() {
                const liveRegion = document.createElement('div');
                liveRegion.id = 'game-announcements';
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.style.position = 'absolute';
                liveRegion.style.left = '-9999px';
                liveRegion.style.width = '1px';
                liveRegion.style.height = '1px';
                liveRegion.style.overflow = 'hidden';
                document.body.appendChild(liveRegion);
            }
            
            announceToScreenReader(message) {
                const liveRegion = document.getElementById('game-announcements');
                if (liveRegion) {
                    liveRegion.textContent = message;
                    
                    // Also use speech synthesis if available
                    if ('speechSynthesis' in window) {
                        const utterance = new SpeechSynthesisUtterance(message);
                        utterance.volume = 0.7;
                        utterance.rate = 1.2;
                        speechSynthesis.speak(utterance);
                    }
                }
            }
            
            updateARIALabels() {
                // Add comprehensive ARIA labels to game elements
                const canvas = document.getElementById('gameCanvas');
                if (canvas) {
                    canvas.setAttribute('role', 'application');
                    canvas.setAttribute('aria-label', 'Enhanced Pong Game Canvas');
                    canvas.setAttribute('aria-describedby', 'game-description');
                }
                
                // Add descriptions to menu buttons
                document.querySelectorAll('.menu-btn').forEach((btn, index) => {
                    btn.setAttribute('tabindex', '0');
                    btn.setAttribute('role', 'button');
                    if (!btn.getAttribute('aria-label')) {
                        btn.setAttribute('aria-label', btn.textContent.trim());
                    }
                });
            }
            
            setupHighContrastMode() {
                // Detect system high contrast preference
                if (window.matchMedia && window.matchMedia('(prefers-contrast: high)').matches) {
                    this.enableHighContrastMode();
                }
                
                // Listen for contrast preference changes
                if (window.matchMedia) {
                    window.matchMedia('(prefers-contrast: high)').addEventListener('change', (e) => {
                        if (e.matches) {
                            this.enableHighContrastMode();
                        } else {
                            this.disableHighContrastMode();
                        }
                    });
                }
            }
            
            enableHighContrastMode() {
                this.highContrastMode = true;
                document.body.classList.add('high-contrast-mode');
                
                // Apply high contrast styles
                const style = document.createElement('style');
                style.id = 'high-contrast-styles';
                style.textContent = `
                    .high-contrast-mode {
                        filter: contrast(150%) brightness(120%);
                    }
                    .high-contrast-mode .menu-btn {
                        border: 3px solid white !important;
                        background: black !important;
                        color: white !important;
                    }
                    .high-contrast-mode .menu-btn:focus {
                        outline: 3px solid yellow !important;
                        outline-offset: 2px !important;
                    }
                `;
                document.head.appendChild(style);
            }
            
            disableHighContrastMode() {
                this.highContrastMode = false;
                document.body.classList.remove('high-contrast-mode');
                const style = document.getElementById('high-contrast-styles');
                if (style) style.remove();
            }
            
            setupVoiceControl() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    return;
                }
                
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                
                this.recognition.continuous = true;
                this.recognition.interimResults = false;
                this.recognition.lang = 'en-US';
                
                this.recognition.onresult = (event) => {
                    const command = event.results[event.results.length - 1][0].transcript.toLowerCase();
                    this.processVoiceCommand(command);
                };
                
                this.recognition.onerror = (event) => {
                    console.log('Voice recognition error:', event.error);
                };
            }
            
            processVoiceCommand(command) {
                const commands = {
                    'start game': () => startGame('classic'),
                    'pause game': () => gameEngine.gameState = 'paused',
                    'resume game': () => gameEngine.gameState = 'playing',
                    'go to menu': () => showPanel('menu'),
                    'show statistics': () => showPanel('stats'),
                    'tournament mode': () => startGame('tournament'),
                    'classic mode': () => startGame('classic'),
                    'settings': () => showPanel('settings'),
                    'help': () => showPanel('help')
                };
                
                for (const [phrase, action] of Object.entries(commands)) {
                    if (command.includes(phrase)) {
                        action();
                        this.announceToScreenReader(`Executed: ${phrase}`);
                        break;
                    }
                }
            }
            
            enableVoiceControl() {
                if (this.recognition) {
                    this.voiceControlEnabled = true;
                    this.recognition.start();
                    this.announceToScreenReader('Voice control enabled');
                }
            }
            
            disableVoiceControl() {
                if (this.recognition) {
                    this.voiceControlEnabled = false;
                    this.recognition.stop();
                    this.announceToScreenReader('Voice control disabled');
                }
            }
            
            setupFocusManagement() {
                // Manage focus for better keyboard navigation
                document.addEventListener('focusin', (e) => {
                    if (e.target.classList.contains('menu-btn')) {
                        e.target.style.outline = '2px solid var(--primary-color)';
                        e.target.style.outlineOffset = '2px';
                    }
                });
                
                document.addEventListener('focusout', (e) => {
                    if (e.target.classList.contains('menu-btn')) {
                        e.target.style.outline = '';
                        e.target.style.outlineOffset = '';
                    }
                });
            }
            
            handleTabNavigation(e) {
                // Enhanced tab navigation logic
                const focusableElements = document.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                
                const currentIndex = Array.from(focusableElements).indexOf(document.activeElement);
                let nextIndex;
                
                if (e.shiftKey) {
                    nextIndex = currentIndex <= 0 ? focusableElements.length - 1 : currentIndex - 1;
                } else {
                    nextIndex = currentIndex >= focusableElements.length - 1 ? 0 : currentIndex + 1;
                }
                
                focusableElements[nextIndex].focus();
                e.preventDefault();
            }
            
            handleActivation(e) {
                if (document.activeElement && document.activeElement.classList.contains('menu-btn')) {
                    document.activeElement.click();
                    e.preventDefault();
                }
            }
            
            handleEscape(e) {
                // Always allow escape to return to menu
                if (currentPanel !== 'menu') {
                    showPanel('menu');
                    e.preventDefault();
                }
            }
            
            handleArrowNavigation(e) {
                if (gameEngine.gameState === 'playing') {
                    // Arrow key paddle control for accessibility
                    switch (e.key) {
                        case 'ArrowUp':
                            gameEngine.player.y = Math.max(0, gameEngine.player.y - 20);
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            gameEngine.player.y = Math.min(gameEngine.canvas.height - gameEngine.player.height, gameEngine.player.y + 20);
                            e.preventDefault();
                            break;
                    }
                }
            }
        }
        
        // Global instances
        let mobileControlSystem = null;
        let accessibilitySystem = null;
        
        // ===== ENHANCED TOURNAMENT SYSTEM =====
        
        class EnhancedTournamentSystem {
            constructor() {
                this.currentTournament = null;
                this.tournamentSettings = {
                    size: 8,
                    format: 'single', // single, double, roundrobin
                    difficultyProgression: 'adaptive',
                    aiPersonalityMode: 'progressive',
                    matchLength: 7
                };
                this.loadTournamentProgress();
            }
            
            createTournament(settings = {}) {
                this.tournamentSettings = { ...this.tournamentSettings, ...settings };
                
                const tournament = {
                    id: Date.now(),
                    startTime: new Date().toISOString(),
                    settings: { ...this.tournamentSettings },
                    format: this.tournamentSettings.format,
                    totalRounds: this.calculateTotalRounds(this.tournamentSettings.size),
                    currentRound: 0,
                    brackets: this.generateBrackets(this.tournamentSettings.size),
                    matches: [],
                    isComplete: false,
                    playerProgress: {
                        roundsWon: 0,
                        totalMatches: 0,
                        matchesWon: 0,
                        opponentsDefeated: [],
                        achievements: []
                    }
                };
                
                this.currentTournament = tournament;
                this.saveTournamentProgress();
                return tournament;
            }
            
            calculateTotalRounds(size) {
                return Math.ceil(Math.log2(size));
            }
            
            generateBrackets(size) {
                const aiPersonalities = ['balanced', 'defensive', 'aggressive', 'perfect', 'unpredictable', 'trickster', 'copycat', 'adaptive'];
                const brackets = [];
                
                // Generate AI opponents for each round
                for (let round = 0; round < this.calculateTotalRounds(size); round++) {
                    const roundBrackets = [];
                    const opponentsInRound = Math.pow(2, this.calculateTotalRounds(size) - round - 1);
                    
                    for (let i = 0; i < opponentsInRound; i++) {
                        let personality, difficulty;
                        
                        switch (this.tournamentSettings.aiPersonalityMode) {
                            case 'progressive':
                                personality = this.getProgressivePersonality(round, i);
                                difficulty = this.getProgressiveDifficulty(round);
                                break;
                            case 'random':
                                personality = aiPersonalities[Math.floor(Math.random() * aiPersonalities.length)];
                                difficulty = ['easy', 'medium', 'hard', 'expert'][Math.floor(Math.random() * 4)];
                                break;
                            case 'custom':
                                personality = this.getCustomPersonality(round, i);
                                difficulty = this.getCustomDifficulty(round, i);
                                break;
                        }
                        
                        roundBrackets.push({
                            id: `R${round}-M${i}`,
                            round: round,
                            position: i,
                            player: 'Player',
                            opponent: {
                                name: this.generateOpponentName(personality),
                                personality: personality,
                                difficulty: difficulty
                            },
                            status: round === 0 ? 'ready' : 'locked',
                            winner: null,
                            score: null,
                            matchHistory: []
                        });
                    }
                    
                    brackets.push(roundBrackets);
                }
                
                return brackets;
            }
            
            getProgressivePersonality(round, position) {
                const progressiveOrder = [
                    ['balanced', 'defensive'],
                    ['aggressive', 'unpredictable'], 
                    ['trickster', 'copycat'],
                    ['perfect', 'adaptive']
                ];
                
                const roundPersonalities = progressiveOrder[Math.min(round, progressiveOrder.length - 1)];
                return roundPersonalities[position % roundPersonalities.length];
            }
            
            getProgressiveDifficulty(round) {
                const difficulties = ['easy', 'medium', 'hard', 'expert'];
                return difficulties[Math.min(round, difficulties.length - 1)];
            }
            
            generateOpponentName(personality) {
                const names = {
                    balanced: ['Balanced Bob', 'Steady Sam', 'Consistent Carl'],
                    defensive: ['Guardian Gary', 'Defender Dan', 'Shield Sarah'],
                    aggressive: ['Attacker Alex', 'Blitz Betty', 'Rush Ryan'],
                    perfect: ['Perfect Pete', 'Flawless Fiona', 'Precision Paul'],
                    unpredictable: ['Wild Willie', 'Chaos Charlie', 'Random Rita'],
                    trickster: ['Tricky Tom', 'Deceptive Dave', 'Sneaky Sue'],
                    copycat: ['Mimic Mike', 'Echo Emma', 'Clone Chris'],
                    adaptive: ['Learning Larry', 'Smart Sally', 'Evolving Eve']
                };
                
                const nameList = names[personality] || ['Mystery Player'];
                return nameList[Math.floor(Math.random() * nameList.length)];
            }
            
            startNextRound() {
                if (!this.currentTournament || this.currentTournament.isComplete) return false;
                
                const currentRound = this.currentTournament.currentRound;
                const roundMatches = this.currentTournament.brackets[currentRound];
                
                if (!roundMatches || roundMatches.length === 0) {
                    this.completeTournament();
                    return false;
                }
                
                // Find next available match
                const nextMatch = roundMatches.find(match => match.status === 'ready');
                if (nextMatch) {
                    return this.startMatch(nextMatch);
                }
                
                return false;
            }
            
            startMatch(match) {
                // Set up game engine for tournament match
                gameEngine.setGameMode('tournament');
                gameEngine.setAIPersonality(match.opponent.personality);
                gameEngine.settings.winScore = this.tournamentSettings.matchLength;
                
                // Store current match reference
                this.currentMatch = match;
                match.status = 'playing';
                
                // Start the game
                gameEngine.gameState = 'playing';
                showPanel('game');
                document.getElementById('gameModeDisplay').textContent = 
                    `TOURNAMENT - Round ${match.round + 1} vs ${match.opponent.name}`;
                
                audioSystem?.play('gameStart');
                this.saveTournamentProgress();
                return true;
            }
            
            completeMatch(playerWon, finalScore) {
                if (!this.currentMatch) return;
                
                const match = this.currentMatch;
                match.status = 'completed';
                match.winner = playerWon ? 'Player' : match.opponent.name;
                match.score = finalScore;
                match.matchHistory.push({
                    timestamp: new Date().toISOString(),
                    playerScore: finalScore.player,
                    opponentScore: finalScore.opponent,
                    duration: Date.now() - new Date(match.startTime || Date.now()).getTime()
                });
                
                // Update tournament progress
                this.currentTournament.playerProgress.totalMatches++;
                if (playerWon) {
                    this.currentTournament.playerProgress.matchesWon++;
                    this.currentTournament.playerProgress.opponentsDefeated.push(match.opponent.personality);
                    
                    // Advance to next round if this was the last match in current round
                    this.checkRoundCompletion();
                } else {
                    // Player eliminated
                    this.eliminatePlayer();
                }
                
                this.currentMatch = null;
                this.saveTournamentProgress();
                this.updateTournamentDisplay();
            }
            
            checkRoundCompletion() {
                const currentRound = this.currentTournament.currentRound;
                const roundMatches = this.currentTournament.brackets[currentRound];
                
                // Check if all matches in current round are completed and player won
                const playerWonRound = roundMatches.every(match => match.winner === 'Player');
                
                if (playerWonRound) {
                    this.currentTournament.playerProgress.roundsWon++;
                    this.currentTournament.currentRound++;
                    
                    // Check if tournament is complete
                    if (this.currentTournament.currentRound >= this.currentTournament.totalRounds) {
                        this.completeTournament(true);
                    } else {
                        this.unlockNextRound();
                    }
                }
            }
            
            unlockNextRound() {
                const nextRound = this.currentTournament.currentRound;
                if (nextRound < this.currentTournament.brackets.length) {
                    this.currentTournament.brackets[nextRound].forEach(match => {
                        match.status = 'ready';
                    });
                }
            }
            
            eliminatePlayer() {
                this.currentTournament.isComplete = true;
                this.currentTournament.result = 'eliminated';
                this.currentTournament.endTime = new Date().toISOString();
                
                // Record tournament result
                if (leaderboardSystem) {
                    leaderboardSystem.recordTournamentResult({
                        matchesWon: this.currentTournament.playerProgress.matchesWon,
                        totalMatches: this.currentTournament.playerProgress.totalMatches,
                        isChampion: false,
                        opponentsDefeated: this.currentTournament.playerProgress.opponentsDefeated,
                        finalScore: this.currentTournament.playerProgress.matchesWon,
                        tournamentType: 'enhanced',
                        duration: Date.now() - new Date(this.currentTournament.startTime).getTime(),
                        difficulty: 'progressive'
                    });
                }
                
                this.showTournamentResults(false);
            }
            
            completeTournament(victory = true) {
                this.currentTournament.isComplete = true;
                this.currentTournament.result = victory ? 'champion' : 'eliminated';
                this.currentTournament.endTime = new Date().toISOString();
                
                // Update game engine tournament stats
                if (gameEngine && gameEngine.stats) {
                    gameEngine.stats.tournamentsPlayed++;
                    
                    if (victory) {
                        gameEngine.stats.tournamentWins++;
                        
                        // Check if perfect tournament (no losses)
                        const totalLosses = this.currentTournament.playerProgress.totalMatches - this.currentTournament.playerProgress.matchesWon;
                        if (totalLosses === 0) {
                            gameEngine.stats.perfectTournaments++;
                        }
                    }
                    
                    // Update best round reached
                    const roundsReached = this.currentTournament.playerProgress.roundsWon + (victory ? 0 : 1);
                    if (roundsReached > gameEngine.stats.tournamentBestRound) {
                        gameEngine.stats.tournamentBestRound = roundsReached;
                    }
                    
                    // Track tournament personalities beaten
                    this.currentTournament.playerProgress.opponentsDefeated.forEach(personality => {
                        gameEngine.stats.tournamentPersonalitiesBeaten.add(personality);
                    });
                    
                    // Save updated stats
                    gameEngine.saveStats();
                }
                
                // Record tournament result
                if (leaderboardSystem) {
                    leaderboardSystem.recordTournamentResult({
                        matchesWon: this.currentTournament.playerProgress.matchesWon,
                        totalMatches: this.currentTournament.playerProgress.totalMatches,
                        isChampion: victory,
                        opponentsDefeated: this.currentTournament.playerProgress.opponentsDefeated,
                        finalScore: this.currentTournament.playerProgress.matchesWon,
                        tournamentType: 'enhanced',
                        duration: Date.now() - new Date(this.currentTournament.startTime).getTime(),
                        difficulty: 'progressive'
                    });
                }
                
                this.showTournamentResults(victory);
            }
            
            showTournamentResults(victory) {
                const message = victory ? 
                    `🏆 TOURNAMENT CHAMPION! 🏆\n\nRounds Won: ${this.currentTournament.playerProgress.roundsWon}\nMatches Won: ${this.currentTournament.playerProgress.matchesWon}/${this.currentTournament.playerProgress.totalMatches}\nOpponents Defeated: ${this.currentTournament.playerProgress.opponentsDefeated.length}` :
                    `Tournament Over\n\nRounds Reached: ${this.currentTournament.playerProgress.roundsWon + 1}\nMatches Won: ${this.currentTournament.playerProgress.matchesWon}/${this.currentTournament.playerProgress.totalMatches}\nBetter luck next time!`;
                
                setTimeout(() => {
                    alert(message);
                    showPanel('menu');
                }, 1000);
            }
            
            loadTournamentProgress() {
                const saved = localStorage.getItem('enhancedTournamentProgress');
                if (saved) {
                    try {
                        this.currentTournament = JSON.parse(saved);
                    } catch (e) {
                        console.warn('Failed to load tournament progress:', e);
                    }
                }
            }
            
            saveTournamentProgress() {
                if (this.currentTournament) {
                    localStorage.setItem('enhancedTournamentProgress', JSON.stringify(this.currentTournament));
                }
            }
            
            clearTournamentProgress() {
                this.currentTournament = null;
                localStorage.removeItem('enhancedTournamentProgress');
            }
        }
        
        // Global tournament system instance
        let enhancedTournamentSystem = null;
        
        // ===== ANALYTICS CHARTS SYSTEM =====
        
        function initializeAnalyticsCharts() {
            // Initialize all charts when analytics panel is shown
            initPerformanceChart();
            initGameModeChart();
            initAIPersonalityChart();
            initRallyChart();
            initMLProgressChart();
            initSessionChart();
            initTournamentChart();
            initHeatMapTrendsChart();
            
            // Add event listeners for chart controls
            document.querySelectorAll('.chart-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const chartType = e.target.dataset.chart;
                    const dataType = e.target.dataset.type;
                    
                    // Update active button
                    e.target.parentElement.querySelectorAll('.chart-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Update chart based on button clicked
                    if (chartType === 'performance') {
                        updatePerformanceChart(dataType);
                    }
                });
            });
        }
        
        function initPerformanceChart() {
            const ctx = document.getElementById('performanceChart');
            if (!ctx) return;
            
            const stats = gameEngine.getStats();
            const analytics = gameEngine.analytics;
            
            // Generate sample data for performance trends (simulated over time)
            const labels = [];
            const winRateData = [];
            const reactionData = [];
            const consistencyData = [];
            
            // Create mock time series data based on current stats
            for (let i = 0; i < Math.min(stats.gamesPlayed, 20); i++) {
                labels.push(`Game ${i + 1}`);
                // Simulate progression - start lower, gradually improve
                const progress = (i + 1) / Math.min(stats.gamesPlayed, 20);
                winRateData.push(Math.max(0, Math.min(100, parseFloat(stats.winRate) - 20 + (progress * 25))));
                reactionData.push(Math.max(100, 500 - (progress * 200) + (Math.random() * 50)));
                consistencyData.push(Math.max(0, Math.min(100, (analytics.playerBehavior.consistency * 100) - 30 + (progress * 40))));
            }
            
            if (analyticsCharts.performance) {
                analyticsCharts.performance.destroy();
            }
            
            analyticsCharts.performance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Win Rate (%)',
                        data: winRateData,
                        borderColor: '#4ecdc4',
                        backgroundColor: 'rgba(78, 205, 196, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function updatePerformanceChart(dataType) {
            const chart = analyticsCharts.performance;
            if (!chart) return;
            
            const stats = gameEngine.getStats();
            const analytics = gameEngine.analytics;
            
            let newData, label, color, backgroundColor;
            
            switch (dataType) {
                case 'winrate':
                    newData = chart.data.datasets[0].data; // Keep existing win rate data
                    label = 'Win Rate (%)';
                    color = '#4ecdc4';
                    backgroundColor = 'rgba(78, 205, 196, 0.1)';
                    break;
                case 'reaction':
                    // Generate mock reaction time data
                    newData = chart.data.labels.map((_, i) => {
                        const progress = (i + 1) / chart.data.labels.length;
                        return Math.max(100, 500 - (progress * 200) + (Math.random() * 50));
                    });
                    label = 'Reaction Time (ms)';
                    color = '#ff6b6b';
                    backgroundColor = 'rgba(255, 107, 107, 0.1)';
                    break;
                case 'consistency':
                    // Generate mock consistency data
                    newData = chart.data.labels.map((_, i) => {
                        const progress = (i + 1) / chart.data.labels.length;
                        return Math.max(0, Math.min(100, (analytics.playerBehavior.consistency * 100) - 30 + (progress * 40)));
                    });
                    label = 'Consistency (%)';
                    color = '#ffd54f';
                    backgroundColor = 'rgba(255, 213, 79, 0.1)';
                    break;
            }
            
            chart.data.datasets[0].data = newData;
            chart.data.datasets[0].label = label;
            chart.data.datasets[0].borderColor = color;
            chart.data.datasets[0].backgroundColor = backgroundColor;
            chart.update();
        }
        
        function initGameModeChart() {
            const ctx = document.getElementById('gameModeChart');
            if (!ctx) return;
            
            const stats = gameEngine.getStats();
            
            // Mock data for different game modes based on total games
            const total = Math.max(1, stats.gamesPlayed);
            const data = {
                classic: Math.round(total * 0.4),
                speedball: stats.speedballWins || Math.round(total * 0.2),
                survival: stats.survivalWins || Math.round(total * 0.15),
                tournament: Math.round(total * 0.1),
                practice: Math.round(total * 0.1),
                multiplayer: Math.round(total * 0.05)
            };
            
            if (analyticsCharts.gameMode) {
                analyticsCharts.gameMode.destroy();
            }
            
            analyticsCharts.gameMode = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Classic', 'Speedball', 'Survival', 'Tournament', 'Practice', 'Multiplayer'],
                    datasets: [{
                        data: Object.values(data),
                        backgroundColor: [
                            '#4ecdc4',
                            '#ff6b6b', 
                            '#ffd54f',
                            '#a8e6cf',
                            '#ff8a80',
                            '#b19cd9'
                        ],
                        borderWidth: 2,
                        borderColor: '#000'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { 
                                color: '#fff',
                                usePointStyle: true,
                                padding: 15
                            }
                        }
                    }
                }
            });
        }
        
        function initAIPersonalityChart() {
            const ctx = document.getElementById('aiPersonalityChart');
            if (!ctx) return;
            
            const stats = gameEngine.getStats();
            const personalitiesBeaten = stats.personalitiesBeaten || new Set();
            
            // Use real analytics data for AI personality performance
            const personalities = ['Balanced', 'Defensive', 'Aggressive', 'Perfect', 'Unpredictable', 'Trickster', 'Copycat', 'Adaptive'];
            const winData = [];
            const lossData = [];
            const winRateData = [];
            
            personalities.forEach(personality => {
                const key = personality.toLowerCase();
                const aiStats = analyticsData.aiPersonalityStats[key] || { wins: 0, losses: 0, totalGames: 0 };
                
                // If no data exists, create minimal mock data
                if (aiStats.totalGames === 0) {
                    const beaten = personalitiesBeaten.has(key);
                    const mockTotal = beaten ? Math.floor(Math.random() * 3) + 1 : 0;
                    const mockWins = beaten ? Math.floor(mockTotal * 0.6) : 0;
                    winData.push(mockWins);
                    lossData.push(mockTotal - mockWins);
                    winRateData.push(mockTotal > 0 ? Math.round((mockWins / mockTotal) * 100) : 0);
                } else {
                    winData.push(aiStats.wins);
                    lossData.push(aiStats.losses);
                    winRateData.push(Math.round((aiStats.wins / aiStats.totalGames) * 100));
                }
            });
            
            if (analyticsCharts.aiPersonality) {
                analyticsCharts.aiPersonality.destroy();
            }
            
            analyticsCharts.aiPersonality = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: personalities,
                    datasets: [{
                        label: 'Wins',
                        data: winData,
                        backgroundColor: '#4ecdc4',
                        borderColor: '#4ecdc4',
                        borderWidth: 1
                    }, {
                        label: 'Losses',
                        data: lossData,
                        backgroundColor: '#ff6b6b',
                        borderColor: '#ff6b6b',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#fff',
                                maxRotation: 45
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function initRallyChart() {
            const ctx = document.getElementById('rallyChart');
            if (!ctx) return;
            
            const analytics = gameEngine.analytics;
            const rallyLengths = analytics.gameFlow.rallyLengths || [];
            
            // Group rallies into buckets
            const buckets = {
                '1-5 hits': 0,
                '6-10 hits': 0,
                '11-20 hits': 0,
                '21-30 hits': 0,
                '31+ hits': 0
            };
            
            if (rallyLengths.length === 0) {
                // Generate sample data if no real data exists
                const stats = gameEngine.getStats();
                const sampleSize = Math.max(10, stats.totalHits / 10);
                for (let i = 0; i < sampleSize; i++) {
                    const rallyLength = Math.floor(Math.random() * 40) + 1;
                    if (rallyLength <= 5) buckets['1-5 hits']++;
                    else if (rallyLength <= 10) buckets['6-10 hits']++;
                    else if (rallyLength <= 20) buckets['11-20 hits']++;
                    else if (rallyLength <= 30) buckets['21-30 hits']++;
                    else buckets['31+ hits']++;
                }
            } else {
                rallyLengths.forEach(length => {
                    if (length <= 5) buckets['1-5 hits']++;
                    else if (length <= 10) buckets['6-10 hits']++;
                    else if (length <= 20) buckets['11-20 hits']++;
                    else if (length <= 30) buckets['21-30 hits']++;
                    else buckets['31+ hits']++;
                });
            }
            
            if (analyticsCharts.rally) {
                analyticsCharts.rally.destroy();
            }
            
            analyticsCharts.rally = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(buckets),
                    datasets: [{
                        label: 'Rally Frequency',
                        data: Object.values(buckets),
                        backgroundColor: '#ffd54f',
                        borderColor: '#ffd54f',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function initMLProgressChart() {
            const ctx = document.getElementById('mlProgressChart');
            if (!ctx) return;
            
            let mlStats = { gamesAnalyzed: 0, confidence: 0 };
            if (gameEngine.mlAI) {
                mlStats = gameEngine.mlAI.getLearningStats();
            }
            
            // Generate progression data
            const labels = [];
            const confidenceData = [];
            const dataPointsData = [];
            
            for (let i = 0; i < Math.max(5, mlStats.gamesAnalyzed); i++) {
                labels.push(`Session ${i + 1}`);
                const progress = (i + 1) / Math.max(5, mlStats.gamesAnalyzed);
                confidenceData.push(Math.min(mlStats.confidence, progress * mlStats.confidence));
                dataPointsData.push(Math.floor(progress * (mlStats.totalDataPoints || 100)));
            }
            
            if (analyticsCharts.mlProgress) {
                analyticsCharts.mlProgress.destroy();
            }
            
            analyticsCharts.mlProgress = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'AI Confidence (%)',
                        data: confidenceData,
                        borderColor: '#a8e6cf',
                        backgroundColor: 'rgba(168, 230, 207, 0.1)',
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: 'Data Points',
                        data: dataPointsData,
                        borderColor: '#b19cd9',
                        backgroundColor: 'rgba(177, 156, 217, 0.1)',
                        tension: 0.4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            beginAtZero: true,
                            max: 100
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: { color: '#fff' },
                            grid: { drawOnChartArea: false },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function initSessionChart() {
            const ctx = document.getElementById('sessionChart');
            if (!ctx) return;
            
            const stats = gameEngine.getStats();
            
            // Mock session data over the last week
            const labels = [];
            const sessionData = [];
            const now = new Date();
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                labels.push(date.toLocaleDateString('en', { weekday: 'short' }));
                
                // Mock session activity (higher for recent days)
                const activity = Math.max(0, Math.floor((7 - i) * stats.gamesPlayed / 15) + Math.floor(Math.random() * 5));
                sessionData.push(activity);
            }
            
            if (analyticsCharts.session) {
                analyticsCharts.session.destroy();
            }
            
            analyticsCharts.session = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Games Played',
                        data: sessionData,
                        backgroundColor: '#ff8a80',
                        borderColor: '#ff8a80',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function initTournamentChart() {
            const ctx = document.getElementById('tournamentChart');
            if (!ctx) return;
            
            const tournamentHistory = analyticsData.tournamentHistory || [];
            
            if (tournamentHistory.length === 0) {
                // Show "no data" message
                const container = ctx.parentElement;
                container.innerHTML = '<div class="no-data-message">No tournament data available yet.<br>Complete some tournaments to see analytics!</div>';
                return;
            }
            
            // Prepare tournament performance data
            const labels = [];
            const winData = [];
            const roundsWonData = [];
            
            tournamentHistory.slice(-10).forEach((tournament, index) => {
                labels.push(`Tournament ${index + 1}`);
                winData.push(tournament.won ? 1 : 0);
                
                // Calculate rounds won
                const roundsWon = tournament.rounds ? tournament.rounds.filter(r => r.won).length : 0;
                roundsWonData.push(roundsWon);
            });
            
            if (analyticsCharts.tournament) {
                analyticsCharts.tournament.destroy();
            }
            
            analyticsCharts.tournament = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Tournament Wins',
                        data: winData,
                        borderColor: '#ffd54f',
                        backgroundColor: 'rgba(255, 213, 79, 0.2)',
                        tension: 0.4,
                        yAxisID: 'y',
                        stepped: true
                    }, {
                        label: 'Rounds Won',
                        data: roundsWonData,
                        borderColor: '#4ecdc4',
                        backgroundColor: 'rgba(78, 205, 196, 0.1)',
                        tension: 0.4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: { 
                                color: '#fff',
                                stepSize: 1,
                                min: 0,
                                max: 1
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: { color: '#fff' },
                            grid: { drawOnChartArea: false },
                            beginAtZero: true,
                            max: 5
                        }
                    }
                }
            });
        }
        
        function initHeatMapTrendsChart() {
            const ctx = document.getElementById('heatMapTrendsChart');
            if (!ctx) return;
            
            const analytics = gameEngine.analytics;
            const heatMapData = analyticsData.heatMapIntensity || [];
            
            // Generate trend data based on current heat map intensity
            const labels = [];
            const playerHitIntensity = [];
            const aiHitIntensity = [];
            const ballTrajectoryIntensity = [];
            
            // If we have stored heat map intensity data, use it
            if (heatMapData.length > 0) {
                heatMapData.forEach((entry, index) => {
                    labels.push(`Session ${index + 1}`);
                    playerHitIntensity.push(entry.playerHits || 0);
                    aiHitIntensity.push(entry.aiHits || 0);
                    ballTrajectoryIntensity.push(entry.ballTrajectories || 0);
                });
            } else {
                // Generate mock trend data based on current analytics
                const currentPlayerHits = analytics.heatMap.playerHits.length;
                const currentAiHits = analytics.heatMap.aiHits.length;
                const currentBallSamples = analytics.heatMap.ballTrajectories.length;
                
                for (let i = 0; i < 10; i++) {
                    labels.push(`Session ${i + 1}`);
                    const progress = (i + 1) / 10;
                    playerHitIntensity.push(Math.floor(currentPlayerHits * progress * (0.7 + Math.random() * 0.6)));
                    aiHitIntensity.push(Math.floor(currentAiHits * progress * (0.7 + Math.random() * 0.6)));
                    ballTrajectoryIntensity.push(Math.floor(currentBallSamples * progress * (0.7 + Math.random() * 0.6)));
                }
            }
            
            if (analyticsCharts.heatMapTrends) {
                analyticsCharts.heatMapTrends.destroy();
            }
            
            analyticsCharts.heatMapTrends = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Player Hit Intensity',
                        data: playerHitIntensity,
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'AI Hit Intensity',
                        data: aiHitIntensity,
                        borderColor: '#4ecdc4',
                        backgroundColor: 'rgba(78, 205, 196, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'Ball Trajectory Data',
                        data: ballTrajectoryIntensity,
                        borderColor: '#ffd54f',
                        backgroundColor: 'rgba(255, 213, 79, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function refreshAnalyticsCharts() {
            // Refresh all charts with current data
            initializeAnalyticsCharts();
            audioSystem?.play('menuClick');
        }
        
        function exportAnalyticsData() {
            const stats = gameEngine.getStats();
            const analytics = gameEngine.analytics;
            
            const exportData = {
                timestamp: new Date().toISOString(),
                version: '1.3.0',
                gameStats: stats,
                playerAnalytics: analytics.playerBehavior,
                extendedAnalytics: {
                    sessionHistory: analyticsData.sessionHistory,
                    performanceHistory: analyticsData.performanceHistory,
                    tournamentHistory: analyticsData.tournamentHistory,
                    aiPersonalityStats: analyticsData.aiPersonalityStats,
                    heatMapIntensity: analyticsData.heatMapIntensity
                },
                heatMapData: {
                    playerHits: analytics.heatMap.playerHits.length,
                    aiHits: analytics.heatMap.aiHits.length,
                    ballTrajectories: analytics.heatMap.ballTrajectories.length,
                    fullPlayerHits: analytics.heatMap.playerHits,
                    fullAiHits: analytics.heatMap.aiHits,
                    fullBallTrajectories: analytics.heatMap.ballTrajectories
                },
                mlAIStats: gameEngine.mlAI ? gameEngine.mlAI.getLearningStats() : null,
                achievements: Array.from(gameEngine.achievements.unlocked)
            };
            
            // Ask user for format preference
            const format = confirm('Export as JSON? Click OK for JSON, Cancel for CSV format.');
            
            if (format) {
                // Export as JSON
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `enhanced-pong-analytics-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            } else {
                // Export as CSV
                exportAnalyticsAsCSV(exportData);
            }
            
            audioSystem?.play('menuClick');
        }
        
        // ===== TOURNAMENT UI FUNCTIONS =====
        
        function showTournamentBracket() {
            if (!enhancedTournamentSystem.currentTournament) {
                alert('No active tournament. Create a new tournament first!');
                showPanel('tournamentCustomize');
                return;
            }
            
            updateTournamentDisplay();
            showPanel('tournamentBracket');
        }
        
        function updateTournamentDisplay() {
            const tournament = enhancedTournamentSystem.currentTournament;
            if (!tournament) return;
            
            // Update tournament progress header
            const progressDiv = document.getElementById('tournamentProgress');
            progressDiv.innerHTML = `
                <h3>🏆 ${tournament.format.toUpperCase()} ELIMINATION TOURNAMENT</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 10px;">
                    <div><strong>Round:</strong> ${tournament.currentRound + 1}/${tournament.totalRounds}</div>
                    <div><strong>Matches Won:</strong> ${tournament.playerProgress.matchesWon}/${tournament.playerProgress.totalMatches}</div>
                    <div><strong>Status:</strong> ${tournament.isComplete ? (tournament.result === 'champion' ? '🏆 Champion' : '❌ Eliminated') : '⚙️ In Progress'}</div>
                </div>
            `;
            
            // Update tournament settings display
            const settingsDiv = document.getElementById('tournamentSettings');
            settingsDiv.innerHTML = `
                <div style="font-size: 11px; color: rgba(255,255,255,0.7);">
                    <span>Format: ${tournament.settings.format}</span> • 
                    <span>Size: ${tournament.settings.size} rounds</span> • 
                    <span>Match Length: Best of ${tournament.settings.matchLength}</span>
                </div>
            `;
            
            // Generate bracket visualization
            generateBracketVisualization(tournament);
            
            // Update controls
            updateTournamentControls(tournament);
        }
        
        function generateBracketVisualization(tournament) {
            const bracketDiv = document.getElementById('tournamentBracket');
            
            let html = '<div class="bracket-container">';
            
            for (let roundIndex = 0; roundIndex < tournament.brackets.length; roundIndex++) {
                const round = tournament.brackets[roundIndex];
                const roundName = getRoundName(roundIndex, tournament.totalRounds);
                
                html += `<div class="bracket-round">`;
                html += `<div class="round-label">${roundName}</div>`;
                
                round.forEach((match, matchIndex) => {
                    const matchClass = getMatchClass(match, tournament.currentRound, roundIndex);
                    
                    html += `<div class="bracket-match ${matchClass}" onclick="viewMatchDetails('${match.id}')"`;
                    if (match.status === 'ready' && roundIndex === tournament.currentRound) {
                        html += ` style="cursor: pointer;"`;
                    }
                    html += `>`;
                    
                    // Player info
                    html += `<div class="bracket-player ${match.winner === 'Player' ? 'winner' : (match.winner ? 'loser' : '')}">`;
                    html += `👤 Player ${match.score ? `(${match.score.player})` : ''}</div>`;
                    
                    html += `<div style="font-size: 12px; color: rgba(255,255,255,0.5); margin: 2px 0;">vs</div>`;
                    
                    // Opponent info
                    html += `<div class="bracket-player ${match.winner === match.opponent.name ? 'winner' : (match.winner ? 'loser' : '')}">`;
                    html += `🤖 ${match.opponent.name}`;
                    html += `<span class="ai-personality-badge">${match.opponent.personality}</span>`;
                    html += `<span class="difficulty-indicator difficulty-${match.opponent.difficulty}"></span>`;
                    if (match.score) html += ` (${match.score.opponent})`;
                    html += `</div>`;
                    
                    if (match.status === 'ready' && roundIndex === tournament.currentRound) {
                        html += `<div style="margin-top: 8px;"><button class="menu-btn" style="font-size: 11px; padding: 4px 8px;" onclick="startTournamentMatch('${match.id}')">Start Match</button></div>`;
                    }
                    
                    html += `</div>`;
                });
                
                html += `</div>`;
            }
            
            html += '</div>';
            bracketDiv.innerHTML = html;
        }
        
        function getRoundName(roundIndex, totalRounds) {
            const roundsFromEnd = totalRounds - roundIndex;
            switch (roundsFromEnd) {
                case 1: return 'FINAL';
                case 2: return 'SEMI-FINAL';
                case 3: return 'QUARTER-FINAL';
                case 4: return 'ROUND OF 16';
                default: return `ROUND ${roundIndex + 1}`;
            }
        }
        
        function getMatchClass(match, currentRound, roundIndex) {
            if (match.status === 'completed') return 'completed';
            if (match.status === 'playing') return 'current';
            if (roundIndex === currentRound && match.status === 'ready') return 'current';
            if (roundIndex > currentRound) return 'locked';
            return '';
        }
        
        function updateTournamentControls(tournament) {
            const nextRoundBtn = document.getElementById('nextRoundBtn');
            
            if (tournament.isComplete) {
                nextRoundBtn.style.display = 'none';
            } else {
                const hasReadyMatches = tournament.brackets[tournament.currentRound]?.some(match => match.status === 'ready');
                nextRoundBtn.style.display = hasReadyMatches ? 'inline-block' : 'none';
                nextRoundBtn.textContent = hasReadyMatches ? '▶️ Start Next Match' : '▶️ Next Round';
            }
        }
        
        function startTournamentMatch(matchId) {
            const tournament = enhancedTournamentSystem.currentTournament;
            if (!tournament) return;
            
            const match = tournament.brackets.flat().find(m => m.id === matchId);
            if (match && match.status === 'ready') {
                enhancedTournamentSystem.startMatch(match);
            }
        }
        
        function startNextTournamentRound() {
            enhancedTournamentSystem.startNextRound();
        }
        
        function saveTournamentProgress() {
            enhancedTournamentSystem.saveTournamentProgress();
            alert('Tournament progress saved!');
            audioSystem?.play('menuClick');
        }
        
        function customizeTournament() {
            showPanel('tournamentCustomize');
            updateTournamentPreview();
        }
        
        function updateTournamentPreview() {
            const size = parseInt(document.getElementById('tournamentSize').value);
            const format = document.getElementById('bracketFormat').value;
            const difficulty = document.getElementById('difficultyProgression').value;
            const aiMode = document.getElementById('aiPersonalityMode').value;
            const matchLength = parseInt(document.getElementById('matchLength').value);
            
            const totalRounds = Math.ceil(Math.log2(size));
            const previewContent = document.getElementById('previewContent');
            
            let html = `
                <div class="preview-round">
                    <strong>Tournament Structure:</strong>
                    <span>${size} opponents, ${totalRounds} rounds</span>
                </div>
                <div class="preview-round">
                    <strong>Format:</strong>
                    <span>${format.charAt(0).toUpperCase() + format.slice(1)} Elimination</span>
                </div>
                <div class="preview-round">
                    <strong>Match Length:</strong>
                    <span>Best of ${matchLength}</span>
                </div>
            `;
            
            // Show AI progression preview
            if (aiMode === 'progressive') {
                const personalities = [
                    ['Balanced', 'Defensive'],
                    ['Aggressive', 'Unpredictable'],
                    ['Trickster', 'Copycat'],
                    ['Perfect', 'Adaptive']
                ];
                
                for (let i = 0; i < Math.min(totalRounds, 4); i++) {
                    const roundPersonalities = personalities[i] || ['Expert AI'];
                    html += `
                        <div class="preview-round">
                            <span>Round ${i + 1}:</span>
                            <span>${roundPersonalities.join(', ')}</span>
                        </div>
                    `;
                }
            }
            
            previewContent.innerHTML = html;
        }
        
        function createCustomTournament() {
            const settings = {
                size: parseInt(document.getElementById('tournamentSize').value),
                format: document.getElementById('bracketFormat').value,
                difficultyProgression: document.getElementById('difficultyProgression').value,
                aiPersonalityMode: document.getElementById('aiPersonalityMode').value,
                matchLength: parseInt(document.getElementById('matchLength').value)
            };
            
            enhancedTournamentSystem.createTournament(settings);
            showTournamentBracket();
            audioSystem?.play('gameStart');
        }
        
        function resetTournamentSettings() {
            document.getElementById('tournamentSize').value = '8';
            document.getElementById('bracketFormat').value = 'single';
            document.getElementById('difficultyProgression').value = 'adaptive';
            document.getElementById('aiPersonalityMode').value = 'progressive';
            document.getElementById('matchLength').value = '7';
            updateTournamentPreview();
            audioSystem?.play('menuClick');
        }
        
        function viewMatchDetails(matchId) {
            // Future enhancement: Show detailed match statistics
            console.log('View match details for:', matchId);
        }
        
        function exportAnalyticsAsCSV(data) {
            let csvContent = 'Enhanced Pong Analytics Export\n';
            csvContent += `Export Date,${data.timestamp}\n`;
            csvContent += `Game Version,${data.version}\n\n`;
            
            // Basic game stats
            csvContent += 'GAME STATISTICS\n';
            csvContent += 'Metric,Value\n';
            csvContent += `Games Played,${data.gameStats.gamesPlayed}\n`;
            csvContent += `Games Won,${data.gameStats.gamesWon}\n`;
            csvContent += `Games Lost,${data.gameStats.gamesLost}\n`;
            csvContent += `Win Rate,${data.gameStats.winRate}%\n`;
            csvContent += `Perfect Games,${data.gameStats.perfectGames}\n`;
            csvContent += `Longest Rally,${data.gameStats.longestRally}\n`;
            csvContent += `Total Hits,${data.gameStats.totalHits}\n`;
            csvContent += `Current Win Streak,${data.gameStats.currentWinStreak || 0}\n`;
            csvContent += `Best Win Streak,${data.gameStats.maxWinStreak || 0}\n\n`;
            
            // AI Personality performance
            csvContent += 'AI PERSONALITY PERFORMANCE\n';
            csvContent += 'AI Personality,Games Played,Wins,Losses,Win Rate\n';
            Object.entries(data.extendedAnalytics.aiPersonalityStats).forEach(([personality, stats]) => {
                const winRate = stats.totalGames > 0 ? Math.round((stats.wins / stats.totalGames) * 100) : 0;
                csvContent += `${personality},${stats.totalGames},${stats.wins},${stats.losses},${winRate}%\n`;
            });
            csvContent += '\n';
            
            // Tournament history
            if (data.extendedAnalytics.tournamentHistory.length > 0) {
                csvContent += 'TOURNAMENT HISTORY\n';
                csvContent += 'Tournament,Date,Result,Rounds Won,Total Rounds\n';
                data.extendedAnalytics.tournamentHistory.forEach((tournament, index) => {
                    const roundsWon = tournament.rounds ? tournament.rounds.filter(r => r.won).length : 0;
                    csvContent += `${index + 1},${tournament.startTime.split('T')[0]},${tournament.won ? 'Won' : 'Lost'},${roundsWon},${tournament.totalRounds}\n`;
                });
                csvContent += '\n';
            }
            
            // Heat map data summary
            csvContent += 'HEAT MAP DATA\n';
            csvContent += 'Type,Data Points\n';
            csvContent += `Player Hits,${data.heatMapData.playerHits}\n`;
            csvContent += `AI Hits,${data.heatMapData.aiHits}\n`;
            csvContent += `Ball Trajectories,${data.heatMapData.ballTrajectories}\n\n`;
            
            // Achievements
            csvContent += 'ACHIEVEMENTS UNLOCKED\n';
            csvContent += 'Achievement\n';
            data.achievements.forEach(achievement => {
                csvContent += `${achievement}\n`;
            });
            
            // Create and download CSV file
            const csvBlob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(csvBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `enhanced-pong-analytics-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            
            URL.revokeObjectURL(url);
        }

        // ===== MOBILE OPTIMIZATION FUNCTIONS =====
        
        function setupDeviceOrientation() {
            // Handle orientation changes
            window.addEventListener('orientationchange', handleOrientationChange);
            window.addEventListener('resize', handleResize);
            
            // Initial setup
            handleOrientationChange();
        }
        
        function handleOrientationChange() {
            // Delay to allow orientation to fully complete
            setTimeout(() => {
                const orientation = screen.orientation?.angle || window.orientation || 0;
                const isLandscape = Math.abs(orientation) === 90;
                
                document.body.classList.toggle('landscape', isLandscape);
                document.body.classList.toggle('portrait', !isLandscape);
                
                // Resize canvas for optimal display
                resizeCanvasForOrientation(isLandscape);
                
                // Announce orientation change for accessibility
                if (accessibilitySystem) {
                    accessibilitySystem.announceToScreenReader(
                        `Screen orientation changed to ${isLandscape ? 'landscape' : 'portrait'}`
                    );
                }
            }, 100);
        }
        
        function handleResize() {
            if (gameEngine && gameEngine.canvas) {
                const rect = gameEngine.canvas.getBoundingClientRect();
                // Update any canvas-dependent calculations
            }
        }
        
        function resizeCanvasForOrientation(isLandscape) {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            
            if (isMobileDevice()) {
                if (isLandscape) {
                    // Landscape: maximize width
                    canvas.style.width = '100vw';
                    canvas.style.height = 'auto';
                    canvas.style.maxHeight = '70vh';
                } else {
                    // Portrait: fit within viewport
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
                    canvas.style.maxWidth = '100vw';
                }
            }
        }
        
        function optimizeForMobile() {
            if (!isMobileDevice()) return;
            
            // Optimize performance for mobile devices
            optimizeMobilePerformance();
            
            // Setup mobile-specific UI improvements
            setupMobileUI();
            
            // Add mobile-specific meta tags if not already present
            addMobileMetaTags();
        }
        
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768 && 'ontouchstart' in window);
        }
        
        function optimizeMobilePerformance() {
            // Reduce particle density on mobile
            if (particleSystem) {
                particleSystem.maxParticles = Math.floor(particleSystem.maxParticles * 0.6);
            }
            
            // Reduce background effect intensity
            if (backgroundEffect) {
                backgroundEffect.intensity = Math.min(backgroundEffect.intensity, 0.8);
            }
            
            // Optimize canvas rendering
            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false; // Better performance
            }
            
            // Enable performance monitoring
            if ('performance' in window && 'memory' in performance) {
                monitorMobilePerformance();
            }
        }
        
        function monitorMobilePerformance() {
            let lastFrameTime = performance.now();
            let frameCount = 0;
            let totalFrameTime = 0;
            
            function checkPerformance() {
                const now = performance.now();
                const frameTime = now - lastFrameTime;
                lastFrameTime = now;
                
                frameCount++;
                totalFrameTime += frameTime;
                
                // Check every 60 frames (roughly 1 second at 60fps)
                if (frameCount >= 60) {
                    const averageFrameTime = totalFrameTime / frameCount;
                    const fps = 1000 / averageFrameTime;
                    
                    // If FPS drops below 45, reduce quality
                    if (fps < 45) {
                        reduceQualityForPerformance();
                    }
                    
                    frameCount = 0;
                    totalFrameTime = 0;
                }
                
                requestAnimationFrame(checkPerformance);
            }
            
            requestAnimationFrame(checkPerformance);
        }
        
        function reduceQualityForPerformance() {
            // Reduce particle effects
            if (particleSystem) {
                particleSystem.maxParticles = Math.max(50, Math.floor(particleSystem.maxParticles * 0.8));
            }
            
            // Reduce background effects
            if (backgroundEffect) {
                backgroundEffect.intensity = Math.max(0.5, backgroundEffect.intensity * 0.8);
            }
            
            // Disable some visual effects
            if (gameEngine) {
                gameEngine.settings.ballTrail = false;
                gameEngine.settings.screenShake = false;
            }
        }
        
        function setupMobileUI() {
            // Add mobile-specific CSS classes
            document.body.classList.add('mobile-device');
            
            // Create mobile control hints
            createMobileControlHints();
            
            // Setup mobile-optimized tournament brackets
            optimizeTournamentForMobile();
        }
        
        function createMobileControlHints() {
            const hintsContainer = document.createElement('div');
            hintsContainer.id = 'mobile-control-hints';
            hintsContainer.innerHTML = `
                <div class="mobile-hint" id="gameControlHint" style="display: none;">
                    <div class="hint-content">
                        <p>👆 <strong>Touch Controls:</strong></p>
                        <p>• Drag to move paddle</p>
                        <p>• Tap to pause/resume</p>
                        <p>• Swipe up/down for quick moves</p>
                        <p>• Long press for menu</p>
                    </div>
                    <button class="hint-close" onclick="closeMobileHint('gameControlHint')">✕</button>
                </div>
            `;
            
            document.body.appendChild(hintsContainer);
            
            // Show hints for first-time mobile users
            if (localStorage.getItem('mobileHintsShown') !== 'true') {
                setTimeout(() => showMobileHint('gameControlHint'), 2000);
                localStorage.setItem('mobileHintsShown', 'true');
            }
        }
        
        function showMobileHint(hintId) {
            const hint = document.getElementById(hintId);
            if (hint) {
                hint.style.display = 'block';
                setTimeout(() => closeMobileHint(hintId), 5000); // Auto-close after 5 seconds
            }
        }
        
        function closeMobileHint(hintId) {
            const hint = document.getElementById(hintId);
            if (hint) {
                hint.style.display = 'none';
            }
        }
        
        function optimizeTournamentForMobile() {
            // Make tournament brackets more mobile-friendly
            const style = document.createElement('style');
            style.id = 'mobile-tournament-styles';
            style.textContent = `
                @media (max-width: 768px) {
                    .tournament-bracket {
                        overflow-x: scroll;
                        -webkit-overflow-scrolling: touch;
                    }
                    
                    .bracket-container {
                        min-width: 800px;
                    }
                    
                    .bracket-match {
                        min-height: 60px;
                        font-size: 12px;
                    }
                    
                    .ai-personality-badge {
                        font-size: 10px;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        function addMobileMetaTags() {
            // Prevent zoom on input focus
            const viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
            }
            
            // Add apple-touch-icon if not present
            if (!document.querySelector('link[rel="apple-touch-icon"]')) {
                const appleIcon = document.createElement('link');
                appleIcon.rel = 'apple-touch-icon';
                appleIcon.href = 'icon-192x192.png';
                document.head.appendChild(appleIcon);
            }
            
            // Add theme-color for mobile browsers
            if (!document.querySelector('meta[name="theme-color"]')) {
                const themeColor = document.createElement('meta');
                themeColor.name = 'theme-color';
                themeColor.content = '#2a5298';
                document.head.appendChild(themeColor);
            }
        }
        
        // Integrate haptic feedback with game events
        function integrateHapticFeedback() {
            if (!mobileControlSystem || !mobileControlSystem.hapticSupported) return;
            
            // Add haptic feedback to existing game events
            const originalPlaySound = audioSystem?.play;
            if (originalPlaySound) {
                audioSystem.play = function(type) {
                    originalPlaySound.call(this, type);
                    
                    // Add haptic feedback based on sound type
                    switch(type) {
                        case 'paddleHit':
                            mobileControlSystem.triggerHapticFeedback('light');
                            break;
                        case 'wallBounce':
                            mobileControlSystem.triggerHapticFeedback('light');
                            break;
                        case 'score':
                            mobileControlSystem.triggerHapticFeedback('success');
                            break;
                        case 'win':
                            mobileControlSystem.triggerHapticFeedback('success');
                            break;
                        case 'lose':
                            mobileControlSystem.triggerHapticFeedback('error');
                            break;
                    }
                };
            }
        }
        
        // PWA Service Worker Registration and Full Offline Support
        function initializePWA() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    // Register service worker for offline functionality
                    registerServiceWorker();
                });
            }
            
            // Setup install prompt
            setupInstallPrompt();
            
            // Check for app updates
            checkForAppUpdates();
        }
        
        function registerServiceWorker() {
            // Create inline service worker for offline support
            const swCode = `
                const CACHE_NAME = 'enhanced-pong-v1.2.0';
                const urlsToCache = [
                    './',
                    './enhanced-pong.html',
                    'https://cdn.jsdelivr.net/npm/chart.js'
                ];
                
                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => cache.addAll(urlsToCache))
                    );
                });
                
                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => {
                                if (response) {
                                    return response;
                                }
                                return fetch(event.request);
                            })
                    );
                });
            `;
            
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);
            
            navigator.serviceWorker.register(swUrl)
                .then(registration => {
                    console.log('Enhanced Pong SW registered:', registration.scope);
                    showOfflineReadyMessage();
                })
                .catch(error => {
                    console.warn('SW registration failed:', error);
                });
        }
        
        function showOfflineReadyMessage() {
            const offlineMessage = document.createElement('div');
            offlineMessage.id = 'offline-ready-message';
            offlineMessage.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(42, 82, 152, 0.95);
                color: white;
                padding: 12px 20px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.2);
            `;
            offlineMessage.innerHTML = '✓ Enhanced Pong is now available offline!';
            document.body.appendChild(offlineMessage);
            
            setTimeout(() => {
                offlineMessage.style.opacity = '0';
                offlineMessage.style.transition = 'opacity 0.5s';
                setTimeout(() => offlineMessage.remove(), 500);
            }, 3000);
        }
        
        // PWA Install Prompt
        let deferredPrompt;
        
        function setupInstallPrompt() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                showInstallButton();
            });
            
            window.addEventListener('appinstalled', () => {
                console.log('Enhanced Pong installed as PWA');
                hideInstallButton();
                showInstalledMessage();
            });
        }
        
        function showInstallButton() {
            const installBtn = document.createElement('button');
            installBtn.id = 'pwa-install-btn';
            installBtn.className = 'menu-btn';
            installBtn.innerHTML = '📱 Install App';
            installBtn.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 9999;
                background: var(--primary-color);
                border: 2px solid var(--accent-color);
                color: white;
                padding: 8px 16px;
                border-radius: 25px;
                font-size: 12px;
                cursor: pointer;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            `;
            
            installBtn.addEventListener('click', installPWA);
            document.body.appendChild(installBtn);
        }
        
        function hideInstallButton() {
            const installBtn = document.getElementById('pwa-install-btn');
            if (installBtn) installBtn.remove();
        }
        
        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    }
                    deferredPrompt = null;
                });
            }
        }
        
        function showInstalledMessage() {
            const message = document.createElement('div');
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(76, 175, 80, 0.95);
                color: white;
                padding: 20px;
                border-radius: 15px;
                font-size: 16px;
                z-index: 10001;
                text-align: center;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;
            message.innerHTML = '✅ Enhanced Pong installed successfully!<br>You can now play offline anytime.';
            document.body.appendChild(message);
            
            setTimeout(() => message.remove(), 4000);
        }
        
        function checkForAppUpdates() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistration().then(registration => {
                    if (registration) {
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed') {
                                    if (navigator.serviceWorker.controller) {
                                        showUpdateAvailable();
                                    }
                                }
                            });
                        });
                    }
                });
            }
        }
        
        function showUpdateAvailable() {
            const updateMessage = document.createElement('div');
            updateMessage.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 152, 0, 0.95);
                color: white;
                padding: 15px 20px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 10000;
                cursor: pointer;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            updateMessage.innerHTML = '🆕 App update available! Tap to reload.';
            updateMessage.addEventListener('click', () => {
                window.location.reload();
            });
            document.body.appendChild(updateMessage);
        }
        
        // Offline Support Functions
        function initializeOfflineSupport() {
            // Monitor online/offline status
            window.addEventListener('online', handleOnlineStatus);
            window.addEventListener('offline', handleOfflineStatus);
            
            // Check initial status
            if (!navigator.onLine) {
                handleOfflineStatus();
            }
            
            // Setup offline data persistence
            setupOfflineDataPersistence();
        }
        
        function handleOnlineStatus() {
            hideOfflineIndicator();
            syncOfflineData();
            console.log('Enhanced Pong: Back online');
        }
        
        function handleOfflineStatus() {
            showOfflineIndicator();
            console.log('Enhanced Pong: Now offline');
        }
        
        function showOfflineIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'offline-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: rgba(244, 67, 54, 0.9);
                color: white;
                text-align: center;
                padding: 8px;
                font-size: 14px;
                z-index: 10002;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            `;
            indicator.innerHTML = '⚠️ Playing offline - Your progress will sync when reconnected';
            document.body.appendChild(indicator);
        }
        
        function hideOfflineIndicator() {
            const indicator = document.getElementById('offline-indicator');
            if (indicator) indicator.remove();
        }
        
        function setupOfflineDataPersistence() {
            // Enhanced local storage for offline play
            const originalSaveData = saveGameData;
            window.saveGameData = function(data) {
                // Save to localStorage for offline persistence
                const offlineData = {
                    timestamp: new Date().toISOString(),
                    data: data,
                    synced: navigator.onLine
                };
                
                const offlineQueue = JSON.parse(localStorage.getItem('offlineDataQueue') || '[]');
                offlineQueue.push(offlineData);
                localStorage.setItem('offlineDataQueue', JSON.stringify(offlineQueue));
                
                if (originalSaveData) {
                    originalSaveData(data);
                }
            };
        }
        
        function syncOfflineData() {
            const offlineQueue = JSON.parse(localStorage.getItem('offlineDataQueue') || '[]');
            
            if (offlineQueue.length > 0) {
                // Process offline data queue
                offlineQueue.forEach(item => {
                    if (!item.synced) {
                        // Attempt to sync data
                        try {
                            // Mark as synced
                            item.synced = true;
                        } catch (error) {
                            console.warn('Failed to sync offline data:', error);
                        }
                    }
                });
                
                // Update queue
                const syncedQueue = offlineQueue.filter(item => !item.synced);
                localStorage.setItem('offlineDataQueue', JSON.stringify(syncedQueue));
                
                if (syncedQueue.length === 0) {
                    showSyncCompleteMessage();
                }
            }
        }
        
        function showSyncCompleteMessage() {
            const message = document.createElement('div');
            message.style.cssText = `
                position: fixed;
                bottom: 60px;
                right: 20px;
                background: rgba(76, 175, 80, 0.9);
                color: white;
                padding: 10px 15px;
                border-radius: 20px;
                font-size: 12px;
                z-index: 10000;
            `;
            message.innerHTML = '✓ Offline progress synced!';
            document.body.appendChild(message);
            
            setTimeout(() => message.remove(), 3000);
        }
        
        // ===== ONLINE MULTIPLAYER SYSTEM =====
        
        class OnlineMultiplayerSystem {
            constructor() {
                this.isHost = false;
                this.isGuest = false;
                this.connection = null;
                this.peer = null;
                this.gameRoom = null;
                this.connectionStatus = 'disconnected';
                this.latency = 0;
                this.lastPingTime = 0;
                this.gameStateSync = {
                    lastSyncTime: 0,
                    syncInterval: 16, // ~60fps sync
                    desyncThreshold: 100 // ms
                };
                this.playerProfile = this.loadPlayerProfile();
                
                this.initializePeerJS();
            }
            
            initializePeerJS() {
                // Use a free PeerJS server for WebRTC signaling
                try {
                    this.peer = new Peer({
                        host: 'peerjs-server.herokuapp.com',
                        port: 443,
                        secure: true,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });
                    
                    this.setupPeerEvents();
                } catch (error) {
                    console.warn('PeerJS not available, multiplayer disabled:', error);
                    this.showMultiplayerError('WebRTC not supported in this environment');
                }
            }
            
            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    console.log('Peer connection opened with ID:', id);
                    this.playerId = id;
                    this.connectionStatus = 'ready';
                    this.updateConnectionUI();
                });
                
                this.peer.on('connection', (conn) => {
                    console.log('Incoming connection from:', conn.peer);
                    this.handleIncomingConnection(conn);
                });
                
                this.peer.on('error', (error) => {
                    console.error('Peer connection error:', error);
                    this.handleConnectionError(error);
                });
            }
            
            createRoom(roomId) {
                if (!this.peer) {
                    this.showMultiplayerError('Multiplayer not initialized');
                    return false;
                }
                
                this.gameRoom = {
                    id: roomId || this.generateRoomId(),
                    host: this.playerId,
                    guest: null,
                    gameState: 'waiting',
                    settings: {
                        winScore: 7,
                        ballSpeed: 5,
                        gameMode: 'online'
                    }
                };
                
                this.isHost = true;
                this.connectionStatus = 'hosting';
                this.updateConnectionUI();
                
                return this.gameRoom.id;
            }
            
            joinRoom(roomId) {
                if (!this.peer || !roomId) {
                    this.showMultiplayerError('Invalid room ID or multiplayer not ready');
                    return false;
                }
                
                try {
                    this.connection = this.peer.connect(roomId, {
                        reliable: true,
                        metadata: {
                            playerProfile: this.playerProfile,
                            gameVersion: '1.6.0'
                        }
                    });
                    
                    this.setupConnectionEvents();
                    this.isGuest = true;
                    this.connectionStatus = 'connecting';
                    this.updateConnectionUI();
                    
                    return true;
                } catch (error) {
                    console.error('Failed to join room:', error);
                    this.showMultiplayerError('Failed to connect to room');
                    return false;
                }
            }
            
            handleIncomingConnection(conn) {
                if (this.connection) {
                    conn.close();
                    return; // Already have a connection
                }
                
                this.connection = conn;
                this.setupConnectionEvents();
                
                if (this.gameRoom) {
                    this.gameRoom.guest = conn.peer;
                    this.gameRoom.gameState = 'connected';
                }
            }
            
            setupConnectionEvents() {
                this.connection.on('open', () => {
                    console.log('Data connection established');
                    this.connectionStatus = 'connected';
                    this.startPingMonitoring();
                    this.updateConnectionUI();
                    
                    if (this.isHost) {
                        this.sendGameState('room_joined', this.gameRoom);
                    }
                });
                
                this.connection.on('data', (data) => {
                    this.handleGameMessage(data);
                });
                
                this.connection.on('close', () => {
                    console.log('Connection closed');
                    this.handleDisconnection();
                });
                
                this.connection.on('error', (error) => {
                    console.error('Connection error:', error);
                    this.handleConnectionError(error);
                });
            }
            
            sendGameMessage(type, data) {
                if (!this.connection || this.connection.open !== true) {
                    return false;
                }
                
                try {
                    const message = {
                        type: type,
                        data: data,
                        timestamp: Date.now(),
                        playerId: this.playerId
                    };
                    
                    this.connection.send(message);
                    return true;
                } catch (error) {
                    console.error('Failed to send message:', error);
                    return false;
                }
            }
            
            handleGameMessage(message) {
                const { type, data, timestamp, playerId } = message;
                
                switch (type) {
                    case 'paddle_move':
                        this.handleOpponentPaddleMove(data);
                        break;
                    case 'ball_sync':
                        this.handleBallSync(data);
                        break;
                    case 'game_start':
                        this.handleGameStart(data);
                        break;
                    case 'score_update':
                        this.handleScoreUpdate(data);
                        break;
                    case 'game_pause':
                        this.handleGamePause(data);
                        break;
                    case 'game_end':
                        this.handleGameEnd(data);
                        break;
                    case 'ping':
                        this.handlePing(timestamp);
                        break;
                    case 'pong':
                        this.handlePong(timestamp);
                        break;
                    case 'room_joined':
                        this.handleRoomJoined(data);
                        break;
                    case 'chat_message':
                        this.handleChatMessage(data);
                        break;
                    default:
                        console.warn('Unknown message type:', type);
                }
            }
            
            startMultiplayerGame() {
                if (!this.connection || this.connectionStatus !== 'connected') {
                    this.showMultiplayerError('No connection established');
                    return false;
                }
                
                if (this.isHost) {
                    // Host starts the game
                    gameEngine.setGameMode('online');
                    gameEngine.gameState = 'playing';
                    
                    this.sendGameMessage('game_start', {
                        hostSide: 'left',
                        guestSide: 'right',
                        settings: this.gameRoom.settings
                    });
                    
                    this.startGameStateSync();
                } else {
                    // Guest waits for host to start
                    this.showWaitingMessage('Waiting for host to start the game...');
                }
                
                return true;
            }
            
            startGameStateSync() {
                this.gameSyncInterval = setInterval(() => {
                    if (gameEngine.gameState === 'playing' && this.isHost) {
                        this.syncBallPosition();
                    }
                    this.syncPaddlePosition();
                }, this.gameStateSync.syncInterval);
            }
            
            syncPaddlePosition() {
                const paddleData = {
                    y: this.isHost ? gameEngine.player.y : gameEngine.ai.y,
                    velocity: 0, // Could track velocity for prediction
                    timestamp: Date.now()
                };
                
                this.sendGameMessage('paddle_move', paddleData);
            }
            
            syncBallPosition() {
                if (!this.isHost) return;
                
                const ballData = {
                    x: gameEngine.ball.x,
                    y: gameEngine.ball.y,
                    vx: gameEngine.ball.vx,
                    vy: gameEngine.ball.vy,
                    timestamp: Date.now()
                };
                
                this.sendGameMessage('ball_sync', ballData);
            }
            
            handleOpponentPaddleMove(data) {
                const opponentPaddle = this.isHost ? gameEngine.ai : gameEngine.player;
                const latencyCompensation = (Date.now() - data.timestamp) / 1000;
                
                // Apply position with latency compensation
                opponentPaddle.y = data.y + (data.velocity * latencyCompensation);
            }
            
            handleBallSync(data) {
                if (this.isHost) return; // Only guest receives ball sync
                
                const latencyCompensation = (Date.now() - data.timestamp) / 1000;
                
                // Apply ball position with prediction
                gameEngine.ball.x = data.x + (data.vx * latencyCompensation);
                gameEngine.ball.y = data.y + (data.vy * latencyCompensation);
                gameEngine.ball.vx = data.vx;
                gameEngine.ball.vy = data.vy;
            }
            
            startPingMonitoring() {
                this.pingInterval = setInterval(() => {
                    this.lastPingTime = Date.now();
                    this.sendGameMessage('ping', this.lastPingTime);
                }, 1000); // Ping every second
            }
            
            handlePing(timestamp) {
                this.sendGameMessage('pong', timestamp);
            }
            
            handlePong(originalTimestamp) {
                this.latency = Date.now() - originalTimestamp;
                this.updateLatencyDisplay();
            }
            
            handleGameStart(data) {
                console.log('Game started by host:', data);
                
                if (this.isGuest) {
                    gameEngine.setGameMode('online');
                    gameEngine.gameState = 'playing';
                    
                    // Set up sides (guest is always on the right)
                    this.playerSide = data.guestSide;
                    
                    showPanel('game');
                    document.getElementById('gameModeDisplay').textContent = 
                        'ONLINE MULTIPLAYER vs ' + (this.connection.metadata?.playerProfile?.displayName || 'Opponent');
                    
                    this.startGameStateSync();
                }
            }
            
            handleScoreUpdate(data) {
                console.log('Score update:', data);
                
                if (gameEngine) {
                    // Update scores based on player side
                    if (this.isHost) {
                        gameEngine.player.score = data.hostScore;
                        gameEngine.ai.score = data.guestScore;
                    } else {
                        gameEngine.player.score = data.guestScore;
                        gameEngine.ai.score = data.hostScore;
                    }
                }
            }
            
            handleGamePause(data) {
                console.log('Game paused by opponent');
                
                if (gameEngine) {
                    gameEngine.gameState = 'paused';
                    this.showWaitingMessage('Game paused by opponent');
                }
            }
            
            handleGameEnd(data) {
                console.log('Game ended:', data);
                
                if (gameEngine) {
                    gameEngine.gameState = 'gameOver';
                    
                    // Update player profile stats
                    this.updatePlayerStats(data.winner === this.playerId);
                    
                    // Show game results
                    this.showGameResults(data);
                }
            }
            
            handleRoomJoined(data) {
                console.log('Room joined successfully:', data);
                
                // Update UI to show ready state
                const gameReadySection = document.getElementById('gameReadySection');
                if (gameReadySection) {
                    gameReadySection.style.display = 'block';
                    
                    document.getElementById('yourPlayerName').textContent = 
                        this.playerProfile.displayName;
                    document.getElementById('opponentPlayerName').textContent = 
                        this.connection.metadata?.playerProfile?.displayName || 'Host';
                }
                
                this.showWaitingMessage('Connected! Waiting for host to start the match...');
            }
            
            handleChatMessage(data) {
                console.log('Chat message:', data);
                // Could implement in-game chat here
            }
            
            handleDisconnection() {
                console.log('Player disconnected');
                this.connectionStatus = 'disconnected';
                
                // Pause game if playing
                if (gameEngine && gameEngine.gameState === 'playing') {
                    gameEngine.gameState = 'paused';
                    this.showWaitingMessage('Opponent disconnected. Game paused.');
                }
                
                this.updateConnectionUI();
            }
            
            handleConnectionError(error) {
                console.error('Connection error:', error);
                this.connectionStatus = 'disconnected';
                this.updateConnectionUI();
                this.showMultiplayerError('Connection error: ' + error.message);
            }
            
            updatePlayerStats(won) {
                this.playerProfile.gamesPlayed++;
                if (won) {
                    this.playerProfile.gamesWon++;
                    this.playerProfile.rating += 25; // Simple rating system
                } else {
                    this.playerProfile.rating = Math.max(800, this.playerProfile.rating - 15);
                }
                
                this.savePlayerProfile();
            }
            
            showGameResults(data) {
                const winner = data.winner === this.playerId ? 'You' : 'Opponent';
                const message = winner === 'You' ? 'Victory!' : 'Defeat!';
                
                setTimeout(() => {
                    alert(message + ' Final Score: ' + data.finalScore.player + '-' + data.finalScore.opponent);
                    showPanel('onlineMultiplayer');
                }, 2000);
            }
            
            disconnect() {
                if (this.connection) {
                    this.connection.close();
                }
                
                if (this.gameSyncInterval) {
                    clearInterval(this.gameSyncInterval);
                }
                
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                }
                
                this.connectionStatus = 'disconnected';
                this.isHost = false;
                this.isGuest = false;
                this.gameRoom = null;
                
                this.updateConnectionUI();
            }
            
            generateRoomId() {
                return Math.random().toString(36).substr(2, 8).toUpperCase();
            }
            
            loadPlayerProfile() {
                const saved = localStorage.getItem('enhancedPongPlayerProfile');
                return saved ? JSON.parse(saved) : {
                    playerId: this.generatePlayerId(),
                    displayName: 'Player' + Math.floor(Math.random() * 1000),
                    gamesPlayed: 0,
                    gamesWon: 0,
                    rating: 1200,
                    createdAt: new Date().toISOString()
                };
            }
            
            savePlayerProfile() {
                localStorage.setItem('enhancedPongPlayerProfile', JSON.stringify(this.playerProfile));
            }
            
            generatePlayerId() {
                return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            }
            
            updateConnectionUI() {
                // Update multiplayer UI based on connection status
                const statusElement = document.getElementById('multiplayerStatus');
                const latencyElement = document.getElementById('latencyDisplay');
                
                if (statusElement) {
                    statusElement.textContent = this.getStatusText();
                    statusElement.className = 'connection-status ' + this.connectionStatus;
                }
            }
            
            updateLatencyDisplay() {
                const element = document.getElementById('latencyDisplay');
                if (element) {
                    const color = this.latency < 50 ? 'green' : this.latency < 100 ? 'yellow' : 'red';
                    element.innerHTML = `<span style="color: ${color}">${this.latency}ms</span>`;
                }
            }
            
            getStatusText() {
                const statusTexts = {
                    disconnected: '❌ Disconnected',
                    ready: '✅ Ready',
                    hosting: '🏠 Hosting Room',
                    connecting: '🔄 Connecting...',
                    connected: '✅ Connected'
                };
                
                return statusTexts[this.connectionStatus] || 'Unknown';
            }
            
            showMultiplayerError(message) {
                console.error('Multiplayer Error:', message);
                // Show error to user - implementation depends on UI
            }
            
            showWaitingMessage(message) {
                console.log('Multiplayer:', message);
                // Show waiting message to user
            }
        }
        
        // Initialize multiplayer system
        let multiplayerSystem = null;
        
        // ===== GAME REPLAY SYSTEM =====
        
        class GameReplaySystem {
            constructor() {
                this.isRecording = false;
                this.currentReplay = null;
                this.replayData = {
                    gameStates: [],
                    metadata: null,
                    events: []
                };
                this.recordingInterval = null;
                this.frameRate = 30; // Record at 30 FPS
                this.maxRecordingTime = 300000; // 5 minutes max
                
                this.loadSavedReplays();
            }
            
            startRecording(gameMode, aiPersonality, playerName = 'Player') {
                this.isRecording = true;
                this.replayData = {
                    gameStates: [],
                    metadata: {
                        id: this.generateReplayId(),
                        gameMode: gameMode,
                        aiPersonality: aiPersonality,
                        playerName: playerName,
                        startTime: new Date().toISOString(),
                        endTime: null,
                        duration: 0,
                        finalScore: null,
                        winner: null,
                        version: '1.6.0'
                    },
                    events: []
                };
                
                console.log('Started recording replay:', this.replayData.metadata.id);
                
                // Record initial state
                this.recordGameState();
                
                // Start periodic recording
                this.recordingInterval = setInterval(() => {
                    this.recordGameState();
                }, 1000 / this.frameRate);
                
                // Stop recording after max time
                setTimeout(() => {
                    if (this.isRecording) {
                        this.stopRecording('timeout');
                    }
                }, this.maxRecordingTime);
                
                return this.replayData.metadata.id;
            }
            
            recordGameState() {
                if (!this.isRecording || !gameEngine) return;
                
                const gameState = {
                    timestamp: Date.now(),
                    frameIndex: this.replayData.gameStates.length,
                    ball: {
                        x: gameEngine.ball.x,
                        y: gameEngine.ball.y,
                        vx: gameEngine.ball.vx,
                        vy: gameEngine.ball.vy,
                        width: gameEngine.ball.width,
                        height: gameEngine.ball.height
                    },
                    player: {
                        y: gameEngine.player.y,
                        score: gameEngine.player.score,
                        height: gameEngine.player.height
                    },
                    ai: {
                        y: gameEngine.ai.y,
                        score: gameEngine.ai.score,
                        height: gameEngine.ai.height,
                        personality: gameEngine.ai.personality
                    },
                    gameState: gameEngine.gameState,
                    currentRally: gameEngine.stats?.currentRally || 0,
                    effects: {
                        playerEffects: { ...gameEngine.playerEffects },
                        aiEffects: { ...gameEngine.aiEffects },
                        ballSizeEffect: gameEngine.ballSizeEffect,
                        magneticEffect: gameEngine.magneticEffect
                    },
                    powerUps: gameEngine.powerUps ? gameEngine.powerUps.map(p => ({
                        x: p.x,
                        y: p.y,
                        type: p.type,
                        active: p.active
                    })) : []
                };
                
                this.replayData.gameStates.push(gameState);
                
                // Limit memory usage - keep only recent states if too many
                if (this.replayData.gameStates.length > 18000) { // 10 minutes at 30fps
                    this.replayData.gameStates.shift();
                }
            }
            
            recordEvent(eventType, eventData) {
                if (!this.isRecording) return;
                
                const event = {
                    timestamp: Date.now(),
                    frameIndex: this.replayData.gameStates.length - 1,
                    type: eventType,
                    data: eventData
                };
                
                this.replayData.events.push(event);
                console.log('Recorded event:', eventType, eventData);
            }
            
            stopRecording(reason = 'manual') {
                if (!this.isRecording) return null;
                
                this.isRecording = false;
                
                if (this.recordingInterval) {
                    clearInterval(this.recordingInterval);
                    this.recordingInterval = null;
                }
                
                // Finalize metadata
                this.replayData.metadata.endTime = new Date().toISOString();
                this.replayData.metadata.duration = Date.now() - new Date(this.replayData.metadata.startTime).getTime();
                
                if (gameEngine) {
                    this.replayData.metadata.finalScore = {
                        player: gameEngine.player.score,
                        ai: gameEngine.ai.score
                    };
                    this.replayData.metadata.winner = 
                        gameEngine.player.score > gameEngine.ai.score ? 'player' : 'ai';
                }
                
                console.log('Stopped recording replay:', this.replayData.metadata.id, 'Reason:', reason);
                
                // Save replay to localStorage
                this.saveReplay(this.replayData);
                
                const replayId = this.replayData.metadata.id;
                this.replayData = { gameStates: [], metadata: null, events: [] };
                
                return replayId;
            }
            
            saveReplay(replayData) {
                try {
                    const compressed = this.compressReplayData(replayData);
                    const savedReplays = this.getSavedReplays();
                    
                    savedReplays[replayData.metadata.id] = {
                        metadata: replayData.metadata,
                        compressed: compressed,
                        size: JSON.stringify(compressed).length
                    };
                    
                    // Limit number of saved replays (keep most recent 20)
                    const replayIds = Object.keys(savedReplays);
                    if (replayIds.length > 20) {
                        const sortedIds = replayIds.sort((a, b) => 
                            new Date(savedReplays[b].metadata.startTime) - new Date(savedReplays[a].metadata.startTime)
                        );
                        
                        // Remove oldest replays
                        sortedIds.slice(20).forEach(id => {
                            delete savedReplays[id];
                        });
                    }
                    
                    localStorage.setItem('enhancedPongReplays', JSON.stringify(savedReplays));
                    console.log('Saved replay:', replayData.metadata.id);
                } catch (error) {
                    console.error('Failed to save replay:', error);
                }
            }
            
            compressReplayData(replayData) {
                // Simple compression by removing duplicate states and using deltas
                const compressed = {
                    metadata: replayData.metadata,
                    events: replayData.events,
                    gameStates: []
                };
                
                let lastState = null;
                replayData.gameStates.forEach((state, index) => {
                    if (index === 0 || index % 5 === 0) { // Keep every 5th frame
                        compressed.gameStates.push(state);
                        lastState = state;
                    }
                });
                
                return compressed;
            }
            
            getSavedReplays() {
                try {
                    const saved = localStorage.getItem('enhancedPongReplays');
                    return saved ? JSON.parse(saved) : {};
                } catch (error) {
                    console.error('Error loading saved replays:', error);
                    return {};
                }
            }
            
            loadSavedReplays() {
                this.savedReplays = this.getSavedReplays();
                console.log('Loaded', Object.keys(this.savedReplays).length, 'saved replays');
            }
            
            getReplaysList() {
                const replays = this.getSavedReplays();
                return Object.values(replays)
                    .map(replay => replay.metadata)
                    .sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
            }
            
            loadReplay(replayId) {
                const savedReplays = this.getSavedReplays();
                const replayData = savedReplays[replayId];
                
                if (!replayData) {
                    console.error('Replay not found:', replayId);
                    return null;
                }
                
                return this.decompressReplayData(replayData.compressed);
            }
            
            decompressReplayData(compressed) {
                // Decompress by interpolating between keyframes
                const decompressed = {
                    metadata: compressed.metadata,
                    events: compressed.events,
                    gameStates: []
                };
                
                // For now, just return the compressed states
                // Could implement interpolation between keyframes here
                decompressed.gameStates = compressed.gameStates;
                
                return decompressed;
            }
            
            deleteReplay(replayId) {
                const savedReplays = this.getSavedReplays();
                if (savedReplays[replayId]) {
                    delete savedReplays[replayId];
                    localStorage.setItem('enhancedPongReplays', JSON.stringify(savedReplays));
                    console.log('Deleted replay:', replayId);
                    return true;
                }
                return false;
            }
            
            exportReplay(replayId) {
                const replayData = this.loadReplay(replayId);
                if (!replayData) return null;
                
                const exportData = {
                    ...replayData,
                    exportedAt: new Date().toISOString(),
                    exportVersion: '1.0'
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `enhanced-pong-replay-${replayId}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                return true;
            }
            
            generateReplayId() {
                return 'replay_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
            }
            
            // Integration with game engine
            initializeGameIntegration() {
                // Hook into game events to record them
                this.hookGameEvents();
            }
            
            hookGameEvents() {
                // Override game engine methods to record events
                if (!gameEngine) return;
                
                const originalWinGame = gameEngine.winGame;
                gameEngine.winGame = () => {
                    this.recordEvent('game_win', {
                        playerScore: gameEngine.player.score,
                        aiScore: gameEngine.ai.score
                    });
                    originalWinGame.call(gameEngine);
                    this.stopRecording('game_end');
                };
                
                const originalLoseGame = gameEngine.loseGame;
                gameEngine.loseGame = () => {
                    this.recordEvent('game_lose', {
                        playerScore: gameEngine.player.score,
                        aiScore: gameEngine.ai.score
                    });
                    originalLoseGame.call(gameEngine);
                    this.stopRecording('game_end');
                };
            }
        }
        
        // Initialize replay system
        let replaySystem = null;
        
        // ===== MULTIPLAYER UI FUNCTIONS =====
        
        function initializeMultiplayerUI() {
            if (!multiplayerSystem) {
                console.warn('Multiplayer system not initialized');
                return;
            }
            
            // Update player profile display
            updatePlayerProfileUI();
            
            // Update connection status
            multiplayerSystem.updateConnectionUI();
            
            // Setup event listeners for room ID inputs
            setupRoomInputValidation();
        }
        
        function updatePlayerProfileUI() {
            if (!multiplayerSystem || !multiplayerSystem.playerProfile) return;
            
            const profile = multiplayerSystem.playerProfile;
            
            document.getElementById('playerDisplayName').textContent = profile.displayName;
            document.getElementById('displayNameInput').value = profile.displayName;
            document.getElementById('onlineGamesPlayed').textContent = profile.gamesPlayed;
            document.getElementById('onlineGamesWon').textContent = profile.gamesWon;
            document.getElementById('playerRating').textContent = profile.rating;
        }
        
        function setupRoomInputValidation() {
            const roomIdInput = document.getElementById('roomIdInput');
            const joinRoomInput = document.getElementById('joinRoomInput');
            
            if (roomIdInput) {
                roomIdInput.addEventListener('input', function() {
                    this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                });
            }
            
            if (joinRoomInput) {
                joinRoomInput.addEventListener('input', function() {
                    this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                });
            }
        }
        
        function createOnlineRoom() {
            if (!socketManager || !socketManager.isConnected) {
                showError('Not connected to multiplayer server. Please check your connection.');
                return;
            }
            
            if (!socketManager.user) {
                showError('Please log in first to create a room.');
                // Show login UI
                showAuthenticationUI();
                return;
            }
            
            try {
                // Start matchmaking to find another player
                socketManager.startMatchmaking();
                
                // Update UI to show matchmaking state
                document.getElementById('createRoomBtn').disabled = true;
                document.getElementById('createRoomBtn').textContent = 'Looking for opponent...';
                
                showSuccess('Looking for an opponent to play with...');
                audioSystem?.play('menuClick');
                
                // Auto-cancel after 30 seconds if no match found
                setTimeout(() => {
                    if (document.getElementById('createRoomBtn').disabled) {
                        cancelMatchmaking();
                    }
                }, 30000);
            } catch (error) {
                console.error('Error starting matchmaking:', error);
                showError('Failed to start matchmaking: ' + error.message);
            }
        }
        
        function joinOnlineRoom() {
            if (!socketManager || !socketManager.isConnected) {
                showError('Not connected to multiplayer server. Please check your connection.');
                return;
            }
            
            if (!socketManager.user) {
                showError('Please log in first to join a room.');
                showAuthenticationUI();
                return;
            }
            
            try {
                // For now, treat 'join room' as starting matchmaking too
                // In a future version, we could implement private rooms
                socketManager.startMatchmaking();
                
                document.getElementById('joinRoomBtn').disabled = true;
                document.getElementById('joinRoomBtn').textContent = 'Looking for game...';
                document.getElementById('joinRoomInput').disabled = true;
                
                showSuccess('Searching for available games...');
                audioSystem?.play('menuClick');
                
                // Auto-cancel after 30 seconds
                setTimeout(() => {
                    if (document.getElementById('joinRoomBtn').disabled) {
                        cancelMatchmaking();
                    }
                }, 30000);
            } catch (error) {
                console.error('Error joining room:', error);
                showError('Failed to search for games: ' + error.message);
            }
        }
        
        function startOnlineMatch() {
            if (!socketManager || !socketManager.isConnected) {
                showError('Not connected to multiplayer server.');
                return;
            }
            
            if (!socketManager.currentRoom) {
                showError('No active game room. Please find a match first.');
                return;
            }
            
            // The game should start automatically when match is found
            // This function might not be needed in the new flow
            showSuccess('Game starting...');
            audioSystem?.play('gameStart');
        }
        
        function cancelMatchmaking() {
            if (socketManager) {
                socketManager.cancelMatchmaking();
            }
            
            // Reset UI elements
            const createBtn = document.getElementById('createRoomBtn');
            const joinBtn = document.getElementById('joinRoomBtn');
            const joinInput = document.getElementById('joinRoomInput');
            
            if (createBtn) {
                createBtn.disabled = false;
                createBtn.textContent = '🏠 Create Room';
            }
            
            if (joinBtn) {
                joinBtn.disabled = false;
                joinBtn.textContent = '🚺 Join Room';
            }
            
            if (joinInput) {
                joinInput.disabled = false;
            }
            
            showSuccess('Matchmaking cancelled');
            audioSystem?.play('menuClick');
        }
        
        function showAuthenticationUI() {
            // TODO: Create proper login/registration UI
            const username = prompt('Enter your username:');
            const password = prompt('Enter your password (or leave empty to register):');
            
            if (!username) {
                showError('Username is required');
                return;
            }
            
            if (password) {
                // Login
                loginUser(username, password);
            } else {
                // Register
                registerUser(username);
            }
        }
        
        async function loginUser(username, password) {
            try {
                const result = await socketManager.login({ username, password });
                showSuccess('Logged in successfully as ' + result.user.username);
            } catch (error) {
                console.error('Login failed:', error);
                showError('Login failed: ' + error.message);
            }
        }
        
        async function registerUser(username) {
            try {
                const email = username + '@temp.example'; // Temporary email
                const password = 'temppass123'; // Temporary password
                
                const result = await socketManager.register({ 
                    username, 
                    email, 
                    password 
                });
                
                showSuccess('Registered and logged in as ' + result.user.username);
            } catch (error) {
                console.error('Registration failed:', error);
                showError('Registration failed: ' + error.message);
            }
        }
        
        function updatePlayerProfile() {
            const newDisplayName = document.getElementById('displayNameInput').value.trim();
            
            if (!newDisplayName) {
                showError('Please enter a display name');
                return;
            }
            
            if (newDisplayName.length > 20) {
                showError('Display name must be 20 characters or less');
                return;
            }
            
            if (multiplayerSystem && multiplayerSystem.playerProfile) {
                multiplayerSystem.playerProfile.displayName = newDisplayName;
                multiplayerSystem.savePlayerProfile();
                
                document.getElementById('playerDisplayName').textContent = newDisplayName;
                showSuccess('Profile updated successfully!');
                audioSystem?.play('menuClick');
            }
        }
        
        function copyRoomId() {
            const roomId = document.getElementById('displayRoomId').textContent;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(roomId).then(() => {
                    showSuccess('Room ID copied to clipboard!');
                    audioSystem?.play('menuClick');
                }).catch(() => {
                    fallbackCopyToClipboard(roomId);
                });
            } else {
                fallbackCopyToClipboard(roomId);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showSuccess('Room ID copied to clipboard!');
                audioSystem?.play('menuClick');
            } catch (err) {
                showError('Failed to copy Room ID. Please copy manually: ' + text);
            }
            
            document.body.removeChild(textArea);
        }
        
        function disconnectMultiplayer() {
            if (socketManager) {
                socketManager.disconnect();
                
                // Reset UI
                document.getElementById('roomInfo').style.display = 'none';
                document.getElementById('gameReadySection').style.display = 'none';
                
                const createBtn = document.getElementById('createRoomBtn');
                const joinBtn = document.getElementById('joinRoomBtn');
                const joinInput = document.getElementById('joinRoomInput');
                const roomInput = document.getElementById('roomIdInput');
                
                if (createBtn) {
                    createBtn.disabled = false;
                    createBtn.textContent = '🏠 Create Room';
                }
                
                if (joinBtn) {
                    joinBtn.disabled = false;
                    joinBtn.textContent = '🚺 Join Room';
                }
                
                if (joinInput) joinInput.disabled = false;
                if (roomInput) roomInput.value = '';
                if (joinInput) joinInput.value = '';
                
                showSuccess('Disconnected from multiplayer server');
                audioSystem?.play('menuClick');
            }
        }
        
        // ===== AUTHENTICATION FUNCTIONS =====
        
        // Enhanced authentication UI function (replaces simple prompt)
        function showAuthenticationUI() {
            // Update server status
            updateAuthServerStatus();
            
            // Show the authentication panel
            showPanel('auth');
            
            // Check if user is already logged in
            checkExistingLogin();
        }
        
        function updateAuthServerStatus() {
            const statusElement = document.getElementById('authServerStatus');
            if (statusElement && socketManager) {
                if (socketManager.isConnected) {
                    statusElement.innerHTML = '✅ Connected';
                } else {
                    statusElement.innerHTML = '🔄 Connecting...';
                }
            }
        }
        
        function checkExistingLogin() {
            const token = localStorage.getItem('authToken');
            const userData = localStorage.getItem('userData');
            
            if (token && userData && socketManager && socketManager.isConnected) {
                try {
                    const user = JSON.parse(userData);
                    showAuthSuccess(`Welcome back, ${user.username}!`);
                    showUserProfile(user);
                    
                    // Try to authenticate with stored token
                    socketManager.authenticate(token).catch(error => {
                        console.error('Token validation failed:', error);
                        clearStoredAuth();
                        showLoginForm();
                    });
                } catch (error) {
                    console.error('Invalid stored user data:', error);
                    clearStoredAuth();
                    showLoginForm();
                }
            } else {
                showLoginForm();
            }
        }
        
        function showLoginForm() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('userProfileSection').style.display = 'none';
            clearAuthMessages();
        }
        
        function showRegisterForm() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
            document.getElementById('userProfileSection').style.display = 'none';
            clearAuthMessages();
            audioSystem?.play('menuClick');
        }
        
        function showUserProfile(user) {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('userProfileSection').style.display = 'block';
            
            // Update profile information
            document.getElementById('currentUserName').textContent = user.username;
            document.getElementById('currentUserEmail').textContent = user.email || 'No email provided';
            
            // Update stats if available
            if (user.stats) {
                document.getElementById('userGamesPlayed').textContent = user.stats.gamesPlayed || 0;
                document.getElementById('userGamesWon').textContent = user.stats.gamesWon || 0;
                document.getElementById('userCurrentRating').textContent = user.stats.rating || 1200;
                
                const winRate = user.stats.gamesPlayed > 0 ? 
                    Math.round((user.stats.gamesWon / user.stats.gamesPlayed) * 100) : 0;
                document.getElementById('userWinRate').textContent = winRate + '%';
            }
        }
        
        async function performLogin() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!validateLoginForm(username, password)) {
                return;
            }
            
            setLoginLoading(true);
            clearAuthMessages();
            
            try {
                const result = await socketManager.login({ username, password });
                
                // Store authentication data
                localStorage.setItem('authToken', result.token);
                localStorage.setItem('userData', JSON.stringify(result.user));
                
                showAuthSuccess(`Welcome back, ${result.user.username}!`);
                showUserProfile(result.user);
                
                audioSystem?.play('win');
            } catch (error) {
                console.error('Login failed:', error);
                showAuthError('Login failed: ' + error.message);
            } finally {
                setLoginLoading(false);
            }
        }
        
        async function performRegistration() {
            const username = document.getElementById('registerUsername').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerPasswordConfirm').value;
            
            if (!validateRegistrationForm(username, email, password, confirmPassword)) {
                return;
            }
            
            setRegisterLoading(true);
            clearAuthMessages();
            
            try {
                const result = await socketManager.register({ username, email, password });
                
                // Store authentication data
                localStorage.setItem('authToken', result.token);
                localStorage.setItem('userData', JSON.stringify(result.user));
                
                showAuthSuccess(`Account created successfully! Welcome, ${result.user.username}!`);
                showUserProfile(result.user);
                
                audioSystem?.play('win');
            } catch (error) {
                console.error('Registration failed:', error);
                showAuthError('Registration failed: ' + error.message);
            } finally {
                setRegisterLoading(false);
            }
        }
        
        function performLogout() {
            clearStoredAuth();
            showAuthSuccess('Signed out successfully!');
            showLoginForm();
            audioSystem?.play('menuClick');
            
            // Disconnect from multiplayer if connected
            if (socketManager && socketManager.isConnected) {
                socketManager.user = null;
                socketManager.updateUserDisplay();
            }
        }
        
        function quickPlayAsGuest() {
            if (!socketManager || !socketManager.isConnected) {
                showAuthError('Not connected to server. Please try again.');
                return;
            }
            
            // Generate a temporary guest username
            const guestName = 'Guest' + Math.floor(Math.random() * 10000);
            
            showAuthInfo(`Joining as ${guestName}...`);
            
            // Create a temporary user object
            const guestUser = {
                id: 'guest_' + Date.now(),
                username: guestName,
                email: null,
                isGuest: true,
                stats: { gamesPlayed: 0, gamesWon: 0, rating: 1200 }
            };
            
            // Set the user in socket manager
            socketManager.user = guestUser;
            socketManager.updateUserDisplay();
            
            showAuthSuccess(`Ready to play as ${guestName}!`);
            showUserProfile(guestUser);
            
            audioSystem?.play('gameStart');
        }
        
        function validateLoginForm(username, password) {
            if (!username) {
                showAuthError('Please enter your username');
                document.getElementById('loginUsername').focus();
                return false;
            }
            
            if (!password) {
                showAuthError('Please enter your password');
                document.getElementById('loginPassword').focus();
                return false;
            }
            
            if (username.length < 3) {
                showAuthError('Username must be at least 3 characters');
                document.getElementById('loginUsername').focus();
                return false;
            }
            
            return true;
        }
        
        function validateRegistrationForm(username, email, password, confirmPassword) {
            if (!username) {
                showAuthError('Please enter a username');
                document.getElementById('registerUsername').focus();
                return false;
            }
            
            if (username.length < 3 || username.length > 20) {
                showAuthError('Username must be 3-20 characters long');
                document.getElementById('registerUsername').focus();
                return false;
            }
            
            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                showAuthError('Username can only contain letters, numbers, and underscores');
                document.getElementById('registerUsername').focus();
                return false;
            }
            
            if (!email) {
                showAuthError('Please enter an email address');
                document.getElementById('registerEmail').focus();
                return false;
            }
            
            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                showAuthError('Please enter a valid email address');
                document.getElementById('registerEmail').focus();
                return false;
            }
            
            if (!password) {
                showAuthError('Please enter a password');
                document.getElementById('registerPassword').focus();
                return false;
            }
            
            if (password.length < 6) {
                showAuthError('Password must be at least 6 characters long');
                document.getElementById('registerPassword').focus();
                return false;
            }
            
            if (password !== confirmPassword) {
                showAuthError('Passwords do not match');
                document.getElementById('registerPasswordConfirm').focus();
                return false;
            }
            
            return true;
        }
        
        function togglePasswordVisibility(inputId) {
            const input = document.getElementById(inputId);
            const toggle = document.getElementById(inputId + 'Toggle');
            
            if (input.type === 'password') {
                input.type = 'text';
                toggle.textContent = '🙈';
            } else {
                input.type = 'password';
                toggle.textContent = '👁️';
            }
        }
        
        function setLoginLoading(loading) {
            const button = document.getElementById('loginBtn');
            const text = document.getElementById('loginBtnText');
            
            if (loading) {
                button.classList.add('loading');
                button.disabled = true;
                text.textContent = 'Signing In...';
            } else {
                button.classList.remove('loading');
                button.disabled = false;
                text.textContent = '🔐 Sign In';
            }
        }
        
        function setRegisterLoading(loading) {
            const button = document.getElementById('registerBtn');
            const text = document.getElementById('registerBtnText');
            
            if (loading) {
                button.classList.add('loading');
                button.disabled = true;
                text.textContent = 'Creating Account...';
            } else {
                button.classList.remove('loading');
                button.disabled = false;
                text.textContent = '📝 Create Account';
            }
        }
        
        function showAuthMessage(message, type = 'info') {
            const container = document.getElementById('authMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `auth-message ${type}`;
            messageDiv.textContent = message;
            
            // Clear existing messages
            container.innerHTML = '';
            container.appendChild(messageDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }
        
        function showAuthSuccess(message) {
            showAuthMessage(message, 'success');
        }
        
        function showAuthError(message) {
            showAuthMessage(message, 'error');
        }
        
        function showAuthInfo(message) {
            showAuthMessage(message, 'info');
        }
        
        function clearAuthMessages() {
            const container = document.getElementById('authMessages');
            if (container) {
                container.innerHTML = '';
            }
        }
        
        function clearStoredAuth() {
            localStorage.removeItem('authToken');
            localStorage.removeItem('userData');
        }
        
        // Add keyboard event listeners for auth forms
        document.addEventListener('DOMContentLoaded', function() {
            // Login form enter key
            const loginForm = document.getElementById('loginForm');
            if (loginForm) {
                loginForm.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        performLogin();
                    }
                });
            }
            
            // Register form enter key
            const registerForm = document.getElementById('registerForm');
            if (registerForm) {
                registerForm.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        performRegistration();
                    }
                });
            }
        });
        
        function showSuccess(message) {
            console.log('Success:', message);
            // Could implement toast notifications here
        }
        
        function showError(message) {
            console.error('Error:', message);
            // Could implement toast notifications here
        }
        
        // ===== MAIN INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize all systems when DOM is ready
            if (isMobileDevice()) {
                setupDeviceOrientation();
                optimizeForMobile();
                integrateHapticFeedback();
            }
            
            // Initialize PWA and offline support
            initializePWA();
            initializeOfflineSupport();
            
            // Initialize multiplayer system
            multiplayerSystem = new OnlineMultiplayerSystem();
            
            console.log('Enhanced Pong: All systems initialized');
        });
        
    </script>
</body>
</html>