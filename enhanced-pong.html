<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Enhanced Pong game with AI personalities, multiple game modes, particle effects, and sound">
    <meta name="keywords" content="pong, enhanced, game, ai, multiplayer, sound, effects">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2a5298">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Enhanced Pong">
    
    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="../icons/icon-128x128.png">
    <link rel="apple-touch-icon" href="../icons/icon-192x192.png">
    <link rel="manifest" href="../manifest.json">
    
    <title>Enhanced Pong Game - Ultimate Edition</title>
    
    <style>
        :root {
            --primary-color: #4ecdc4;
            --secondary-color: #ff6b6b;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            text-align: center;
        }

        #gameCanvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: #000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            font-family: Arial, sans-serif;
        }

        .menu-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 15px;
            color: white;
            pointer-events: auto;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 30px rgba(78,205,196,0.5);
            backdrop-filter: blur(10px);
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            word-wrap: break-word;
        }

        .menu-btn {
            background: linear-gradient(45deg, var(--primary-color), #44a08d);
            border: none;
            color: white;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            min-width: 140px;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(78,205,196,0.4);
        }

        .menu-btn.secondary {
            background: linear-gradient(45deg, #666, #444);
        }

        .menu-btn.secondary:hover {
            box-shadow: 0 6px 12px rgba(102,102,102,0.4);
        }

        .game-modes {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 15px 0;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            text-align: left;
        }

        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .setting-item label {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-item input[type="range"] {
            width: 120px;
        }

        .setting-item select {
            padding: 5px;
            border-radius: 5px;
            min-width: 120px;
        }

        #inGameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: white;
            font-size: 16px;
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        .ui-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ui-controls {
            pointer-events: auto;
        }

        .ui-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 5px;
            font-size: 12px;
        }

        .ui-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            text-align: left;
            margin: 20px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .stats-grid p {
            margin: 5px 0;
            font-size: 14px;
            word-break: break-word;
        }
        
        .stats-grid h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        .theme-neon { background: linear-gradient(135deg, #1e3c72, #2a5298); }
        .theme-retro { background: linear-gradient(135deg, #2d1b69, #11998e); }
        .theme-classic { background: linear-gradient(135deg, #000000, #434343); }
        .theme-cyberpunk { background: linear-gradient(135deg, #0f0f0f, #1a0033); }
        .theme-synthwave { background: linear-gradient(135deg, #2d1b4e, #ff006e, #8338ec); }
        .theme-ocean { background: linear-gradient(135deg, #0f3460, #16537e, #005c98); }
        .theme-forest { background: linear-gradient(135deg, #0f2027, #203a43, #2c5530); }
        .theme-sunset { background: linear-gradient(135deg, #f2994a, #f2c94c, #eb5757); }
        .theme-galaxy { background: linear-gradient(135deg, #1a0033, #330066, #660099); }
        .theme-volcanic { background: linear-gradient(135deg, #1a0000, #cc0000, #ff3300); }
        .theme-arctic { background: linear-gradient(135deg, #e6f7ff, #b3e5fc, #81d4fa); color: #000000; }
        .theme-matrix { background: linear-gradient(135deg, #000000, #003300, #006600); }
        .theme-crimson { background: linear-gradient(135deg, #330000, #660000, #990000); }
        .theme-highcontrast { background: linear-gradient(135deg, #ffffff, #f0f0f0); color: #000000; }
        .theme-protanopia { background: linear-gradient(135deg, #0066cc, #004499); }
        .theme-deuteranopia { background: linear-gradient(135deg, #cc6600, #994400); }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <div id="gameOverlay">
            <!-- Main Menu -->
            <div id="gameMenu" class="menu-panel">
                <h2 style="color: var(--primary-color); margin-bottom: 20px; font-size: 2.2em;">🏓 ENHANCED PONG</h2>
                
                <div class="game-modes">
                    <button class="menu-btn" onclick="startGame('classic')">🎮 Classic</button>
                    <button class="menu-btn" onclick="startGame('speedball')">⚡ Speedball</button>
                    <button class="menu-btn" onclick="startGame('survival')">💀 Survival</button>
                    <button class="menu-btn" onclick="startGame('tournament')">🏆 Tournament</button>
                    <button class="menu-btn" onclick="startGame('practice')">🎯 Practice</button>
                    <button class="menu-btn" onclick="startGame('multiplayer')">👥 Multiplayer</button>
                </div>
                
                <div style="margin: 20px 0;">
                    <label>AI Difficulty:</label>
                    <select id="difficultySelect" onchange="changeDifficulty(this.value)" style="width: 200px; padding: 8px; margin: 5px;">
                        <option value="easy">😊 Easy</option>
                        <option value="medium" selected>😐 Medium</option>
                        <option value="hard">😈 Hard</option>
                    </select>
                    
                    <br><label>AI Personality:</label>
                    <select id="personalitySelect" onchange="changePersonality(this.value)" style="width: 200px; padding: 8px; margin: 5px;">
                        <option value="balanced" selected>⚖️ Balanced</option>
                        <option value="defensive">🛡️ Defensive</option>
                        <option value="aggressive">⚔️ Aggressive</option>
                        <option value="perfect">🎯 Perfect</option>
                        <option value="unpredictable">🎲 Unpredictable</option>
                        <option value="trickster">🃏 Trickster</option>
                        <option value="copycat">🪞 Copycat</option>
                        <option value="adaptive">🧠 Adaptive</option>
                    </select>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button class="menu-btn secondary" onclick="showPanel('settings')">⚙️ Settings</button>
                    <button class="menu-btn secondary" onclick="showPanel('stats')">📊 Stats</button>
                    <button class="menu-btn secondary" onclick="showPanel('help')">❓ Help</button>
                    <button class="menu-btn secondary" onclick="showPanel('about')">ℹ️ About</button>
                </div>
            </div>

            <!-- Settings Panel -->
            <div id="settingsPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">⚙️ Settings</h2>
                
                <div class="settings-grid">
                    <div class="setting-item">
                        <label>🔊 Volume: <span id="volumeValue">70%</span></label>
                        <input type="range" id="volumeSlider" min="0" max="100" value="70" oninput="updateVolume(this.value)">
                    </div>
                    
                    <div class="setting-item">
                        <label>🎨 Theme:</label>
                        <select id="themeSelect" onchange="changeTheme(this.value)">
                            <option value="neon" selected>🌈 Neon</option>
                            <option value="retro">👾 Retro</option>
                            <option value="classic">⚫ Classic</option>
                            <option value="cyberpunk">🔮 Cyberpunk</option>
                            <option value="synthwave">🌆 Synthwave</option>
                            <option value="ocean">🌊 Ocean Depths</option>
                            <option value="forest">🌲 Forest Night</option>
                            <option value="sunset">🌅 Sunset Vibes</option>
                            <option value="galaxy">🌌 Galaxy</option>
                            <option value="volcanic">🌋 Volcanic</option>
                            <option value="arctic">❄️ Arctic Ice</option>
                            <option value="matrix">🟢 Matrix Green</option>
                            <option value="crimson">🔥 Crimson Fire</option>
                            <option value="highcontrast">⬜ High Contrast</option>
                            <option value="protanopia">🔴 Protanopia Friendly</option>
                            <option value="deuteranopia">🟠 Deuteranopia Friendly</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="particlesCheck" checked onchange="toggleParticles(this.checked)"> ✨ Particles</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="shakeCheck" checked onchange="toggleScreenShake(this.checked)"> 📳 Screen Shake</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="trailCheck" checked onchange="toggleBallTrail(this.checked)"> 🔥 Ball Trail</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="muteCheck" onchange="toggleMute(this.checked)"> 🔇 Mute</label>
                    </div>
                    
                    <div class="setting-item">
                        <label><input type="checkbox" id="backgroundCheck" checked onchange="toggleBackgroundEffects(this.checked)"> 🌌 Background Effects</label>
                    </div>
                    
                    <div class="setting-item">
                        <label>🎭 Background Type:</label>
                        <select id="backgroundTypeSelect" onchange="changeBackgroundType(this.value)">
                            <option value="particles" selected>✨ Floating Particles</option>
                            <option value="waves">🌊 Animated Waves</option>
                            <option value="geometric">🔷 Geometric Patterns</option>
                            <option value="starfield">⭐ Starfield</option>
                            <option value="pulsing">💫 Pulsing Gradient</option>
                            <option value="matrix">🟢 Matrix Rain</option>
                            <option value="plasma">🌈 Plasma Field</option>
                            <option value="neural">🧠 Neural Network</option>
                            <option value="galaxy">🌌 Spiral Galaxy</option>
                            <option value="lightning">⚡ Lightning Storm</option>
                            <option value="aurora">🌟 Aurora Borealis</option>
                            <option value="circuit">🔌 Circuit Board</option>
                            <option value="honeycomb">🍯 Honeycomb Grid</option>
                            <option value="ripple">💧 Water Ripples</option>
                            <option value="storm">⛈️ Lightning Storm</option>
                        </select>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                    <button class="menu-btn" onclick="saveSettings()">💾 Save</button>
                    <button class="menu-btn secondary" onclick="clearGameCache()">🗑️ Clear Cache</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back</button>
                </div>
            </div>

            <!-- Stats Panel -->
            <div id="statsPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">📊 Statistics</h2>
                <div id="statsContent"></div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="menu-btn" onclick="showPanel('heatmap')">🔥 Heat Maps</button>
                    <button class="menu-btn" onclick="showPanel('mlstats')">🧠 ML AI Stats</button>
                    <button class="menu-btn secondary" onclick="clearStats()">🗑️ Clear</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back</button>
                </div>
            </div>
            
            <!-- Heat Map Panel -->
            <div id="heatmapPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">🔥 Heat Map Visualization</h2>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <label>Heat Map Type:</label>
                    <select id="heatmapTypeSelect" onchange="updateHeatMap()" style="padding: 8px; margin: 10px;">
                        <option value="playerHits">🏓 Player Paddle Hits</option>
                        <option value="aiHits">🤖 AI Paddle Hits</option>
                        <option value="ballTrajectory">⚽ Ball Trajectory</option>
                        <option value="playerMovement">🕹️ Player Movement</option>
                        <option value="combined">🌈 Combined View</option>
                    </select>
                </div>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <canvas id="heatmapCanvas" width="400" height="200" style="border: 2px solid var(--primary-color); border-radius: 8px; background: #000;"></canvas>
                </div>
                
                <div style="font-size: 12px; text-align: center; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                        <span>🔵 Low Intensity</span>
                        <div style="width: 100px; height: 8px; background: linear-gradient(90deg, blue, cyan, green, yellow, orange, red); border-radius: 4px;"></div>
                        <span>🔴 High Intensity</span>
                    </div>
                </div>
                
                <div id="heatmapStats" style="font-size: 14px; text-align: left; margin-bottom: 15px;"></div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="menu-btn secondary" onclick="clearHeatMapData()">🗑️ Clear Heat Data</button>
                    <button class="menu-btn secondary" onclick="showPanel('stats')">🔙 Back</button>
                </div>
            </div>

            <!-- ML AI Stats Panel -->
            <div id="mlstatsPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">🧠 Machine Learning AI Statistics</h2>
                <div id="mlstatsContent"></div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="menu-btn secondary" onclick="resetMLAI()">🗑️ Reset ML AI</button>
                    <button class="menu-btn secondary" onclick="showPanel('stats')">🔙 Back</button>
                </div>
            </div>
            
            <!-- Help Panel -->
            <div id="helpPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">❓ Help</h2>
                <div style="text-align: left; font-size: 14px;">
                    <h3>🎮 Controls</h3>
                    <p>• <strong>Mouse/Touch:</strong> Move paddle up/down</p>
                    <p>• <strong>Multiplayer:</strong> W/S vs Arrow Keys</p>
                    
                    <h3>🎯 Game Modes</h3>
                    <p>• <strong>Classic:</strong> Traditional Pong</p>
                    <p>• <strong>Speedball:</strong> Increasing speed</p>
                    <p>• <strong>Survival:</strong> Limited lives</p>
                    <p>• <strong>Tournament:</strong> Best of 3</p>
                    <p>• <strong>Practice:</strong> No scoring</p>
                    <p>• <strong>Multiplayer:</strong> Two players</p>
                    
                    <h3>🤖 AI Personalities</h3>
                    <p>• <strong>Balanced:</strong> Standard AI behavior</p>
                    <p>• <strong>Defensive:</strong> Cautious, center-focused play</p>
                    <p>• <strong>Aggressive:</strong> Fast & predictive attacks</p>
                    <p>• <strong>Perfect:</strong> Near-perfect ball tracking</p>
                    <p>• <strong>Unpredictable:</strong> Random movement patterns</p>
                    <p>• <strong>Trickster:</strong> Uses fake movements to confuse</p>
                    <p>• <strong>Copycat:</strong> Mimics your play style</p>
                    <p>• <strong>Adaptive:</strong> Learns and adapts to you</p>
                </div>
                <button class="menu-btn secondary" onclick="showPanel('menu')" style="margin-top: 15px;">🔙 Back</button>
            </div>
            
            <!-- About Panel -->
            <div id="aboutPanel" class="menu-panel" style="display: none;">
                <h2 style="color: var(--primary-color); margin-bottom: 20px;">ℹ️ About Enhanced Pong</h2>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <h3 style="color: var(--secondary-color); margin-bottom: 5px;">🎮 Enhanced Pong - Ultimate Edition</h3>
                    <p style="margin: 5px 0; color: #aaa;">Version 1.0.0</p>
                    <p style="margin: 5px 0; font-weight: bold;">Created by <span style="color: var(--primary-color);">ShadowHarvy</span></p>
                </div>
                
                <div style="text-align: left; font-size: 13px; margin-bottom: 20px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h4 style="color: var(--primary-color); margin-top: 0;">🚀 What Makes This Special</h4>
                        <p>• <strong>8 AI Personalities</strong> including machine learning adaptive AI</p>
                        <p>• <strong>Advanced Analytics</strong> with heat maps and performance tracking</p>
                        <p>• <strong>14 Achievements</strong> to unlock and master</p>
                        <p>• <strong>16 Visual Themes</strong> including accessibility options</p>
                        <p>• <strong>15 Background Effects</strong> from Matrix to Lightning Storm</p>
                        <p>• <strong>6 Game Modes</strong> for varied gameplay experiences</p>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h4 style="color: var(--secondary-color); margin-top: 0;">🗺️ Development Roadmap</h4>
                        <p><strong>Next (v1.1.0):</strong> 📊 Analytics Dashboard with Charts</p>
                        <p><strong>v1.2.0:</strong> 🏆 Enhanced Tournament Mode & Custom AI Training</p>
                        <p><strong>v1.3.0:</strong> 📱 Mobile Optimization & Accessibility</p>
                        <p><strong>v1.4.0:</strong> 🌐 Online Multiplayer & Replay System</p>
                        <p><strong>v1.5.0:</strong> 🎆 Advanced Features & Customization</p>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                        <h4 style="color: var(--primary-color); margin-top: 0;">👨‍💻 About the Developer</h4>
                        <p><strong>ShadowHarvy</strong> is a backend developer with a passion for security and a growing interest in game development. This project represents an exploration into frontend technologies and AI-driven gameplay mechanics.</p>
                        <p style="margin-top: 10px;"><strong>Background:</strong> 🖥️ Backend Development • 🔒 Security Enthusiast • 🎮 Aspiring Game Developer</p>
                        <p><strong>Platform:</strong> Linux (CachyOS) • Multi-browser support</p>
                        <p><strong>Tech Stack:</strong> HTML5 Canvas, JavaScript ES6+, Web Audio API, Machine Learning</p>
                        <p style="margin-top: 10px; font-style: italic;">"Bridging backend expertise with creative game development!"</p>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="menu-btn secondary" onclick="showPanel('help')">❓ Help</button>
                    <button class="menu-btn secondary" onclick="showPanel('menu')">🔙 Back</button>
                </div>
            </div>

            <!-- In-Game UI -->
            <div id="inGameUI">
                <div class="ui-top">
                    <div>
                        <span>Lives: <span id="livesCount">3</span></span>
                        <span style="margin-left: 20px;">Rally: <span id="rallyCount">0</span></span>
                    </div>
                    <div id="gameModeDisplay" style="font-weight: bold;"></div>
                    <div class="ui-controls">
                        <button class="ui-btn" onclick="pauseGame()">⏸️ Pause</button>
                        <button class="ui-btn" onclick="showPanel('menu'); gameEngine.gameState = 'menu';">📋 Menu</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== AUDIO SYSTEM =====
        class AudioSystem {
            constructor() {
                this.audioContext = null;
                this.muted = false;
                this.volume = 0.7;
                this.initAudio();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Audio not supported');
                }
            }
            
            beep(freq, duration, type = 'sine') {
                if (!this.audioContext || this.muted) return;
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                
                osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                osc.type = type;
                
                gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + duration);
            }
            
            play(type) {
                if (!this.audioContext || this.muted) return;
                
                switch(type) {
                    case 'paddleHit': this.beep(220, 0.1, 'square'); break;
                    case 'wallBounce': this.beep(330, 0.08, 'sine'); break;
                    case 'score': this.scoreSound(); break;
                    case 'win': this.winSound(); break;
                    case 'lose': this.loseSound(); break;
                    case 'menuClick': this.beep(150, 0.05, 'sine'); break;
                    case 'gameStart': this.startSound(); break;
                }
            }
            
            scoreSound() {
                [261.63, 329.63, 392.00].forEach((freq, i) => {
                    setTimeout(() => this.beep(freq, 0.15, 'sine'), i * 100);
                });
            }
            
            winSound() {
                [261.63, 329.63, 392.00, 523.25].forEach((freq, i) => {
                    setTimeout(() => this.beep(freq, 0.3, 'square'), i * 150);
                });
            }
            
            loseSound() {
                [392.00, 329.63, 261.63].forEach((freq, i) => {
                    setTimeout(() => this.beep(freq, 0.4, 'sawtooth'), i * 200);
                });
            }
            
            startSound() {
                setTimeout(() => this.beep(440, 0.1, 'square'), 0);
                setTimeout(() => this.beep(554, 0.1, 'square'), 100);
                setTimeout(() => this.beep(659, 0.2, 'square'), 200);
            }
        }

        // ===== BACKGROUND EFFECTS SYSTEM =====
        class BackgroundEffect {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.enabled = true;
                this.currentEffect = 'particles'; // particles, waves, geometric, starfield, pulsing, matrix, plasma, neural, galaxy, lightning, aurora, circuit, honeycomb, ripple, storm
                this.time = 0;
                this.intensity = 1; // 0-2, affects animation speed and density
                this.backgroundParticles = [];
                this.matrixColumns = [];
                this.plasmaData = [];
                this.neuralNodes = [];
                this.galaxyStars = [];
                this.lightningBranches = [];
                this.circuitPaths = [];
                this.hexagons = [];
                this.ripples = [];
                this.stormClouds = [];
                this.lightningBolts = [];
                this.rainDrops = [];
                this.initBackgroundParticles();
                this.initMatrixRain();
                this.initNeuralNetwork();
                this.initGalaxy();
                this.initCircuitBoard();
                this.initHoneycomb();
                this.initStorm();
            }
            
            initBackgroundParticles() {
                // Create floating background particles
                for (let i = 0; i < 25; i++) {
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20,
                        size: 1 + Math.random() * 2,
                        alpha: 0.1 + Math.random() * 0.2,
                        hue: Math.random() * 360
                    });
                }
            }
            
            initMatrixRain() {
                const columns = Math.floor(this.canvas.width / 20);
                for (let i = 0; i < columns; i++) {
                    this.matrixColumns.push({
                        x: i * 20,
                        y: Math.random() * this.canvas.height,
                        speed: 2 + Math.random() * 5,
                        chars: '01'.split(''),
                        currentChar: 0
                    });
                }
            }
            
            initNeuralNetwork() {
                for (let i = 0; i < 15; i++) {
                    this.neuralNodes.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        connections: [],
                        activity: Math.random()
                    });
                }
                // Create connections between nodes
                this.neuralNodes.forEach((node, i) => {
                    for (let j = i + 1; j < this.neuralNodes.length; j++) {
                        const other = this.neuralNodes[j];
                        const distance = Math.sqrt((node.x - other.x) ** 2 + (node.y - other.y) ** 2);
                        if (distance < 150 && Math.random() > 0.7) {
                            node.connections.push(j);
                        }
                    }
                });
            }
            
            initGalaxy() {
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * Math.min(this.canvas.width, this.canvas.height) / 3;
                    this.galaxyStars.push({
                        angle: angle,
                        radius: radius,
                        speed: 0.5 + Math.random(),
                        size: 0.5 + Math.random() * 2,
                        centerX: this.canvas.width / 2,
                        centerY: this.canvas.height / 2
                    });
                }
            }
            
            initCircuitBoard() {
                const gridSize = 40;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    for (let y = 0; y < this.canvas.height; y += gridSize) {
                        if (Math.random() > 0.7) {
                            this.circuitPaths.push({
                                x: x,
                                y: y,
                                width: gridSize * (0.5 + Math.random() * 2),
                                height: gridSize * (0.5 + Math.random() * 2),
                                type: Math.random() > 0.5 ? 'horizontal' : 'vertical',
                                pulse: Math.random() * Math.PI * 2
                            });
                        }
                    }
                }
            }
            
            initHoneycomb() {
                const hexSize = 30;
                const hexWidth = hexSize * Math.sqrt(3);
                const hexHeight = hexSize * 2;
                
                for (let row = 0; row < this.canvas.height / hexHeight + 2; row++) {
                    for (let col = 0; col < this.canvas.width / hexWidth + 2; col++) {
                        const x = col * hexWidth + (row % 2) * hexWidth / 2;
                        const y = row * hexHeight * 0.75;
                        
                        this.hexagons.push({
                            x: x,
                            y: y,
                            size: hexSize,
                            alpha: 0.1 + Math.random() * 0.2,
                            pulse: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
            
            initStorm() {
                // Create storm clouds
                for (let i = 0; i < 5; i++) {
                    this.stormClouds.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * (this.canvas.height * 0.3),
                        width: 80 + Math.random() * 120,
                        height: 40 + Math.random() * 60,
                        darkness: 0.3 + Math.random() * 0.4,
                        drift: (Math.random() - 0.5) * 20
                    });
                }
                
                // Initialize rain drops
                for (let i = 0; i < 50; i++) {
                    this.rainDrops.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        speed: 200 + Math.random() * 300,
                        length: 5 + Math.random() * 15,
                        opacity: 0.3 + Math.random() * 0.4
                    });
                }
            }
            
            update(dt) {
                if (!this.enabled) return;
                this.time += dt;
                
                // Update background particles
                this.backgroundParticles.forEach(particle => {
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;
                    
                    // Wrap around screen
                    if (particle.x < -10) particle.x = this.canvas.width + 10;
                    if (particle.x > this.canvas.width + 10) particle.x = -10;
                    if (particle.y < -10) particle.y = this.canvas.height + 10;
                    if (particle.y > this.canvas.height + 10) particle.y = -10;
                });
                
                // Update matrix rain
                this.matrixColumns.forEach(col => {
                    col.y += col.speed * 60 * dt;
                    if (col.y > this.canvas.height) {
                        col.y = -20;
                        col.x = Math.floor(Math.random() * (this.canvas.width / 20)) * 20;
                    }
                });
                
                // Update neural network activity
                this.neuralNodes.forEach(node => {
                    node.activity += (Math.random() - 0.5) * dt;
                    node.activity = Math.max(0.1, Math.min(1, node.activity));
                });
                
                // Update galaxy rotation
                this.galaxyStars.forEach(star => {
                    star.angle += star.speed * dt * 0.2;
                });
                
                // Update circuit board pulses
                this.circuitPaths.forEach(path => {
                    path.pulse += dt * 2;
                });
                
                // Update hexagon pulses
                this.hexagons.forEach(hex => {
                    hex.pulse += dt * (0.5 + Math.random());
                });
                
                // Update storm elements
                this.updateStormElements(dt);
            }
            
            draw() {
                if (!this.enabled) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.3;
                
                switch (this.currentEffect) {
                    case 'particles': this.drawFloatingParticles(); break;
                    case 'waves': this.drawWaves(); break;
                    case 'geometric': this.drawGeometric(); break;
                    case 'starfield': this.drawStarfield(); break;
                    case 'pulsing': this.drawPulsingGradient(); break;
                    case 'matrix': this.drawMatrix(); break;
                    case 'plasma': this.drawPlasma(); break;
                    case 'neural': this.drawNeuralNetwork(); break;
                    case 'galaxy': this.drawGalaxy(); break;
                    case 'lightning': this.drawLightning(); break;
                    case 'aurora': this.drawAurora(); break;
                    case 'circuit': this.drawCircuitBoard(); break;
                    case 'honeycomb': this.drawHoneycomb(); break;
                    case 'ripple': this.drawRipple(); break;
                    case 'storm': this.drawStorm(); break;
                }
                
                this.ctx.restore();
            }
            
            drawFloatingParticles() {
                this.backgroundParticles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.alpha * this.intensity;
                    this.ctx.fillStyle = `hsl(${particle.hue}, 60%, 70%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
            
            drawWaves() {
                const waveHeight = 30;
                const waveFreq = 0.005;
                const waveSpeed = 2;
                
                this.ctx.strokeStyle = `rgba(100, 200, 255, ${0.2 * this.intensity})`;
                this.ctx.lineWidth = 2;
                
                for (let wave = 0; wave < 3; wave++) {
                    this.ctx.beginPath();
                    for (let x = 0; x < this.canvas.width; x += 5) {
                        const y = this.canvas.height / 2 + 
                                 Math.sin((x * waveFreq) + (this.time * waveSpeed) + (wave * 2)) * waveHeight +
                                 Math.sin((x * waveFreq * 2) + (this.time * waveSpeed * 0.7) + (wave * 1.5)) * waveHeight * 0.5;
                        if (x === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                }
            }
            
            drawGeometric() {
                const time = this.time * 0.5;
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * this.intensity})`;
                this.ctx.lineWidth = 1;
                
                // Draw rotating geometric patterns
                for (let i = 0; i < 8; i++) {
                    const centerX = (i % 4) * (this.canvas.width / 3) + this.canvas.width / 6;
                    const centerY = Math.floor(i / 4) * (this.canvas.height / 2) + this.canvas.height / 4;
                    const rotation = time + (i * Math.PI / 4);
                    const size = 20 + Math.sin(time + i) * 10;
                    
                    this.ctx.save();
                    this.ctx.translate(centerX, centerY);
                    this.ctx.rotate(rotation);
                    
                    this.ctx.beginPath();
                    for (let side = 0; side < 6; side++) {
                        const angle = (side / 6) * Math.PI * 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (side === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.closePath();
                    this.ctx.stroke();
                    this.ctx.restore();
                }
            }
            
            drawStarfield() {
                // Create twinkling stars
                for (let i = 0; i < 50; i++) {
                    const x = (i * 73) % this.canvas.width;
                    const y = (i * 37) % this.canvas.height;
                    const twinkle = Math.sin(this.time * 3 + i) * 0.5 + 0.5;
                    const alpha = 0.1 + (twinkle * 0.3) * this.intensity;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(x, y, 1, 1);
                    
                    // Add cross sparkle to brighter stars
                    if (twinkle > 0.7) {
                        this.ctx.fillRect(x - 2, y, 5, 1);
                        this.ctx.fillRect(x, y - 2, 1, 5);
                    }
                    this.ctx.restore();
                }
            }
            
            drawPulsingGradient() {
                const pulse = Math.sin(this.time * 2) * 0.3 + 0.7;
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.width * pulse
                );
                
                gradient.addColorStop(0, `rgba(100, 150, 255, ${0.1 * this.intensity})`);
                gradient.addColorStop(0.5, `rgba(150, 100, 255, ${0.05 * this.intensity})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawMatrix() {
                this.ctx.fillStyle = `rgba(0, 255, 0, ${0.8 * this.intensity})`;
                this.ctx.font = '14px monospace';
                
                this.matrixColumns.forEach(col => {
                    const char = col.chars[Math.floor(this.time * 2) % col.chars.length];
                    this.ctx.fillText(char, col.x, col.y);
                });
            }
            
            drawPlasma() {
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let x = 0; x < this.canvas.width; x += 4) {
                    for (let y = 0; y < this.canvas.height; y += 4) {
                        const index = (y * this.canvas.width + x) * 4;
                        
                        const value = Math.sin(x * 0.01 + this.time) + 
                                    Math.sin(y * 0.01 + this.time * 0.7) + 
                                    Math.sin((x + y) * 0.01 + this.time * 0.5);
                        
                        const color = Math.floor((value + 3) * 42.5) % 256;
                        
                        data[index] = color * 0.3;     // Red
                        data[index + 1] = color * 0.6; // Green  
                        data[index + 2] = color;       // Blue
                        data[index + 3] = 50 * this.intensity; // Alpha
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }
            
            drawNeuralNetwork() {
                // Draw connections
                this.ctx.strokeStyle = `rgba(100, 255, 200, ${0.3 * this.intensity})`;
                this.ctx.lineWidth = 1;
                
                this.neuralNodes.forEach((node, i) => {
                    node.connections.forEach(connectionIndex => {
                        const connected = this.neuralNodes[connectionIndex];
                        const activity = (node.activity + connected.activity) / 2;
                        
                        this.ctx.globalAlpha = activity * this.intensity * 0.5;
                        this.ctx.beginPath();
                        this.ctx.moveTo(node.x, node.y);
                        this.ctx.lineTo(connected.x, connected.y);
                        this.ctx.stroke();
                    });
                });
                
                // Draw nodes
                this.neuralNodes.forEach(node => {
                    const pulse = Math.sin(this.time * 3 + node.x * 0.01) * 0.5 + 0.5;
                    this.ctx.globalAlpha = (node.activity * pulse + 0.3) * this.intensity;
                    this.ctx.fillStyle = `hsl(${180 + pulse * 60}, 70%, 60%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 3 + pulse * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawGalaxy() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.galaxyStars.forEach(star => {
                    const x = centerX + Math.cos(star.angle) * star.radius;
                    const y = centerY + Math.sin(star.angle) * star.radius;
                    
                    const distance = star.radius / (Math.min(this.canvas.width, this.canvas.height) / 3);
                    const alpha = (1 - distance) * 0.4 * this.intensity;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = `hsl(${240 + distance * 120}, 80%, 70%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
            
            drawLightning() {
                this.ctx.strokeStyle = `rgba(200, 200, 255, ${0.6 * this.intensity})`;
                this.ctx.lineWidth = 2;
                this.ctx.lineCap = 'round';
                
                // Generate random lightning bolts
                if (Math.random() < 0.05 * this.intensity) {
                    const startX = Math.random() * this.canvas.width;
                    const startY = 0;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    
                    let x = startX;
                    let y = startY;
                    
                    while (y < this.canvas.height) {
                        x += (Math.random() - 0.5) * 40;
                        y += Math.random() * 30 + 10;
                        this.ctx.lineTo(x, y);
                    }
                    
                    this.ctx.stroke();
                }
            }
            
            drawAurora() {
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                
                const time = this.time * 0.5;
                const wave1 = Math.sin(time) * 0.3 + 0.7;
                const wave2 = Math.sin(time * 0.7) * 0.3 + 0.7;
                
                gradient.addColorStop(0, `rgba(0, 255, 150, ${0.1 * wave1 * this.intensity})`);
                gradient.addColorStop(0.5, `rgba(150, 0, 255, ${0.15 * wave2 * this.intensity})`);
                gradient.addColorStop(1, `rgba(0, 150, 255, ${0.1 * wave1 * this.intensity})`);
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Add flowing streaks
                this.ctx.strokeStyle = `rgba(100, 255, 200, ${0.3 * this.intensity})`;
                this.ctx.lineWidth = 3;
                
                for (let i = 0; i < 5; i++) {
                    this.ctx.beginPath();
                    for (let x = 0; x < this.canvas.width; x += 10) {
                        const y = this.canvas.height * 0.3 + 
                                 Math.sin((x * 0.01) + (time * 2) + (i * 1.2)) * 30 + 
                                 Math.sin((x * 0.005) + (time * 1.5) + (i * 0.8)) * 20;
                        if (x === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                }
            }
            
            drawCircuitBoard() {
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.4 * this.intensity})`;
                this.ctx.lineWidth = 2;
                
                this.circuitPaths.forEach(path => {
                    const pulse = Math.sin(this.time * 2 + path.pulse) * 0.5 + 0.5;
                    this.ctx.globalAlpha = pulse * this.intensity * 0.6;
                    
                    this.ctx.beginPath();
                    if (path.type === 'horizontal') {
                        this.ctx.moveTo(path.x, path.y);
                        this.ctx.lineTo(path.x + path.width, path.y);
                    } else {
                        this.ctx.moveTo(path.x, path.y);
                        this.ctx.lineTo(path.x, path.y + path.height);
                    }
                    this.ctx.stroke();
                    
                    // Draw connection nodes
                    this.ctx.fillStyle = `rgba(255, 255, 0, ${pulse * this.intensity})`;
                    this.ctx.beginPath();
                    this.ctx.arc(path.x, path.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawHoneycomb() {
                this.ctx.strokeStyle = `rgba(255, 200, 0, ${0.3 * this.intensity})`;
                this.ctx.lineWidth = 1;
                
                this.hexagons.forEach(hex => {
                    const pulse = Math.sin(this.time + hex.pulse) * 0.3 + 0.7;
                    this.ctx.globalAlpha = hex.alpha * pulse * this.intensity;
                    
                    this.ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = hex.x + Math.cos(angle) * hex.size;
                        const y = hex.y + Math.sin(angle) * hex.size;
                        
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.closePath();
                    this.ctx.stroke();
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawRipple() {
                // Create ripples on game events
                this.ripples.forEach((ripple, index) => {
                    const progress = (this.time - ripple.startTime) / ripple.duration;
                    
                    if (progress >= 1) {
                        this.ripples.splice(index, 1);
                        return;
                    }
                    
                    const radius = progress * ripple.maxRadius;
                    const alpha = (1 - progress) * 0.4 * this.intensity;
                    
                    this.ctx.strokeStyle = `rgba(${ripple.color}, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
                
                // Background subtle ripples
                for (let i = 0; i < 3; i++) {
                    const radius = (Math.sin(this.time * 0.5 + i * 2) * 0.5 + 0.5) * 100;
                    const alpha = 0.1 * this.intensity;
                    
                    this.ctx.strokeStyle = `rgba(100, 150, 255, ${alpha})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            updateStormElements(dt) {
                // Update storm clouds drift
                this.stormClouds.forEach(cloud => {
                    cloud.x += cloud.drift * dt;
                    // Wrap around screen
                    if (cloud.x > this.canvas.width + cloud.width) cloud.x = -cloud.width;
                    if (cloud.x < -cloud.width) cloud.x = this.canvas.width + cloud.width;
                });
                
                // Update rain drops
                this.rainDrops.forEach(drop => {
                    drop.y += drop.speed * dt;
                    if (drop.y > this.canvas.height + drop.length) {
                        drop.y = -drop.length;
                        drop.x = Math.random() * this.canvas.width;
                    }
                });
                
                // Update lightning bolts (they fade over time)
                this.lightningBolts = this.lightningBolts.filter(bolt => {
                    bolt.life -= dt * 5; // Lightning fades quickly
                    bolt.alpha = Math.max(0, bolt.life);
                    return bolt.life > 0;
                });
            }
            
            drawStorm() {
                // Draw storm clouds
                this.stormClouds.forEach(cloud => {
                    const gradient = this.ctx.createRadialGradient(
                        cloud.x + cloud.width/2, cloud.y + cloud.height/2, 0,
                        cloud.x + cloud.width/2, cloud.y + cloud.height/2, cloud.width/2
                    );
                    
                    gradient.addColorStop(0, `rgba(40, 40, 60, ${cloud.darkness * this.intensity})`);
                    gradient.addColorStop(0.7, `rgba(20, 20, 40, ${cloud.darkness * 0.7 * this.intensity})`);
                    gradient.addColorStop(1, 'rgba(20, 20, 40, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.ellipse(cloud.x + cloud.width/2, cloud.y + cloud.height/2, cloud.width/2, cloud.height/2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw rain
                this.ctx.strokeStyle = `rgba(150, 180, 220, ${0.5 * this.intensity})`;
                this.ctx.lineWidth = 1;
                this.rainDrops.forEach(drop => {
                    this.ctx.globalAlpha = drop.opacity * this.intensity;
                    this.ctx.beginPath();
                    this.ctx.moveTo(drop.x, drop.y);
                    this.ctx.lineTo(drop.x - 3, drop.y + drop.length); // Angled rain
                    this.ctx.stroke();
                });
                this.ctx.globalAlpha = 1;
                
                // Draw lightning bolts
                this.lightningBolts.forEach(bolt => {
                    this.ctx.save();
                    this.ctx.globalAlpha = bolt.alpha * this.intensity;
                    this.ctx.strokeStyle = bolt.color;
                    this.ctx.lineWidth = bolt.width;
                    this.ctx.lineCap = 'round';
                    this.ctx.shadowColor = bolt.color;
                    this.ctx.shadowBlur = 15;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(bolt.points[0].x, bolt.points[0].y);
                    bolt.points.slice(1).forEach(point => {
                        this.ctx.lineTo(point.x, point.y);
                    });
                    this.ctx.stroke();
                    this.ctx.restore();
                });
            }
            
            createLightningBolt(startX, startY, endX, endY, intensity = 'normal') {
                const points = [{x: startX, y: startY}];
                const segments = Math.floor(Math.abs(endY - startY) / 20);
                
                for (let i = 1; i < segments; i++) {
                    const progress = i / segments;
                    const x = startX + (endX - startX) * progress + (Math.random() - 0.5) * 60;
                    const y = startY + (endY - startY) * progress;
                    points.push({x, y});
                }
                points.push({x: endX, y: endY});
                
                const bolt = {
                    points: points,
                    life: 1,
                    alpha: 1,
                    color: intensity === 'major' ? '#ffffff' : '#a0c4ff',
                    width: intensity === 'major' ? 4 : 2
                };
                
                this.lightningBolts.push(bolt);
                
                // Add branching for major lightning
                if (intensity === 'major' && points.length > 3) {
                    const branchPoint = points[Math.floor(points.length * 0.6)];
                    const branchEndX = branchPoint.x + (Math.random() - 0.5) * 200;
                    const branchEndY = Math.min(this.canvas.height, branchPoint.y + 50 + Math.random() * 100);
                    this.createLightningBolt(branchPoint.x, branchPoint.y, branchEndX, branchEndY, 'normal');
                }
            }
            
            triggerLightningBounce() {
                if (this.currentEffect !== 'storm') return;
                
                // Light lightning on bounce
                const startX = Math.random() * this.canvas.width;
                const endX = startX + (Math.random() - 0.5) * 100;
                const endY = this.canvas.height * (0.3 + Math.random() * 0.4);
                
                this.createLightningBolt(startX, 0, endX, endY, 'normal');
            }
            
            triggerLightningScore() {
                if (this.currentEffect !== 'storm') return;
                
                // Major lightning on score - multiple bolts
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const startX = Math.random() * this.canvas.width;
                        const endX = startX + (Math.random() - 0.5) * 150;
                        const endY = this.canvas.height * (0.4 + Math.random() * 0.5);
                        
                        this.createLightningBolt(startX, 0, endX, endY, 'major');
                    }, i * 100);
                }
            }
            
            // React to game events
            onBallHit() {
                this.intensity = Math.min(2, this.intensity + 0.3);
                setTimeout(() => {
                    this.intensity = Math.max(0.5, this.intensity - 0.3);
                }, 200);
                
                // Trigger light lightning on bounces
                this.triggerLightningBounce();
            }
            
            onScore() {
                this.intensity = 2;
                setTimeout(() => {
                    this.intensity = 1;
                }, 1000);
                
                // Trigger major lightning on scores
                this.triggerLightningScore();
            }
            
            onPowerUpCollected() {
                this.intensity = 1.5;
                setTimeout(() => {
                    this.intensity = 1;
                }, 500);
                
                // Add ripple effect for ripple background
                if (this.currentEffect === 'ripple') {
                    this.addRipple(Math.random() * this.canvas.width, Math.random() * this.canvas.height, '255, 200, 0', 2);
                }
            }
            
            addRipple(x, y, color = '100, 150, 255', duration = 1.5) {
                this.ripples.push({
                    x: x,
                    y: y,
                    startTime: this.time,
                    duration: duration,
                    maxRadius: 100,
                    color: color
                });
            }
            
            setEffect(effectName) {
                this.currentEffect = effectName;
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
            }
        }

        // ===== PARTICLE SYSTEM =====
        class Particle {
            constructor(x, y, vx, vy, life, color, size, type = 'circle') {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.life = life; this.maxLife = life;
                this.color = color; this.size = size; this.type = type;
                this.gravity = 0; this.alpha = 1; this.rotation = 0; this.rotationSpeed = 0;
            }
            
            update(dt) {
                this.x += this.vx * dt; this.y += this.vy * dt; this.vy += this.gravity * dt;
                this.rotation += this.rotationSpeed * dt; this.life -= dt;
                this.alpha = Math.max(0, this.life / this.maxLife);
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = this.alpha;
                ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                
                if (this.type === 'circle') {
                    ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                }
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor(ctx) { this.ctx = ctx; this.particles = []; this.enabled = true; }
            
            update(dt) {
                if (!this.enabled) return;
                this.particles = this.particles.filter(p => p.update(dt));
            }
            
            draw() {
                if (!this.enabled) return;
                this.particles.forEach(p => p.draw(this.ctx));
            }
            
            addParticle(particle) {
                if (this.enabled && this.particles.length < 500) this.particles.push(particle);
            }
            
            paddleHit(x, y, vx, vy) {
                const colors = ['#4ecdc4', '#44a08d', '#ffffff'];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI/3) * (Math.random()-0.5) + Math.atan2(vy, vx);
                    const speed = 100 + Math.random() * 100;
                    const p = new Particle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed,
                        0.3 + Math.random()*0.2, colors[Math.floor(Math.random()*colors.length)], 2+Math.random()*3);
                    p.gravity = 50; this.addParticle(p);
                }
            }
            
            wallBounce(x, y) {
                const colors = ['#ff6b6b', '#ffa726', '#ffffff'];
                for (let i = 0; i < 4; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 50;
                    this.addParticle(new Particle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed,
                        0.4, colors[Math.floor(Math.random()*colors.length)], 1+Math.random()*2));
                }
            }
            
            scoreEffect(x, y, isPlayer) {
                const colors = isPlayer ? ['#4ecdc4', '#44a08d'] : ['#ff6b6b', '#ee5a52'];
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 80 + Math.random() * 100;
                    const p = new Particle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed-100,
                        1+Math.random()*0.5, colors[Math.floor(Math.random()*colors.length)], 3+Math.random()*4);
                    p.gravity = 100; p.rotationSpeed = (Math.random()-0.5)*10; this.addParticle(p);
                }
            }
            
            winEffect(w, h) {
                const colors = ['#4ecdc4', '#44a08d', '#ffffff', '#ffd54f'];
                for (let i = 0; i < 20; i++) {
                    const p = new Particle(Math.random()*w, -20, (Math.random()-0.5)*100, 100+Math.random()*100,
                        3+Math.random()*2, colors[Math.floor(Math.random()*colors.length)], 4+Math.random()*6);
                    p.gravity = 150; p.rotationSpeed = (Math.random()-0.5)*15; this.addParticle(p);
                }
            }
        }

        // ===== MACHINE LEARNING AI =====
        class MachineLearningAI {
            constructor() {
                this.patterns = {
                    playerMovement: [], // Stores player Y positions over time
                    ballInterceptions: [], // Where player intercepts the ball
                    reactionTimes: [], // Player reaction time patterns
                    defensiveZones: [], // Where player tends to defend
                    aggressiveActions: [], // When player makes aggressive moves
                    weakSpots: [], // Areas where player misses
                    successfulHits: [] // Where player makes successful hits
                };
                
                this.learningModel = {
                    playerTendencies: {
                        favoritePosition: 200, // Default center
                        movementSpeed: 1.0,
                        reactionDelay: 0.3,
                        defensiveRatio: 0.5, // 0 = aggressive, 1 = defensive
                        consistencyLevel: 0.5,
                        predictability: 0.5
                    },
                    adaptations: {
                        targetingBias: 0, // -1 = target weak spots, 1 = avoid strengths
                        speedAdjustment: 1.0,
                        strategyPreference: 'balanced', // balanced, exploit, challenge
                        learningRate: 0.1
                    },
                    confidence: 0.5, // How confident the AI is in its learning
                    gamesAnalyzed: 0
                };
                
                this.minGamesForLearning = 3;
                this.maxPatternSize = 100; // Limit memory usage
            }
            
            // Record player behavior during gameplay
            recordPlayerAction(actionType, data) {
                if (!this.patterns[actionType]) return;
                
                this.patterns[actionType].push({
                    ...data,
                    timestamp: Date.now(),
                    gameNumber: this.learningModel.gamesAnalyzed
                });
                
                // Limit pattern size to prevent memory overflow
                if (this.patterns[actionType].length > this.maxPatternSize) {
                    this.patterns[actionType].shift();
                }
            }
            
            // Analyze patterns after each game
            analyzeGamePatterns(gameStats) {
                this.learningModel.gamesAnalyzed++;
                
                if (this.learningModel.gamesAnalyzed < this.minGamesForLearning) {
                    return; // Need more data
                }
                
                this.analyzeMovementPatterns();
                this.analyzeReactionPatterns();
                this.analyzeDefensivePatterns();
                this.analyzeWeakSpots();
                this.updateConfidence();
                this.adaptStrategy(gameStats);
            }
            
            analyzeMovementPatterns() {
                if (this.patterns.playerMovement.length < 10) return;
                
                const recentMovements = this.patterns.playerMovement.slice(-50);
                const positions = recentMovements.map(m => m.y);
                
                // Calculate favorite position
                this.learningModel.playerTendencies.favoritePosition = 
                    positions.reduce((sum, pos) => sum + pos, 0) / positions.length;
                
                // Calculate movement consistency
                const avgPosition = this.learningModel.playerTendencies.favoritePosition;
                const variance = positions.reduce((sum, pos) => sum + Math.pow(pos - avgPosition, 2), 0) / positions.length;
                this.learningModel.playerTendencies.consistencyLevel = Math.max(0, Math.min(1, 1 - (variance / 10000)));
                
                // Calculate predictability based on movement patterns
                let predictableSequences = 0;
                for (let i = 3; i < positions.length; i++) {
                    const pattern = positions.slice(i-3, i);
                    const prediction = this.predictNextPosition(pattern);
                    if (Math.abs(prediction - positions[i]) < 20) {
                        predictableSequences++;
                    }
                }
                this.learningModel.playerTendencies.predictability = predictableSequences / (positions.length - 3);
            }
            
            analyzeReactionPatterns() {
                if (this.patterns.reactionTimes.length < 5) return;
                
                const recentReactions = this.patterns.reactionTimes.slice(-20);
                const avgReactionTime = recentReactions.reduce((sum, r) => sum + r.time, 0) / recentReactions.length;
                
                this.learningModel.playerTendencies.reactionDelay = avgReactionTime / 1000; // Convert to seconds
                
                // Analyze if player has faster reactions in certain situations
                const urgentReactions = recentReactions.filter(r => r.ballSpeed > 6);
                if (urgentReactions.length > 0) {
                    const urgentAvg = urgentReactions.reduce((sum, r) => sum + r.time, 0) / urgentReactions.length;
                    this.learningModel.playerTendencies.stressResponse = urgentAvg / avgReactionTime;
                }
            }
            
            analyzeDefensivePatterns() {
                if (this.patterns.defensiveZones.length < 5) return;
                
                const recentDefensive = this.patterns.defensiveZones.slice(-30);
                const centerZone = recentDefensive.filter(d => Math.abs(d.y - 200) < 60).length;
                const totalDefensive = recentDefensive.length;
                
                this.learningModel.playerTendencies.defensiveRatio = centerZone / totalDefensive;
            }
            
            analyzeWeakSpots() {
                if (this.patterns.weakSpots.length < 3) return;
                
                const recentMisses = this.patterns.weakSpots.slice(-20);
                const missZones = {};
                
                recentMisses.forEach(miss => {
                    const zone = Math.floor(miss.y / 50); // Divide field into zones
                    missZones[zone] = (missZones[zone] || 0) + 1;
                });
                
                // Find the zone with most misses
                let maxMisses = 0;
                let weakestZone = 4; // Default to center
                for (const zone in missZones) {
                    if (missZones[zone] > maxMisses) {
                        maxMisses = missZones[zone];
                        weakestZone = parseInt(zone);
                    }
                }
                
                this.learningModel.playerTendencies.weakestZone = weakestZone;
            }
            
            updateConfidence() {
                const dataPoints = Object.values(this.patterns).reduce((sum, arr) => sum + arr.length, 0);
                const targetDataPoints = 200; // Ideal amount of data
                
                this.learningModel.confidence = Math.min(1, dataPoints / targetDataPoints);
            }
            
            adaptStrategy(gameStats) {
                const playerWinRate = gameStats.gamesWon / gameStats.gamesPlayed;
                const learningRate = this.learningModel.adaptations.learningRate;
                
                // Adjust strategy based on player performance
                if (playerWinRate > 0.7) {
                    // Player is winning too much, make AI more challenging
                    this.learningModel.adaptations.strategyPreference = 'exploit';
                    this.learningModel.adaptations.targetingBias = Math.min(0.8, 
                        this.learningModel.adaptations.targetingBias + learningRate);
                } else if (playerWinRate < 0.3) {
                    // Player is struggling, make AI less aggressive
                    this.learningModel.adaptations.strategyPreference = 'challenge';
                    this.learningModel.adaptations.targetingBias = Math.max(-0.5, 
                        this.learningModel.adaptations.targetingBias - learningRate);
                } else {
                    // Balanced game, maintain current strategy
                    this.learningModel.adaptations.strategyPreference = 'balanced';
                }
                
                // Adjust speed based on player's reaction time
                if (this.learningModel.playerTendencies.reactionDelay > 0.4) {
                    this.learningModel.adaptations.speedAdjustment = Math.max(0.7, 
                        this.learningModel.adaptations.speedAdjustment - learningRate * 0.5);
                } else if (this.learningModel.playerTendencies.reactionDelay < 0.2) {
                    this.learningModel.adaptations.speedAdjustment = Math.min(1.3, 
                        this.learningModel.adaptations.speedAdjustment + learningRate * 0.5);
                }
            }
            
            // Predict where player will be based on patterns
            predictPlayerPosition(currentY, ballY, ballVy) {
                if (this.learningModel.confidence < 0.3) {
                    return currentY; // Not enough data, return current position
                }
                
                const tendencies = this.learningModel.playerTendencies;
                const adaptations = this.learningModel.adaptations;
                
                // Base prediction on favorite position and ball trajectory
                let predictedY = tendencies.favoritePosition * 0.3 + ballY * 0.7;
                
                // Adjust for player's defensive ratio
                if (tendencies.defensiveRatio > 0.6) {
                    // Defensive player, predict they'll move toward center
                    predictedY = predictedY * 0.7 + 200 * 0.3;
                }
                
                // Factor in reaction delay
                const delayFactor = Math.max(0, 1 - tendencies.reactionDelay * 2);
                predictedY = currentY * (1 - delayFactor) + predictedY * delayFactor;
                
                return Math.max(40, Math.min(360, predictedY));
            }
            
            // Get AI target position based on learning
            getAdaptiveTarget(ballX, ballY, ballVx, ballVy, playerY, aiY) {
                if (this.learningModel.confidence < 0.3) {
                    return ballY; // Default behavior
                }
                
                const tendencies = this.learningModel.playerTendencies;
                const adaptations = this.learningModel.adaptations;
                
                let targetY = ballY;
                
                // Predict where player will be
                const predictedPlayerY = this.predictPlayerPosition(playerY, ballY, ballVy);
                
                switch (adaptations.strategyPreference) {
                    case 'exploit':
                        // Target player's weak spots
                        if (tendencies.weakestZone !== undefined) {
                            const weakSpotY = tendencies.weakestZone * 50 + 25;
                            targetY = weakSpotY * 0.6 + ballY * 0.4;
                        }
                        break;
                        
                    case 'challenge':
                        // Play to player's strengths to provide good gameplay
                        targetY = predictedPlayerY * 0.3 + ballY * 0.7;
                        break;
                        
                    default: // 'balanced'
                        // Mix of challenging and exploiting
                        const exploitFactor = adaptations.targetingBias;
                        if (exploitFactor > 0 && tendencies.weakestZone !== undefined) {
                            const weakSpotY = tendencies.weakestZone * 50 + 25;
                            targetY = weakSpotY * exploitFactor + ballY * (1 - exploitFactor);
                        } else {
                            targetY = predictedPlayerY * 0.2 + ballY * 0.8;
                        }
                }
                
                // Add some unpredictability if player is too predictable
                if (tendencies.predictability > 0.8 && Math.random() < 0.3) {
                    targetY += (Math.random() - 0.5) * 60;
                }
                
                return Math.max(40, Math.min(360, targetY));
            }
            
            // Utility function to predict next position based on pattern
            predictNextPosition(positionHistory) {
                if (positionHistory.length < 2) return positionHistory[positionHistory.length - 1];
                
                // Simple linear prediction
                const last = positionHistory[positionHistory.length - 1];
                const secondLast = positionHistory[positionHistory.length - 2];
                const velocity = last - secondLast;
                
                return last + velocity;
            }
            
            // Get learning statistics for display
            getLearningStats() {
                return {
                    confidence: (this.learningModel.confidence * 100).toFixed(1),
                    gamesAnalyzed: this.learningModel.gamesAnalyzed,
                    strategy: this.learningModel.adaptations.strategyPreference,
                    playerTendencies: {
                        favoritePosition: Math.round(this.learningModel.playerTendencies.favoritePosition),
                        consistency: (this.learningModel.playerTendencies.consistencyLevel * 100).toFixed(1),
                        defensiveRatio: (this.learningModel.playerTendencies.defensiveRatio * 100).toFixed(1),
                        avgReactionTime: (this.learningModel.playerTendencies.reactionDelay * 1000).toFixed(0)
                    },
                    totalDataPoints: Object.values(this.patterns).reduce((sum, arr) => sum + arr.length, 0)
                };
            }
            
            // Save/Load learning data
            saveToStorage() {
                const data = {
                    patterns: this.patterns,
                    learningModel: this.learningModel
                };
                localStorage.setItem('pongMLAI', JSON.stringify(data));
            }
            
            loadFromStorage() {
                const saved = localStorage.getItem('pongMLAI');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.patterns = { ...this.patterns, ...data.patterns };
                        this.learningModel = { ...this.learningModel, ...data.learningModel };
                    } catch (e) {
                        console.warn('Failed to load ML AI data:', e);
                    }
                }
            }
            
            // Reset learning data
            resetLearning() {
                this.patterns = {
                    playerMovement: [],
                    ballInterceptions: [],
                    reactionTimes: [],
                    defensiveZones: [],
                    aggressiveActions: [],
                    weakSpots: [],
                    successfulHits: []
                };
                
                this.learningModel = {
                    playerTendencies: {
                        favoritePosition: 200,
                        movementSpeed: 1.0,
                        reactionDelay: 0.3,
                        defensiveRatio: 0.5,
                        consistencyLevel: 0.5,
                        predictability: 0.5
                    },
                    adaptations: {
                        targetingBias: 0,
                        speedAdjustment: 1.0,
                        strategyPreference: 'balanced',
                        learningRate: 0.1
                    },
                    confidence: 0.5,
                    gamesAnalyzed: 0
                };
                
                this.saveToStorage();
            }
        }
        
        // ===== HEAT MAP VISUALIZER =====
        class HeatMapVisualizer {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.gameWidth = 800;
                this.gameHeight = 400;
                this.heatmapWidth = 400;
                this.heatmapHeight = 200;
                this.scaleX = this.heatmapWidth / this.gameWidth;
                this.scaleY = this.heatmapHeight / this.gameHeight;
                this.gridSize = 10; // Size of each heat map cell
                this.maxIntensity = 0;
            }
            
            initialize(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                }
            }
            
            getIntensityColor(intensity, maxIntensity) {
                if (maxIntensity === 0) return 'rgba(0,0,0,0)';
                
                const normalizedIntensity = intensity / maxIntensity;
                const alpha = Math.min(0.8, normalizedIntensity * 0.8 + 0.2);
                
                // Heat map color progression: Blue -> Cyan -> Green -> Yellow -> Orange -> Red
                if (normalizedIntensity < 0.2) {
                    // Blue to Cyan
                    const ratio = normalizedIntensity / 0.2;
                    return `rgba(${Math.floor(ratio * 0)}, ${Math.floor(ratio * 255)}, 255, ${alpha})`;
                } else if (normalizedIntensity < 0.4) {
                    // Cyan to Green
                    const ratio = (normalizedIntensity - 0.2) / 0.2;
                    return `rgba(0, 255, ${Math.floor(255 - ratio * 255)}, ${alpha})`;
                } else if (normalizedIntensity < 0.6) {
                    // Green to Yellow
                    const ratio = (normalizedIntensity - 0.4) / 0.2;
                    return `rgba(${Math.floor(ratio * 255)}, 255, 0, ${alpha})`;
                } else if (normalizedIntensity < 0.8) {
                    // Yellow to Orange
                    const ratio = (normalizedIntensity - 0.6) / 0.2;
                    return `rgba(255, ${Math.floor(255 - ratio * 128)}, 0, ${alpha})`;
                } else {
                    // Orange to Red
                    const ratio = (normalizedIntensity - 0.8) / 0.2;
                    return `rgba(255, ${Math.floor(127 - ratio * 127)}, 0, ${alpha})`;
                }
            }
            
            drawPlayerHits(analytics) {
                if (!this.ctx || !analytics.heatMap.playerHits.length) return;
                
                this.clearCanvas();
                
                // Create intensity grid
                const grid = this.createIntensityGrid(analytics.heatMap.playerHits);
                this.drawHeatMapGrid(grid);
                
                // Draw game field outline
                this.drawGameField();
                
                return {
                    totalHits: analytics.heatMap.playerHits.length,
                    avgIntensity: this.calculateAverageIntensity(analytics.heatMap.playerHits),
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawAIHits(analytics) {
                if (!this.ctx || !analytics.heatMap.aiHits.length) return;
                
                this.clearCanvas();
                
                const grid = this.createIntensityGrid(analytics.heatMap.aiHits);
                this.drawHeatMapGrid(grid);
                this.drawGameField();
                
                return {
                    totalHits: analytics.heatMap.aiHits.length,
                    avgIntensity: this.calculateAverageIntensity(analytics.heatMap.aiHits),
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawBallTrajectory(analytics) {
                if (!this.ctx || !analytics.heatMap.ballTrajectories.length) return;
                
                this.clearCanvas();
                
                const grid = this.createIntensityGrid(analytics.heatMap.ballTrajectories);
                this.drawHeatMapGrid(grid);
                this.drawGameField();
                
                return {
                    totalSamples: analytics.heatMap.ballTrajectories.length,
                    avgIntensity: this.calculateAverageIntensity(analytics.heatMap.ballTrajectories),
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawPlayerMovement(playerMovementSamples) {
                if (!this.ctx || !playerMovementSamples.length) return;
                
                this.clearCanvas();
                
                // Convert movement samples to heat map format
                const movementData = playerMovementSamples.map(sample => ({
                    x: 20, // Player paddle X position
                    y: sample.y,
                    intensity: 1
                }));
                
                const grid = this.createIntensityGrid(movementData);
                this.drawHeatMapGrid(grid);
                this.drawGameField();
                
                return {
                    totalSamples: playerMovementSamples.length,
                    avgPosition: movementData.reduce((sum, d) => sum + d.y, 0) / movementData.length,
                    maxIntensity: this.maxIntensity
                };
            }
            
            drawCombined(analytics, playerMovementSamples) {
                if (!this.ctx) return;
                
                this.clearCanvas();
                
                // Combine all data with different colors
                const allData = [];
                
                // Player hits (red tint)
                if (analytics.heatMap.playerHits.length > 0) {
                    allData.push(...analytics.heatMap.playerHits.map(hit => ({...hit, type: 'playerHit'})));
                }
                
                // AI hits (blue tint)
                if (analytics.heatMap.aiHits.length > 0) {
                    allData.push(...analytics.heatMap.aiHits.map(hit => ({...hit, type: 'aiHit'})));
                }
                
                // Ball trajectory (green tint)
                if (analytics.heatMap.ballTrajectories.length > 0) {
                    allData.push(...analytics.heatMap.ballTrajectories.map(traj => ({...traj, type: 'ballTrajectory'})));
                }
                
                this.drawCombinedHeatMap(allData);
                this.drawGameField();
                
                return {
                    playerHits: analytics.heatMap.playerHits.length,
                    aiHits: analytics.heatMap.aiHits.length,
                    ballSamples: analytics.heatMap.ballTrajectories.length,
                    maxIntensity: this.maxIntensity
                };
            }
            
            createIntensityGrid(data) {
                const gridCols = Math.ceil(this.heatmapWidth / this.gridSize);
                const gridRows = Math.ceil(this.heatmapHeight / this.gridSize);
                const grid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                
                this.maxIntensity = 0;
                
                data.forEach(point => {
                    const gridX = Math.floor((point.x * this.scaleX) / this.gridSize);
                    const gridY = Math.floor((point.y * this.scaleY) / this.gridSize);
                    
                    if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
                        grid[gridY][gridX] += point.intensity || 1;
                        this.maxIntensity = Math.max(this.maxIntensity, grid[gridY][gridX]);
                    }
                });
                
                return grid;
            }
            
            drawHeatMapGrid(grid) {
                if (!this.ctx) return;
                
                for (let row = 0; row < grid.length; row++) {
                    for (let col = 0; col < grid[row].length; col++) {
                        const intensity = grid[row][col];
                        if (intensity > 0) {
                            const color = this.getIntensityColor(intensity, this.maxIntensity);
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(
                                col * this.gridSize,
                                row * this.gridSize,
                                this.gridSize,
                                this.gridSize
                            );
                        }
                    }
                }
            }
            
            drawCombinedHeatMap(data) {
                if (!this.ctx) return;
                
                const gridCols = Math.ceil(this.heatmapWidth / this.gridSize);
                const gridRows = Math.ceil(this.heatmapHeight / this.gridSize);
                
                // Separate grids for different data types
                const playerGrid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                const aiGrid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                const ballGrid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
                
                data.forEach(point => {
                    const gridX = Math.floor((point.x * this.scaleX) / this.gridSize);
                    const gridY = Math.floor((point.y * this.scaleY) / this.gridSize);
                    
                    if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
                        const intensity = point.intensity || 1;
                        
                        switch (point.type) {
                            case 'playerHit':
                                playerGrid[gridY][gridX] += intensity;
                                break;
                            case 'aiHit':
                                aiGrid[gridY][gridX] += intensity;
                                break;
                            case 'ballTrajectory':
                                ballGrid[gridY][gridX] += intensity;
                                break;
                        }
                    }
                });
                
                // Find max intensity across all grids
                this.maxIntensity = 0;
                [playerGrid, aiGrid, ballGrid].forEach(grid => {
                    grid.forEach(row => {
                        row.forEach(cell => {
                            this.maxIntensity = Math.max(this.maxIntensity, cell);
                        });
                    });
                });
                
                // Draw combined visualization
                for (let row = 0; row < gridRows; row++) {
                    for (let col = 0; col < gridCols; col++) {
                        const playerIntensity = playerGrid[row][col];
                        const aiIntensity = aiGrid[row][col];
                        const ballIntensity = ballGrid[row][col];
                        
                        if (playerIntensity > 0 || aiIntensity > 0 || ballIntensity > 0) {
                            // Blend colors based on different data types
                            const alpha = Math.min(0.8, (playerIntensity + aiIntensity + ballIntensity) / this.maxIntensity * 0.8 + 0.2);
                            const r = Math.min(255, (playerIntensity / this.maxIntensity) * 255);
                            const g = Math.min(255, (ballIntensity / this.maxIntensity) * 255);
                            const b = Math.min(255, (aiIntensity / this.maxIntensity) * 255);
                            
                            this.ctx.fillStyle = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, ${alpha})`;
                            this.ctx.fillRect(
                                col * this.gridSize,
                                row * this.gridSize,
                                this.gridSize,
                                this.gridSize
                            );
                        }
                    }
                }
            }
            
            drawGameField() {
                if (!this.ctx) return;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                
                // Draw center line
                this.ctx.setLineDash([2, 2]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.heatmapWidth / 2, 0);
                this.ctx.lineTo(this.heatmapWidth / 2, this.heatmapHeight);
                this.ctx.stroke();
                
                // Draw paddles
                this.ctx.setLineDash([]);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                
                // Player paddle (left)
                const playerPaddleX = 20 * this.scaleX;
                const paddleWidth = 10 * this.scaleX;
                const paddleHeight = 80 * this.scaleY;
                const centerY = (this.heatmapHeight - paddleHeight) / 2;
                
                this.ctx.fillRect(playerPaddleX, centerY, paddleWidth, paddleHeight);
                
                // AI paddle (right)
                const aiPaddleX = (800 - 30) * this.scaleX;
                this.ctx.fillRect(aiPaddleX, centerY, paddleWidth, paddleHeight);
            }
            
            clearCanvas() {
                if (!this.ctx) return;
                this.ctx.clearRect(0, 0, this.heatmapWidth, this.heatmapHeight);
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.heatmapWidth, this.heatmapHeight);
            }
            
            calculateAverageIntensity(data) {
                if (data.length === 0) return 0;
                const totalIntensity = data.reduce((sum, point) => sum + (point.intensity || 1), 0);
                return (totalIntensity / data.length).toFixed(2);
            }
        }
        
        // ===== POWER-UP SYSTEM =====
        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.width = 20; this.height = 20;
                this.life = 10; // seconds before despawn
                this.pulse = 0; // for visual pulsing effect
                this.collected = false;
                
                // Power-up definitions
                this.types = {
                    speedBoost: {color: '#ff6b6b', icon: '⚡', effect: 'Speed Boost!'},
                    sizeChange: {color: '#4ecdc4', icon: '📏', effect: 'Size Change!'},
                    freeze: {color: '#a8e6cf', icon: '❄️', effect: 'Freeze!'},
                    ballSize: {color: '#ffd54f', icon: '🔍', effect: 'Ball Size!'},
                    magnetic: {color: '#ff69b4', icon: '🧲', effect: 'Magnetic Ball!'}
                };
            }
            
            update(dt) {
                this.life -= dt;
                this.pulse += dt * 6; // pulsing animation speed
                return this.life > 0 && !this.collected;
            }
            
            draw(ctx) {
                const powerType = this.types[this.type];
                const pulseFactor = 1 + Math.sin(this.pulse) * 0.2;
                const size = this.width * pulseFactor;
                
                ctx.save();
                ctx.globalAlpha = Math.max(0.3, this.life / 10);
                
                // Glow effect
                ctx.shadowColor = powerType.color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = powerType.color;
                
                // Draw power-up background
                ctx.fillRect(this.x + (this.width - size)/2, this.y + (this.height - size)/2, size, size);
                
                // Draw icon
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.font = `${size * 0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(powerType.icon, this.x + this.width/2, this.y + this.height/2 + size * 0.2);
                
                ctx.restore();
            }
            
            checkCollision(paddle) {
                return this.x < paddle.x + paddle.width &&
                       this.x + this.width > paddle.x &&
                       this.y < paddle.y + paddle.height &&
                       this.y + this.height > paddle.y;
            }
        }

        // ===== GAME ENGINE =====
        class GameEngine {
            constructor(canvas, ctx) {
                this.canvas = canvas; this.ctx = ctx;
                this.gameMode = 'classic'; this.gameState = 'menu';
                
                // Game objects
                this.player = {x: 20, y: canvas.height/2-40, width: 10, height: 80, score: 0, lives: 3, 
                              prevY: canvas.height/2-40, velocity: 0};
                this.ai = {x: canvas.width-30, y: canvas.height/2-40, width: 10, height: 80, score: 0, 
                          difficulty: 'medium', personality: 'balanced', reactionTime: 0.1, errorRate: 0.1,
                          prevY: canvas.height/2-40, velocity: 0, targetY: canvas.height/2-40};
                this.ball = {x: canvas.width/2, y: canvas.height/2, width: 10, height: 10, 
                           vx: 5, vy: 3, maxSpeed: 15, speedIncrease: 0.02, trail: [], 
                           spin: 0, spinDecay: 0.95}; // spin: + = clockwise, - = counterclockwise
                
                // Machine Learning AI System
                this.mlAI = new MachineLearningAI();
                this.mlAI.loadFromStorage();
                this.lastPlayerPosition = canvas.height/2;
                this.ballDirectionChangeTime = 0;
                
                // Settings & effects
                this.settings = {winScore: 10, ballTrail: true, screenShake: true, particles: true, sound: true};
                this.screenShake = {x: 0, y: 0, intensity: 0, duration: 0};
                this.slowMotion = {active: false, factor: 1, duration: 0};
                
                // Power-ups system
                this.powerUps = [];
                this.playerEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.aiEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.lastPowerUpSpawn = 0;
                this.powerUpSpawnDelay = 8; // seconds
                this.ballSizeEffect = 0; // Timer for ball size effect
                this.magneticEffect = 0; // Timer for magnetic ball effect
                
                // Stats
                this.stats = {gamesPlayed: 0, gamesWon: 0, gamesLost: 0, longestRally: 0, 
                            currentRally: 0, totalHits: 0, perfectGames: 0};
                
                // Advanced Analytics
                this.analytics = {
                    playerBehavior: {
                        movementPattern: [], // Track player Y positions over time
                        reactionTimes: [], // Time between ball direction change and player response
                        hitZones: [], // Where player hits the ball (top, middle, bottom)
                        averagePosition: 0, // Player's average paddle position
                        defensiveStyle: 0, // How defensive vs aggressive (0-1)
                        consistency: 0 // How consistent player movement is (0-1)
                    },
                    heatMap: {
                        playerHits: [], // {x, y, intensity} for player paddle hits
                        aiHits: [], // {x, y, intensity} for AI paddle hits
                        ballTrajectories: [], // Ball position samples
                        scoringZones: [] // Where goals are scored from
                    },
                    gameFlow: {
                        rallyLengths: [],
                        gameRhythm: [], // Time between hits
                        intensityMoments: [], // High-action periods
                        comebackAttempts: 0
                    },
                    aiLearning: {
                        playerPreferences: {}, // What player tends to do in situations
                        successfulStrategies: [], // What works against this player
                        adaptationLevel: 0 // How much AI has learned (0-1)
                    }
                };
                this.loadStats();
                this.loadAnalytics();
                this.loadAchievements();
                
                // Achievement System
                this.achievements = {
                    unlocked: new Set(),
                    definitions: {
                        'first_win': {title: '🏆 First Victory', description: 'Win your first game', condition: () => this.stats.gamesWon >= 1},
                        'perfect_game': {title: '🎯 Flawless', description: 'Win without opponent scoring', condition: () => this.stats.perfectGames >= 1},
                        'streak_5': {title: '🔥 Hot Streak', description: 'Win 5 games in a row', condition: () => this.checkWinStreak(5)},
                        'rally_master': {title: '🏓 Rally Master', description: 'Achieve 50+ hit rally', condition: () => this.stats.longestRally >= 50},
                        'consistency': {title: '📏 Consistent Player', description: 'Maintain 80%+ movement consistency', condition: () => this.analytics.playerBehavior.consistency >= 0.8},
                        'quick_reflexes': {title: '⚡ Lightning Reflexes', description: 'Average reaction time under 200ms', condition: () => this.getAverageReactionTime() < 200},
                        'defensive_master': {title: '🛡️ Defensive Wall', description: 'Spend 80%+ time in center court', condition: () => this.analytics.playerBehavior.defensiveStyle >= 0.8},
                        'power_user': {title: '💪 Power Player', description: 'Collect 25 power-ups', condition: () => this.stats.powerUpsCollected >= 25},
                        'survivor': {title: '💀 Survivor', description: 'Win a survival mode game', condition: () => this.stats.survivalWins >= 1},
                        'speed_demon': {title: '🏃 Speed Demon', description: 'Win a speedball mode game', condition: () => this.stats.speedballWins >= 1},
                        'ai_tamer': {title: '🤖 AI Tamer', description: 'Beat all AI personalities', condition: () => this.checkAllPersonalitiesBeaten()},
                        'marathon': {title: '🏃‍♂️ Marathon Player', description: 'Play 100 games', condition: () => this.stats.gamesPlayed >= 100},
                        'dedication': {title: '⏰ Dedicated', description: 'Play for 60+ minutes total', condition: () => this.stats.totalPlayTime >= 3600000},
                        'comeback_king': {title: '👑 Comeback King', description: 'Win after being 5+ points behind', condition: () => this.stats.comebacks >= 1}
                    },
                    newlyUnlocked: [] // For showing achievement notifications
                };
                
                // Extended stats for achievements
                if (!this.stats.powerUpsCollected) this.stats.powerUpsCollected = 0;
                if (!this.stats.survivalWins) this.stats.survivalWins = 0;
                if (!this.stats.speedballWins) this.stats.speedballWins = 0;
                if (!this.stats.personalitiesBeaten) this.stats.personalitiesBeaten = new Set();
                if (!this.stats.currentWinStreak) this.stats.currentWinStreak = 0;
                if (!this.stats.maxWinStreak) this.stats.maxWinStreak = 0;
                if (!this.stats.comebacks) this.stats.comebacks = 0;
                if (!this.stats.totalPlayTime) this.stats.totalPlayTime = 0;
                if (!this.stats.gameStartTime) this.stats.gameStartTime = 0;
                
                // Analytics tracking variables
                this.lastBallDirectionChange = 0;
                this.lastPlayerMove = 0;
                this.currentRallyStartTime = 0;
                this.lastHitTime = 0;
                this.playerMovementSamples = [];
                this.ballPositionSamples = [];
                
                this.setupControls();
            }
            
            setupControls() {
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.gameState === 'playing') {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseY = e.clientY - rect.top;
                        let targetY = mouseY - this.player.height / 2;
                        
                        // Apply freeze effect to player movement
                        if (this.playerEffects.freeze > 0) {
                            const currentCenter = this.player.y + this.player.height / 2;
                            const targetCenter = targetY + this.player.height / 2;
                            const diff = targetCenter - currentCenter;
                            targetY = this.player.y + diff * 0.2; // Slow movement when frozen
                        }
                        
                        this.player.y = Math.max(0, Math.min(this.canvas.height - this.player.height, targetY));
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.gameState === 'playing') {
                        const rect = this.canvas.getBoundingClientRect();
                        const touchY = e.touches[0].clientY - rect.top;
                        this.player.y = Math.max(0, Math.min(this.canvas.height - this.player.height, 
                            touchY - this.player.height / 2));
                    }
                }, { passive: false });
                
                document.addEventListener('keydown', (e) => {
                    if (this.gameMode === 'multiplayer' && this.gameState === 'playing') {
                        switch (e.key) {
                            case 'w': case 'W': this.player.y = Math.max(0, this.player.y - 20); break;
                            case 's': case 'S': this.player.y = Math.min(this.canvas.height - this.player.height, this.player.y + 20); break;
                            case 'ArrowUp': this.ai.y = Math.max(0, this.ai.y - 20); break;
                            case 'ArrowDown': this.ai.y = Math.min(this.canvas.height - this.ai.height, this.ai.y + 20); break;
                        }
                    }
                });
            }
            
            getDifficultySettings() {
                const difficulties = {
                    easy: { aiSpeed: 150, ballSpeed: 3, aiReactionTime: 0.2, aiError: 0.2 },
                    medium: { aiSpeed: 200, ballSpeed: 5, aiReactionTime: 0.1, aiError: 0.1 },
                    hard: { aiSpeed: 250, ballSpeed: 7, aiReactionTime: 0.05, aiError: 0.05 }
                };
                return difficulties[this.ai.difficulty] || difficulties.medium;
            }
            
            updateAI(dt) {
                if (this.gameMode === 'multiplayer') return;
                
                const ballCenterY = this.ball.y + this.ball.height / 2;
                let newTargetY = ballCenterY;
                let speed = this.getDifficultySettings().aiSpeed;
                
                // Apply power-up effects
                if (this.aiEffects.speedBoost > 0) speed *= 1.8;
                if (this.aiEffects.freeze > 0) speed *= 0.2;
                
                // Record player movement for ML AI
                this.recordPlayerMovementData();
                
                // AI personality behavior
                switch (this.ai.personality) {
                    case 'defensive':
                        newTargetY = ballCenterY * 0.7 + (this.canvas.height / 2) * 0.3;
                        speed *= 0.8; break;
                    case 'aggressive':
                        if (this.ball.vx > 0) newTargetY = this.predictBallPosition();
                        speed *= 1.2; break;
                    case 'perfect':
                        speed *= 1.5; this.ai.errorRate = 0.01; break;
                    case 'unpredictable':
                        if (Math.random() < 0.1) newTargetY += (Math.random() - 0.5) * 50; break;
                    case 'trickster':
                        this.applyTricksterBehavior(newTargetY, dt); break;
                    case 'copycat':
                        newTargetY = this.applyCopycatBehavior(); break;
                    case 'adaptive':
                        // Use Machine Learning AI for adaptive behavior
                        newTargetY = this.mlAI.getAdaptiveTarget(
                            this.ball.x, this.ball.y, this.ball.vx, this.ball.vy,
                            this.player.y + this.player.height / 2,
                            this.ai.y + this.ai.height / 2
                        );
                        // Apply ML AI speed adjustment
                        speed *= this.mlAI.learningModel.adaptations.speedAdjustment;
                        break;
                    default:
                        if (this.ball.vx > 0) newTargetY = ballCenterY + this.ball.vy * 0.3;
                }
                
                // Apply reaction time and error
                if (Math.random() < this.ai.reactionTime) return;
                if (Math.random() < this.ai.errorRate) newTargetY += (Math.random() - 0.5) * 30;
                
                // Smooth interpolation to new target (prevents sudden jerky movements)
                const targetInterpolation = 0.1; // How quickly AI adjusts target (lower = smoother)
                this.ai.targetY = this.ai.targetY + (newTargetY - this.ai.targetY) * targetInterpolation;
                
                const targetPaddleY = this.ai.targetY - this.ai.height / 2;
                const difference = targetPaddleY - this.ai.y;
                
                // Add dead zone to prevent micro-adjustments and vibration
                const deadZone = 8; // pixels - increased for smoother movement
                if (Math.abs(difference) < deadZone) return;
                
                // Smooth movement with speed limiting
                const maxMoveDistance = speed * dt;
                const moveAmount = Math.sign(difference) * Math.min(Math.abs(difference), maxMoveDistance);
                
                this.ai.y += moveAmount;
                this.ai.y = Math.max(0, Math.min(this.canvas.height - this.ai.height, this.ai.y));
            }
            
            predictBallPosition() {
                const distanceToAI = this.ai.x - this.ball.x;
                const timeToReach = distanceToAI / Math.abs(this.ball.vx);
                return this.ball.y + this.ball.vy * timeToReach;
            }
            
            recordPlayerMovementData() {
                const currentPlayerY = this.player.y + this.player.height / 2;
                
                // Record basic movement pattern
                this.mlAI.recordPlayerAction('playerMovement', {
                    y: currentPlayerY,
                    ballX: this.ball.x,
                    ballY: this.ball.y,
                    ballVx: this.ball.vx,
                    ballVy: this.ball.vy
                });
                
                // Detect if player is in defensive zone
                const centerY = this.canvas.height / 2;
                if (Math.abs(currentPlayerY - centerY) < 60) {
                    this.mlAI.recordPlayerAction('defensiveZones', {
                        y: currentPlayerY,
                        ballDistance: Math.abs(this.ball.x - this.player.x)
                    });
                }
                
                // Record reaction time when ball direction changes
                if (this.ballDirectionChangeTime > 0 && Math.abs(currentPlayerY - this.lastPlayerPosition) > 5) {
                    const reactionTime = Date.now() - this.ballDirectionChangeTime;
                    this.mlAI.recordPlayerAction('reactionTimes', {
                        time: reactionTime,
                        ballSpeed: Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy),
                        playerMovement: Math.abs(currentPlayerY - this.lastPlayerPosition)
                    });
                    this.ballDirectionChangeTime = 0;
                }
                
                this.lastPlayerPosition = currentPlayerY;
            }
            
            update(dt) {
                if (this.gameState !== 'playing') return;
                
                // Screen shake
                if (this.screenShake.duration > 0) {
                    this.screenShake.duration -= dt;
                    const intensity = this.screenShake.intensity * (this.screenShake.duration / 0.5);
                    this.screenShake.x = (Math.random() - 0.5) * intensity;
                    this.screenShake.y = (Math.random() - 0.5) * intensity;
                } else {
                    this.screenShake.x = 0; this.screenShake.y = 0;
                }
                
                // Slow motion
                if (this.slowMotion.active) {
                    this.slowMotion.duration -= dt;
                    if (this.slowMotion.duration <= 0) {
                        this.slowMotion.active = false; this.slowMotion.factor = 1;
                    }
                }
                
                const effectiveDt = dt * this.slowMotion.factor;
                this.updatePowerUps(effectiveDt);
                this.updatePlayerEffects(effectiveDt);
                this.updatePaddleVelocities(effectiveDt);
                this.updateAI(effectiveDt);
                this.updateBall(effectiveDt);
                this.updateBallTrail();
                this.updateAnalytics(effectiveDt);
            }
            
            updateBall(dt) {
                // Apply magnetic effect before movement
                if (this.magneticEffect > 0) {
                    this.applyMagneticForce(dt);
                }
                
                // Apply spin effect to ball trajectory
                if (Math.abs(this.ball.spin) > 0.1) {
                    this.applySpinEffect(dt);
                }
                
                this.ball.x += this.ball.vx * dt * 60;
                this.ball.y += this.ball.vy * dt * 60;
                
                // Apply spin decay
                this.ball.spin *= this.ball.spinDecay;
                
                // Wall collision
                if (this.ball.y <= 0 || this.ball.y >= this.canvas.height - this.ball.height) {
                    this.ball.vy = -this.ball.vy;
                    this.ball.y = Math.max(0, Math.min(this.canvas.height - this.ball.height, this.ball.y));
                    this.addScreenShake(3);
                    audioSystem?.play('wallBounce');
                    particleSystem?.wallBounce(this.ball.x + this.ball.width/2, this.ball.y + this.ball.height/2);
                }
                
                this.checkPaddleCollision();
                this.checkBallPowerUpCollision();
                
                // Scoring
                if (this.ball.x < -this.ball.width) this.aiScored();
                else if (this.ball.x > this.canvas.width) this.playerScored();
                
                // Speed increase in speedball mode
                if (this.gameMode === 'speedball') {
                    const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                    if (speed < this.ball.maxSpeed) {
                        this.ball.vx *= (1 + this.ball.speedIncrease);
                        this.ball.vy *= (1 + this.ball.speedIncrease);
                    }
                }
            }
            
            checkBallPowerUpCollision() {
                // Check if ball collides with any power-ups
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    if (this.ball.x < powerUp.x + powerUp.width &&
                        this.ball.x + this.ball.width > powerUp.x &&
                        this.ball.y < powerUp.y + powerUp.height &&
                        this.ball.y + this.ball.height > powerUp.y) {
                        
                        // Randomly assign power-up to player or AI
                        const collector = Math.random() > 0.5 ? 'player' : 'ai';
                        this.collectPowerUp(powerUp, collector);
                        this.powerUps.splice(i, 1); // Remove the power-up
                    }
                }
            }
            
            checkPaddleCollision() {
                // Player paddle
                if (this.ball.x <= this.player.x + this.player.width &&
                    this.ball.x + this.ball.width >= this.player.x &&
                    this.ball.y <= this.player.y + this.player.height &&
                    this.ball.y + this.ball.height >= this.player.y &&
                    this.ball.vx < 0) {
                    
                    this.ball.vx = Math.abs(this.ball.vx);
                    this.ball.x = this.player.x + this.player.width;
                    const hitPos = (this.ball.y + this.ball.height/2) - (this.player.y + this.player.height/2);
                    this.ball.vy += hitPos * 0.15;
                    
                    // Add spin based on paddle velocity and hit position
                    const spinFactor = 0.02;
                    const paddleMovementSpin = this.player.velocity * spinFactor;
                    const hitPositionSpin = hitPos * 0.01; // Hit position affects spin
                    this.ball.spin = paddleMovementSpin + hitPositionSpin;
                    
                    this.stats.currentRally++; this.stats.totalHits++;
                    this.addScreenShake(5); this.addSlowMotion(0.3, 0.1);
                    audioSystem?.play('paddleHit');
                    particleSystem?.paddleHit(this.ball.x, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    backgroundEffect?.onBallHit();
                    
                    // Record analytics
                    this.recordHit(true, this.ball.x, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    this.lastBallDirectionChange = Date.now();
                    
                    // Record ML AI data for player hits
                    this.mlAI.recordPlayerAction('ballInterceptions', {
                        x: this.ball.x,
                        y: this.ball.y + this.ball.height/2,
                        paddleY: this.player.y + this.player.height/2,
                        hitPosition: hitPos,
                        ballSpeed: Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy)
                    });
                    
                    this.mlAI.recordPlayerAction('successfulHits', {
                        x: this.ball.x,
                        y: this.ball.y + this.ball.height/2,
                        zone: Math.floor((this.ball.y + this.ball.height/2) / 50)
                    });
                    
                    // Mark ball direction change for reaction time tracking
                    this.ballDirectionChangeTime = Date.now();
                }
                
                // AI paddle
                if (this.ball.x + this.ball.width >= this.ai.x &&
                    this.ball.x <= this.ai.x + this.ai.width &&
                    this.ball.y <= this.ai.y + this.ai.height &&
                    this.ball.y + this.ball.height >= this.ai.y &&
                    this.ball.vx > 0) {
                    
                    this.ball.vx = -Math.abs(this.ball.vx);
                    this.ball.x = this.ai.x - this.ball.width;
                    const hitPos = (this.ball.y + this.ball.height/2) - (this.ai.y + this.ai.height/2);
                    this.ball.vy += hitPos * 0.15;
                    
                    // Add spin based on paddle velocity and hit position (opposite direction from player)
                    const spinFactor = 0.02;
                    const paddleMovementSpin = -this.ai.velocity * spinFactor; // Negative for AI paddle
                    const hitPositionSpin = -hitPos * 0.01; // Opposite spin direction
                    this.ball.spin = paddleMovementSpin + hitPositionSpin;
                    
                    this.stats.currentRally++; this.stats.totalHits++;
                    this.addScreenShake(5); this.addSlowMotion(0.3, 0.1);
                    audioSystem?.play('paddleHit');
                    particleSystem?.paddleHit(this.ball.x + this.ball.width, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    backgroundEffect?.onBallHit();
                    
                    // Record analytics
                    this.recordHit(false, this.ball.x + this.ball.width, this.ball.y + this.ball.height/2, this.ball.vx, this.ball.vy);
                    this.lastBallDirectionChange = Date.now();
                }
            }
            
            updateBallTrail() {
                if (!this.settings.ballTrail) return;
                this.ball.trail.push({x: this.ball.x + this.ball.width/2, y: this.ball.y + this.ball.height/2, age: 0});
                this.ball.trail = this.ball.trail.filter(point => { point.age += 1; return point.age < 20; });
            }
            
            playerScored() {
                this.player.score++;
                if (this.stats.currentRally > this.stats.longestRally) this.stats.longestRally = this.stats.currentRally;
                this.stats.currentRally = 0;
                audioSystem?.play('score');
                particleSystem?.scoreEffect(this.canvas.width / 4, this.canvas.height / 2, true);
                backgroundEffect?.onScore();
                this.resetBall(); this.addSlowMotion(0.5, 0.5);
                if (this.player.score >= this.settings.winScore) this.playerWon();
            }
            
            aiScored() {
                this.ai.score++;
                
                // Record player miss (weak spot) for ML AI
                this.mlAI.recordPlayerAction('weakSpots', {
                    x: this.ball.x,
                    y: this.ball.y + this.ball.height/2,
                    playerY: this.player.y + this.player.height/2,
                    missDistance: Math.abs((this.ball.y + this.ball.height/2) - (this.player.y + this.player.height/2))
                });
                
                if (this.gameMode === 'survival') {
                    this.player.lives--;
                    if (this.player.lives <= 0) { this.aiWon(); return; }
                }
                if (this.stats.currentRally > this.stats.longestRally) this.stats.longestRally = this.stats.currentRally;
                this.stats.currentRally = 0;
                audioSystem?.play('score');
                particleSystem?.scoreEffect(this.canvas.width * 3/4, this.canvas.height / 2, false);
                backgroundEffect?.onScore();
                this.resetBall();
                if (this.ai.score >= this.settings.winScore) this.aiWon();
            }
            
            playerWon() {
                this.gameState = 'gameOver'; this.stats.gamesPlayed++; this.stats.gamesWon++;
                if (this.ai.score === 0) this.stats.perfectGames++;
                
                // Track win streak
                this.stats.currentWinStreak++;
                if (this.stats.currentWinStreak > this.stats.maxWinStreak) {
                    this.stats.maxWinStreak = this.stats.currentWinStreak;
                }
                
                // Track personality beaten
                this.stats.personalitiesBeaten.add(this.ai.personality);
                
                // Track game mode victories
                if (this.gameMode === 'survival') this.stats.survivalWins++;
                if (this.gameMode === 'speedball') this.stats.speedballWins++;
                
                // ML AI analysis after game
                if (this.ai.personality === 'adaptive') {
                    this.mlAI.analyzeGamePatterns({
                        gamesPlayed: this.stats.gamesPlayed,
                        gamesWon: this.stats.gamesWon,
                        gameResult: 'win',
                        finalScore: {player: this.player.score, ai: this.ai.score}
                    });
                    this.mlAI.saveToStorage();
                }
                
                this.addScreenShake(10);
                audioSystem?.play('win');
                particleSystem?.winEffect(this.canvas.width, this.canvas.height);
                this.saveStats();
                this.saveAnalytics();
                
                // Check achievements after game ends
                this.checkAchievements();
                
                setTimeout(() => this.resetGame(), 3000);
            }
            
            aiWon() {
                this.gameState = 'gameOver'; this.stats.gamesPlayed++; this.stats.gamesLost++;
                
                // Reset win streak on loss
                this.stats.currentWinStreak = 0;
                
                // ML AI analysis after game
                if (this.ai.personality === 'adaptive') {
                    this.mlAI.analyzeGamePatterns({
                        gamesPlayed: this.stats.gamesPlayed,
                        gamesWon: this.stats.gamesWon,
                        gameResult: 'loss',
                        finalScore: {player: this.player.score, ai: this.ai.score}
                    });
                    this.mlAI.saveToStorage();
                }
                
                this.addScreenShake(8);
                audioSystem?.play('lose');
                this.saveStats();
                this.saveAnalytics();
                
                // Check achievements even on loss (some achievements might be reached)
                this.checkAchievements();
                
                setTimeout(() => this.resetGame(), 3000);
            }
            
            resetBall() {
                this.ball.x = this.canvas.width / 2 - this.ball.width / 2;
                this.ball.y = this.canvas.height / 2 - this.ball.height / 2;
                const settings = this.getDifficultySettings();
                this.ball.vx = (Math.random() > 0.5 ? 1 : -1) * settings.ballSpeed;
                this.ball.vy = (Math.random() - 0.5) * settings.ballSpeed;
                this.ball.trail = [];
            }
            
            resetGame() {
                this.player.score = 0; this.ai.score = 0; this.player.lives = 3;
                this.stats.currentRally = 0;
                this.player.y = this.canvas.height / 2 - this.player.height / 2;
                this.ai.y = this.canvas.height / 2 - this.ai.height / 2;
                
                // Clear power-ups and effects
                this.powerUps = [];
                this.playerEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.aiEffects = {speedBoost: 0, sizeChange: 0, freeze: 0};
                this.ballSizeEffect = 0;
                this.magneticEffect = 0;
                this.lastPowerUpSpawn = 0;
                this.player.height = 80;
                this.ai.height = 80;
                this.ball.width = 10;
                this.ball.height = 10;
                
                this.resetBall(); this.gameState = 'playing';
                audioSystem?.play('gameStart');
            }
            
            setGameMode(mode) {
                this.gameMode = mode;
                switch (mode) {
                    case 'speedball': this.ball.speedIncrease = 0.02; break;
                    case 'survival': this.player.lives = 5; this.settings.winScore = 999; break;
                    case 'tournament': this.settings.winScore = 7; break;
                    case 'practice': this.settings.winScore = 999; break;
                }
                this.resetGame();
            }
            
            setAIPersonality(personality) {
                this.ai.personality = personality;
                switch (personality) {
                    case 'defensive': this.ai.reactionTime = 0.15; this.ai.errorRate = 0.12; break;
                    case 'aggressive': this.ai.reactionTime = 0.08; this.ai.errorRate = 0.08; break;
                    case 'perfect': this.ai.reactionTime = 0.02; this.ai.errorRate = 0.01; break;
                    case 'unpredictable': this.ai.reactionTime = 0.1 + Math.random() * 0.1; this.ai.errorRate = 0.15; break;
                    case 'trickster': 
                        this.ai.reactionTime = 0.12; this.ai.errorRate = 0.1;
                        this.ai.tricksterState = {fakeDirection: 0, fakeTimer: 0, realTarget: 0}; break;
                    case 'copycat':
                        this.ai.reactionTime = 0.1; this.ai.errorRate = 0.08;
                        this.ai.copycatMemory = []; break;
                    case 'adaptive':
                        this.ai.reactionTime = 0.1; this.ai.errorRate = 0.1;
                        this.ai.adaptiveStrategy = {currentStrategy: 'balanced', confidence: 0.5}; break;
                    default: this.ai.reactionTime = 0.1; this.ai.errorRate = 0.1;
                }
            }
            
            applyTricksterBehavior(targetY, dt) {
                // Trickster AI uses fake movements to confuse the player
                if (!this.ai.tricksterState) {
                    this.ai.tricksterState = {fakeDirection: 0, fakeTimer: 0, realTarget: targetY};
                }
                
                this.ai.tricksterState.fakeTimer -= dt;
                
                // Occasionally start a fake movement
                if (this.ai.tricksterState.fakeTimer <= 0 && Math.random() < 0.3) {
                    this.ai.tricksterState.fakeDirection = (Math.random() - 0.5) * 100;
                    this.ai.tricksterState.fakeTimer = 0.5 + Math.random() * 0.5;
                    this.ai.tricksterState.realTarget = targetY;
                }
                
                // Apply fake movement or real movement
                if (this.ai.tricksterState.fakeTimer > 0) {
                    return this.ai.y + this.ai.tricksterState.fakeDirection;
                } else {
                    return this.ai.tricksterState.realTarget;
                }
            }
            
            applyCopycatBehavior() {
                // Copycat AI mimics player movement patterns
                if (!this.ai.copycatMemory) this.ai.copycatMemory = [];
                
                // Record player positions
                this.ai.copycatMemory.push({
                    playerY: this.player.y,
                    ballY: this.ball.y,
                    time: Date.now()
                });
                
                // Keep only recent memory (last 3 seconds)
                const now = Date.now();
                this.ai.copycatMemory = this.ai.copycatMemory.filter(m => now - m.time < 3000);
                
                // Find similar ball position in memory and copy player response
                const currentBallY = this.ball.y;
                let bestMatch = null;
                let bestDistance = Infinity;
                
                this.ai.copycatMemory.forEach(memory => {
                    const distance = Math.abs(memory.ballY - currentBallY);
                    if (distance < bestDistance && distance < 50) {
                        bestDistance = distance;
                        bestMatch = memory;
                    }
                });
                
                if (bestMatch) {
                    // Mirror the player's position relative to ball
                    const mirrorOffset = bestMatch.playerY - bestMatch.ballY;
                    return currentBallY + mirrorOffset;
                } else {
                    // Fall back to normal behavior if no pattern found
                    return this.ball.y + this.ball.height / 2;
                }
            }
            
            applyAdaptiveBehavior(ballCenterY) {
                // Adaptive AI learns from player patterns and adjusts strategy
                if (!this.ai.adaptiveStrategy) {
                    this.ai.adaptiveStrategy = {currentStrategy: 'balanced', confidence: 0.5};
                }
                
                // Analyze recent player performance
                const recentPerformance = this.analyzePlayerPerformance();
                
                // Adjust strategy based on what's working
                if (recentPerformance.playerWinRate < 0.3) {
                    this.ai.adaptiveStrategy.currentStrategy = 'defensive';
                    this.ai.adaptiveStrategy.confidence = Math.min(1, this.ai.adaptiveStrategy.confidence + 0.1);
                } else if (recentPerformance.playerWinRate > 0.7) {
                    this.ai.adaptiveStrategy.currentStrategy = 'aggressive';
                    this.ai.adaptiveStrategy.confidence = Math.min(1, this.ai.adaptiveStrategy.confidence + 0.1);
                } else {
                    this.ai.adaptiveStrategy.currentStrategy = 'balanced';
                }
                
                // Apply the current strategy with confidence weighting
                let targetY = ballCenterY;
                const confidence = this.ai.adaptiveStrategy.confidence;
                
                switch (this.ai.adaptiveStrategy.currentStrategy) {
                    case 'defensive':
                        targetY = ballCenterY * (0.6 + confidence * 0.2) + (this.canvas.height / 2) * (0.4 - confidence * 0.2);
                        break;
                    case 'aggressive':
                        if (this.ball.vx > 0) {
                            targetY = this.predictBallPosition() * (0.8 + confidence * 0.2);
                        }
                        break;
                    default:
                        targetY = ballCenterY + this.ball.vy * (0.2 + confidence * 0.3);
                }
                
                return targetY;
            }
            
            analyzePlayerPerformance() {
                // Analyze recent player performance for adaptive AI
                const recentGames = Math.min(5, this.stats.gamesPlayed);
                if (recentGames === 0) {
                    return {playerWinRate: 0.5, averageRally: 0, consistency: 0.5};
                }
                
                const playerWinRate = this.stats.gamesWon / this.stats.gamesPlayed;
                const averageRally = this.stats.totalHits / this.stats.gamesPlayed;
                const consistency = this.analytics.playerBehavior.consistency || 0.5;
                
                return {playerWinRate, averageRally, consistency};
            }
            
            addScreenShake(intensity) {
                if (this.settings.screenShake) {
                    this.screenShake.intensity = intensity; this.screenShake.duration = 0.5;
                }
            }
            
            addSlowMotion(factor, duration) {
                this.slowMotion.active = true; this.slowMotion.factor = factor; this.slowMotion.duration = duration;
            }
            
            applyMagneticForce(dt) {
                const ballCenterX = this.ball.x + this.ball.width / 2;
                const ballCenterY = this.ball.y + this.ball.height / 2;
                const magneticStrength = 80; // Adjust this for stronger/weaker attraction
                const maxDistance = 100; // Maximum distance for magnetic effect
                
                // Check attraction to player paddle
                const playerCenterX = this.player.x + this.player.width / 2;
                const playerCenterY = this.player.y + this.player.height / 2;
                const distanceToPlayer = Math.sqrt(
                    Math.pow(ballCenterX - playerCenterX, 2) + 
                    Math.pow(ballCenterY - playerCenterY, 2)
                );
                
                if (distanceToPlayer < maxDistance && distanceToPlayer > 0) {
                    const forceStrength = (1 - distanceToPlayer / maxDistance) * magneticStrength;
                    const forceX = (playerCenterX - ballCenterX) / distanceToPlayer * forceStrength;
                    const forceY = (playerCenterY - ballCenterY) / distanceToPlayer * forceStrength;
                    
                    this.ball.vx += forceX * dt;
                    this.ball.vy += forceY * dt;
                }
                
                // Check attraction to AI paddle
                const aiCenterX = this.ai.x + this.ai.width / 2;
                const aiCenterY = this.ai.y + this.ai.height / 2;
                const distanceToAI = Math.sqrt(
                    Math.pow(ballCenterX - aiCenterX, 2) + 
                    Math.pow(ballCenterY - aiCenterY, 2)
                );
                
                if (distanceToAI < maxDistance && distanceToAI > 0) {
                    const forceStrength = (1 - distanceToAI / maxDistance) * magneticStrength;
                    const forceX = (aiCenterX - ballCenterX) / distanceToAI * forceStrength;
                    const forceY = (aiCenterY - ballCenterY) / distanceToAI * forceStrength;
                    
                    this.ball.vx += forceX * dt;
                    this.ball.vy += forceY * dt;
                }
                
                // Limit ball speed to prevent it from going too fast
                const maxSpeed = this.ball.maxSpeed * 1.2;
                const currentSpeed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                if (currentSpeed > maxSpeed) {
                    this.ball.vx = (this.ball.vx / currentSpeed) * maxSpeed;
                    this.ball.vy = (this.ball.vy / currentSpeed) * maxSpeed;
                }
            }
            
            applySpinEffect(dt) {
                // Spin creates a perpendicular force (Magnus effect)
                const spinStrength = 0.3;
                const currentSpeed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                
                if (currentSpeed > 0) {
                    // Normalize velocity vector
                    const normalizedVx = this.ball.vx / currentSpeed;
                    const normalizedVy = this.ball.vy / currentSpeed;
                    
                    // Calculate perpendicular force (spin effect)
                    const spinForceX = -normalizedVy * this.ball.spin * spinStrength;
                    const spinForceY = normalizedVx * this.ball.spin * spinStrength;
                    
                    // Apply spin force
                    this.ball.vx += spinForceX * dt * 60;
                    this.ball.vy += spinForceY * dt * 60;
                }
            }
            
            updatePaddleVelocities(dt) {
                // Calculate paddle velocities for spin effects
                this.player.velocity = (this.player.y - this.player.prevY) / dt;
                this.ai.velocity = (this.ai.y - this.ai.prevY) / dt;
                
                // Store previous positions
                this.player.prevY = this.player.y;
                this.ai.prevY = this.ai.y;
                
                // Smooth velocity to avoid jitter
                this.player.velocity *= 0.8;
                this.ai.velocity *= 0.8;
            }
            
            updatePowerUps(dt) {
                // Spawn new power-ups periodically
                this.lastPowerUpSpawn += dt;
                if (this.lastPowerUpSpawn >= this.powerUpSpawnDelay) {
                    this.spawnPowerUp();
                    this.lastPowerUpSpawn = 0;
                }
                
                // Update existing power-ups
                this.powerUps = this.powerUps.filter(powerUp => {
                    const alive = powerUp.update(dt);
                    if (alive) {
                        // Check collisions with paddles
                        if (powerUp.checkCollision(this.player)) {
                            this.collectPowerUp(powerUp, 'player');
                            return false;
                        } else if (powerUp.checkCollision(this.ai)) {
                            this.collectPowerUp(powerUp, 'ai');
                            return false;
                        }
                    }
                    return alive;
                });
            }
            
            spawnPowerUp() {
                const types = ['speedBoost', 'sizeChange', 'freeze', 'ballSize', 'magnetic'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = this.canvas.width * 0.3 + Math.random() * this.canvas.width * 0.4;
                const y = 50 + Math.random() * (this.canvas.height - 100);
                this.powerUps.push(new PowerUp(x, y, type));
            }
            
            collectPowerUp(powerUp, collector) {
                powerUp.collected = true;
                const effectDuration = 5; // seconds
                
                // Track power-up collection for achievements
                this.stats.powerUpsCollected++;
                
                switch (powerUp.type) {
                    case 'speedBoost':
                        if (collector === 'player') this.playerEffects.speedBoost = effectDuration;
                        else this.aiEffects.speedBoost = effectDuration;
                        break;
                    case 'sizeChange':
                        if (collector === 'player') this.playerEffects.sizeChange = effectDuration;
                        else this.aiEffects.sizeChange = effectDuration;
                        break;
                    case 'freeze':
                        // Freeze effect affects the opponent
                        if (collector === 'player') this.aiEffects.freeze = effectDuration;
                        else this.playerEffects.freeze = effectDuration;
                        break;
                    case 'ballSize':
                        // Ball size effect is global (affects the ball itself)
                        this.ballSizeEffect = effectDuration;
                        const sizeMultiplier = Math.random() > 0.5 ? 1.8 : 0.6; // Bigger or smaller
                        this.ball.width *= sizeMultiplier;
                        this.ball.height *= sizeMultiplier;
                        break;
                    case 'magnetic':
                        // Magnetic effect is global (affects ball movement)
                        this.magneticEffect = effectDuration;
                        break;
                }
                
                audioSystem?.play('score');
                particleSystem?.scoreEffect(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, collector === 'player');
                backgroundEffect?.onPowerUpCollected();
            }
            
            updatePlayerEffects(dt) {
                // Update player effects
                Object.keys(this.playerEffects).forEach(effect => {
                    if (this.playerEffects[effect] > 0) {
                        this.playerEffects[effect] -= dt;
                        if (this.playerEffects[effect] <= 0) {
                            this.playerEffects[effect] = 0;
                        }
                    }
                });
                
                // Update AI effects
                Object.keys(this.aiEffects).forEach(effect => {
                    if (this.aiEffects[effect] > 0) {
                        this.aiEffects[effect] -= dt;
                        if (this.aiEffects[effect] <= 0) {
                            this.aiEffects[effect] = 0;
                        }
                    }
                });
                
                // Update ball size effect
                if (this.ballSizeEffect > 0) {
                    this.ballSizeEffect -= dt;
                    if (this.ballSizeEffect <= 0) {
                        // Reset ball to original size
                        this.ball.width = 10;
                        this.ball.height = 10;
                    }
                }
                
                // Update magnetic effect
                if (this.magneticEffect > 0) {
                    this.magneticEffect -= dt;
                    if (this.magneticEffect <= 0) {
                        this.magneticEffect = 0;
                    }
                }
                
                // Apply size changes
                const playerBaseHeight = 80;
                const aiBaseHeight = 80;
                this.player.height = playerBaseHeight * (this.playerEffects.sizeChange > 0 ? 1.5 : 1);
                this.ai.height = aiBaseHeight * (this.aiEffects.sizeChange > 0 ? 1.5 : 1);
            }
            
            saveStats() { 
                const statsToSave = { ...this.stats };
                // Convert Set to Array for storage
                if (this.stats.personalitiesBeaten instanceof Set) {
                    statsToSave.personalitiesBeaten = Array.from(this.stats.personalitiesBeaten);
                }
                localStorage.setItem('pongStats', JSON.stringify(statsToSave)); 
            }
            loadStats() {
                const saved = localStorage.getItem('pongStats');
                if (saved) {
                    const loadedStats = JSON.parse(saved);
                    this.stats = { ...this.stats, ...loadedStats };
                    // Convert Array back to Set if needed
                    if (Array.isArray(this.stats.personalitiesBeaten)) {
                        this.stats.personalitiesBeaten = new Set(this.stats.personalitiesBeaten);
                    }
                }
            }
            
            saveAnalytics() { 
                localStorage.setItem('pongAnalytics', JSON.stringify(this.analytics)); 
            }
            
            loadAnalytics() {
                const saved = localStorage.getItem('pongAnalytics');
                if (saved) {
                    const savedAnalytics = JSON.parse(saved);
                    this.analytics = { ...this.analytics, ...savedAnalytics };
                }
            }
            
            updateAnalytics(dt) {
                // Track player movement patterns
                this.playerMovementSamples.push({
                    y: this.player.y + this.player.height / 2,
                    time: Date.now()
                });
                
                // Keep only recent samples (last 10 seconds)
                const now = Date.now();
                this.playerMovementSamples = this.playerMovementSamples.filter(s => now - s.time < 10000);
                
                // Track ball trajectory for heat map
                this.ballPositionSamples.push({
                    x: this.ball.x + this.ball.width / 2,
                    y: this.ball.y + this.ball.height / 2,
                    time: now
                });
                
                // Keep recent ball samples
                this.ballPositionSamples = this.ballPositionSamples.filter(s => now - s.time < 5000);
                
                // Add to heat map trajectories
                if (this.analytics.heatMap.ballTrajectories.length < 1000) {
                    this.analytics.heatMap.ballTrajectories.push({
                        x: this.ball.x + this.ball.width / 2,
                        y: this.ball.y + this.ball.height / 2,
                        intensity: 1
                    });
                }
                
                // Calculate player behavior metrics
                this.calculateBehaviorMetrics();
            }
            
            calculateBehaviorMetrics() {
                if (this.playerMovementSamples.length < 10) return;
                
                // Calculate average position
                const totalY = this.playerMovementSamples.reduce((sum, sample) => sum + sample.y, 0);
                this.analytics.playerBehavior.averagePosition = totalY / this.playerMovementSamples.length;
                
                // Calculate movement consistency (lower variance = higher consistency)
                const avgY = this.analytics.playerBehavior.averagePosition;
                const variance = this.playerMovementSamples.reduce((sum, sample) => 
                    sum + Math.pow(sample.y - avgY, 2), 0) / this.playerMovementSamples.length;
                this.analytics.playerBehavior.consistency = Math.max(0, Math.min(1, 1 - (variance / 10000)));
                
                // Calculate defensive style (how much time spent in defensive vs aggressive positions)
                const defensivePositions = this.playerMovementSamples.filter(s => 
                    Math.abs(s.y - this.canvas.height / 2) < this.canvas.height * 0.25).length;
                this.analytics.playerBehavior.defensiveStyle = defensivePositions / this.playerMovementSamples.length;
            }
            
            recordHit(isPlayer, x, y, ballVx, ballVy) {
                // Record hit for heat map
                const hitData = {
                    x: x,
                    y: y,
                    intensity: Math.abs(ballVx) + Math.abs(ballVy), // Intensity based on ball speed
                    time: Date.now()
                };
                
                if (isPlayer) {
                    this.analytics.heatMap.playerHits.push(hitData);
                    // Keep only recent hits (last 100)
                    if (this.analytics.heatMap.playerHits.length > 100) {
                        this.analytics.heatMap.playerHits.shift();
                    }
                    
                    // Record hit zone (top, middle, bottom of paddle)
                    const paddleCenter = this.player.y + this.player.height / 2;
                    const hitOffset = y - paddleCenter;
                    let zone = 'middle';
                    if (hitOffset < -this.player.height * 0.25) zone = 'top';
                    else if (hitOffset > this.player.height * 0.25) zone = 'bottom';
                    
                    this.analytics.playerBehavior.hitZones.push(zone);
                    if (this.analytics.playerBehavior.hitZones.length > 50) {
                        this.analytics.playerBehavior.hitZones.shift();
                    }
                } else {
                    this.analytics.heatMap.aiHits.push(hitData);
                    if (this.analytics.heatMap.aiHits.length > 100) {
                        this.analytics.heatMap.aiHits.shift();
                    }
                }
                
                // Record game rhythm
                const timeSinceLastHit = Date.now() - this.lastHitTime;
                if (this.lastHitTime > 0) {
                    this.analytics.gameFlow.gameRhythm.push(timeSinceLastHit);
                    if (this.analytics.gameFlow.gameRhythm.length > 50) {
                        this.analytics.gameFlow.gameRhythm.shift();
                    }
                }
                this.lastHitTime = Date.now();
                
                // Track reaction time for player hits
                if (isPlayer && this.lastBallDirectionChange > 0) {
                    const reactionTime = Date.now() - this.lastBallDirectionChange;
                    this.analytics.playerBehavior.reactionTimes.push(reactionTime);
                    if (this.analytics.playerBehavior.reactionTimes.length > 20) {
                        this.analytics.playerBehavior.reactionTimes.shift();
                    }
                }
            }
            
            // Achievement System Methods
            loadAchievements() {
                const saved = localStorage.getItem('pongAchievements');
                if (saved) {
                    const savedAchievements = JSON.parse(saved);
                    this.achievements.unlocked = new Set(savedAchievements.unlocked || []);
                }
            }
            
            saveAchievements() {
                const achievementsData = {
                    unlocked: Array.from(this.achievements.unlocked)
                };
                localStorage.setItem('pongAchievements', JSON.stringify(achievementsData));
            }
            
            checkAchievements() {
                Object.keys(this.achievements.definitions).forEach(achievementId => {
                    if (!this.achievements.unlocked.has(achievementId)) {
                        const achievement = this.achievements.definitions[achievementId];
                        try {
                            if (achievement.condition()) {
                                this.unlockAchievement(achievementId);
                            }
                        } catch (e) {
                            // Silently fail if condition check fails
                            console.warn(`Achievement condition failed for ${achievementId}:`, e);
                        }
                    }
                });
            }
            
            unlockAchievement(achievementId) {
                if (!this.achievements.unlocked.has(achievementId)) {
                    this.achievements.unlocked.add(achievementId);
                    this.achievements.newlyUnlocked.push(achievementId);
                    this.saveAchievements();
                    
                    // Show achievement notification
                    this.showAchievementNotification(achievementId);
                }
            }
            
            showAchievementNotification(achievementId) {
                const achievement = this.achievements.definitions[achievementId];
                if (achievement && typeof console !== 'undefined') {
                    console.log(`🏆 Achievement Unlocked: ${achievement.title} - ${achievement.description}`);
                }
            }
            
            getAverageReactionTime() {
                const reactionTimes = this.analytics.playerBehavior.reactionTimes;
                if (reactionTimes.length === 0) return 1000;
                return reactionTimes.reduce((sum, time) => sum + time, 0) / reactionTimes.length;
            }
            
            checkWinStreak(targetStreak) {
                return this.stats.maxWinStreak >= targetStreak;
            }
            
            checkAllPersonalitiesBeaten() {
                const personalities = ['balanced', 'defensive', 'aggressive', 'perfect', 'unpredictable', 'trickster', 'copycat', 'adaptive'];
                return personalities.every(personality => this.stats.personalitiesBeaten.has(personality));
            }
            
            getStats() {
                return {
                    ...this.stats,
                    winRate: this.stats.gamesPlayed > 0 ? (this.stats.gamesWon / this.stats.gamesPlayed * 100).toFixed(1) : 0,
                    averageRally: this.stats.gamesPlayed > 0 ? (this.stats.totalHits / this.stats.gamesPlayed).toFixed(1) : 0
                };
            }
        }

        // ===== GAME INITIALIZATION =====
        let gameEngine, audioSystem, particleSystem, backgroundEffect, heatMapVisualizer;
        let canvas, ctx, lastTime = 0;
        let currentPanel = 'menu';
        let gameSettings = {volume: 0.7, theme: 'neon', particles: true, screenShake: true, ballTrail: true, backgroundEffects: true, backgroundType: 'particles'};

        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            audioSystem = new AudioSystem();
            particleSystem = new ParticleSystem(ctx);
            backgroundEffect = new BackgroundEffect(ctx, canvas);
            gameEngine = new GameEngine(canvas, ctx);
            heatMapVisualizer = new HeatMapVisualizer();
            
            // Initialize heat map visualizer after DOM is ready
            heatMapVisualizer.initialize('heatmapCanvas');
            
            loadSettings();
            
            // Apply background settings after initialization
            backgroundEffect.setEnabled(gameSettings.backgroundEffects);
            backgroundEffect.setEffect(gameSettings.backgroundType);
            
            startGameLoop();
        });

        function startGameLoop() {
            function gameLoop(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw background effects first (behind everything)
                backgroundEffect.update(deltaTime);
                backgroundEffect.draw();
                
                if (gameEngine.screenShake.duration > 0) {
                    ctx.save();
                    ctx.translate(gameEngine.screenShake.x, gameEngine.screenShake.y);
                }
                
                gameEngine.update(deltaTime);
                drawGame();
                particleSystem.update(deltaTime);
                particleSystem.draw();
                
                if (gameEngine.screenShake.duration > 0) ctx.restore();
                
                updateInGameUI();
                requestAnimationFrame(gameLoop);
            }
            requestAnimationFrame(gameLoop);
        }

        function drawGame() {
            if (gameEngine.gameState !== 'playing' && gameEngine.gameState !== 'paused') return;
            
            // Center line
            ctx.setLineDash([5, 15]); ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke();
            ctx.setLineDash([]);
            
            // Ball trail
            if (gameEngine.settings.ballTrail && gameEngine.ball.trail.length > 0) {
                ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.beginPath();
                gameEngine.ball.trail.forEach((point, index) => {
                    const alpha = (gameEngine.ball.trail.length - point.age) / gameEngine.ball.trail.length;
                    ctx.globalAlpha = alpha * 0.5;
                    if (index === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke(); ctx.globalAlpha = 1;
            }
            
            // Paddles & ball with glow
            ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
            ctx.shadowBlur = 10; ctx.fillStyle = '#fff';
            ctx.fillRect(gameEngine.player.x, gameEngine.player.y, gameEngine.player.width, gameEngine.player.height);
            ctx.fillRect(gameEngine.ai.x, gameEngine.ai.y, gameEngine.ai.width, gameEngine.ai.height);
            
            ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
            ctx.shadowBlur = 15;
            ctx.fillRect(gameEngine.ball.x, gameEngine.ball.y, gameEngine.ball.width, gameEngine.ball.height);
            ctx.shadowBlur = 0;
            
            // Scores
            ctx.fillStyle = '#fff'; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center';
            ctx.fillText(gameEngine.player.score, canvas.width / 4, 60);
            ctx.fillText(gameEngine.ai.score, canvas.width * 3/4, 60);
            
            // Power-ups
            gameEngine.powerUps.forEach(powerUp => powerUp.draw(ctx));
            
            // Power-up effect indicators
            if (gameEngine.playerEffects.speedBoost > 0 || gameEngine.playerEffects.sizeChange > 0) {
                ctx.fillStyle = '#ff6b6b'; ctx.shadowBlur = 5; ctx.shadowColor = '#ff6b6b';
                if (gameEngine.playerEffects.speedBoost > 0) ctx.fillText('⚡', gameEngine.player.x, gameEngine.player.y - 10);
                if (gameEngine.playerEffects.sizeChange > 0) ctx.fillText('📏', gameEngine.player.x + 15, gameEngine.player.y - 10);
            }
            if (gameEngine.aiEffects.speedBoost > 0 || gameEngine.aiEffects.sizeChange > 0) {
                ctx.fillStyle = '#4ecdc4'; ctx.shadowBlur = 5; ctx.shadowColor = '#4ecdc4';
                if (gameEngine.aiEffects.speedBoost > 0) ctx.fillText('⚡', gameEngine.ai.x, gameEngine.ai.y - 10);
                if (gameEngine.aiEffects.sizeChange > 0) ctx.fillText('📏', gameEngine.ai.x + 15, gameEngine.ai.y - 10);
            }
            if (gameEngine.playerEffects.freeze > 0) {
                ctx.fillStyle = '#a8e6cf'; ctx.shadowBlur = 5; ctx.shadowColor = '#a8e6cf';
                ctx.fillText('❄️', gameEngine.player.x, gameEngine.player.y - 25);
            }
            if (gameEngine.aiEffects.freeze > 0) {
                ctx.fillStyle = '#a8e6cf'; ctx.shadowBlur = 5; ctx.shadowColor = '#a8e6cf';
                ctx.fillText('❄️', gameEngine.ai.x, gameEngine.ai.y - 25);
            }
            
            // Magnetic effect indicator
            if (gameEngine.magneticEffect > 0) {
                ctx.fillStyle = '#ff69b4'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff69b4';
                ctx.font = '16px Arial'; ctx.textAlign = 'center';
                ctx.fillText('🧲', canvas.width / 2, 30);
                
                // Draw magnetic field lines
                const ballCenterX = gameEngine.ball.x + gameEngine.ball.width / 2;
                const ballCenterY = gameEngine.ball.y + gameEngine.ball.height / 2;
                ctx.strokeStyle = 'rgba(255, 105, 180, 0.3)';
                ctx.lineWidth = 2;
                
                // Lines to player paddle
                const playerCenterX = gameEngine.player.x + gameEngine.player.width / 2;
                const playerCenterY = gameEngine.player.y + gameEngine.player.height / 2;
                const distanceToPlayer = Math.sqrt(Math.pow(ballCenterX - playerCenterX, 2) + Math.pow(ballCenterY - playerCenterY, 2));
                if (distanceToPlayer < 100) {
                    ctx.beginPath();
                    ctx.moveTo(ballCenterX, ballCenterY);
                    ctx.lineTo(playerCenterX, playerCenterY);
                    ctx.stroke();
                }
                
                // Lines to AI paddle
                const aiCenterX = gameEngine.ai.x + gameEngine.ai.width / 2;
                const aiCenterY = gameEngine.ai.y + gameEngine.ai.height / 2;
                const distanceToAI = Math.sqrt(Math.pow(ballCenterX - aiCenterX, 2) + Math.pow(ballCenterY - aiCenterY, 2));
                if (distanceToAI < 100) {
                    ctx.beginPath();
                    ctx.moveTo(ballCenterX, ballCenterY);
                    ctx.lineTo(aiCenterX, aiCenterY);
                    ctx.stroke();
                }
            }
            
            ctx.shadowBlur = 0;
            
            // Lives in survival mode
            if (gameEngine.gameMode === 'survival') {
                ctx.font = '20px Arial'; ctx.fillStyle = '#ff6b6b'; ctx.textAlign = 'left';
                ctx.fillText('❤️'.repeat(gameEngine.player.lives), 20, canvas.height - 20);
            }
            
            // Pause overlay
            if (gameEngine.gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 36px Arial'; ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
            
            // Game over overlay
            if (gameEngine.gameState === 'gameOver') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                const winner = gameEngine.player.score >= gameEngine.settings.winScore ? 'PLAYER WINS!' : 'AI WINS!';
                const color = gameEngine.player.score >= gameEngine.settings.winScore ? '#4ecdc4' : '#ff6b6b';
                ctx.fillStyle = color; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center';
                ctx.fillText(winner, canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = '#fff'; ctx.font = '20px Arial';
                ctx.fillText('Restarting in 3 seconds...', canvas.width / 2, canvas.height / 2 + 60);
            }
        }

        // ===== UI FUNCTIONS =====
        function showPanel(panelName) {
            ['gameMenu', 'settingsPanel', 'statsPanel', 'helpPanel', 'aboutPanel', 'inGameUI', 'heatmapPanel', 'mlstatsPanel'].forEach(id => 
                document.getElementById(id).style.display = 'none');
            
            currentPanel = panelName;
            
            switch (panelName) {
                case 'menu': document.getElementById('gameMenu').style.display = 'block'; gameEngine.gameState = 'menu'; break;
                case 'settings': document.getElementById('settingsPanel').style.display = 'block'; updateSettingsUI(); break;
                case 'stats': updateStatsPanel(); document.getElementById('statsPanel').style.display = 'block'; break;
                case 'help': document.getElementById('helpPanel').style.display = 'block'; break;
                case 'about': document.getElementById('aboutPanel').style.display = 'block'; break;
                case 'game': document.getElementById('inGameUI').style.display = 'block'; break;
                case 'heatmap': 
                    document.getElementById('heatmapPanel').style.display = 'block'; 
                    // Initialize heat map when panel is shown
                    setTimeout(() => updateHeatMap(), 100);
                    break;
                case 'mlstats':
                    document.getElementById('mlstatsPanel').style.display = 'block';
                    updateMLStatsPanel();
                    break;
            }
            audioSystem?.play('menuClick');
        }

        function startGame(mode) {
            gameEngine.setGameMode(mode);
            gameEngine.gameState = 'playing';
            showPanel('game');
            document.getElementById('gameModeDisplay').textContent = mode.toUpperCase() + ' MODE';
            audioSystem?.play('gameStart');
        }

        function changeDifficulty(difficulty) {
            gameEngine.ai.difficulty = difficulty;
            audioSystem?.play('menuClick');
        }

        function changePersonality(personality) {
            gameEngine.setAIPersonality(personality);
            audioSystem?.play('menuClick');
        }

        function updateVolume(value) {
            document.getElementById('volumeValue').textContent = value + '%';
            audioSystem.volume = value / 100;
        }

        function changeTheme(theme) {
            gameSettings.theme = theme;
            applyTheme(theme);
            audioSystem?.play('menuClick');
        }

        function toggleParticles(enabled) {
            gameSettings.particles = enabled;
            gameEngine.settings.particles = enabled;
            particleSystem.enabled = enabled;
            audioSystem?.play('menuClick');
        }

        function toggleScreenShake(enabled) {
            gameSettings.screenShake = enabled;
            gameEngine.settings.screenShake = enabled;
            audioSystem?.play('menuClick');
        }

        function toggleBallTrail(enabled) {
            gameSettings.ballTrail = enabled;
            gameEngine.settings.ballTrail = enabled;
            audioSystem?.play('menuClick');
        }

        function toggleMute(muted) {
            audioSystem.muted = muted;
        }
        
        function toggleBackgroundEffects(enabled) {
            gameSettings.backgroundEffects = enabled;
            backgroundEffect.setEnabled(enabled);
            audioSystem?.play('menuClick');
        }
        
        function changeBackgroundType(type) {
            gameSettings.backgroundType = type;
            backgroundEffect.setEffect(type);
            audioSystem?.play('menuClick');
        }

        function saveSettings() {
            localStorage.setItem('enhancedPongSettings', JSON.stringify(gameSettings));
            audioSystem?.play('menuClick');
        }

        function loadSettings() {
            const saved = localStorage.getItem('enhancedPongSettings');
            if (saved) gameSettings = { ...gameSettings, ...JSON.parse(saved) };
            applyTheme(gameSettings.theme);
            
            // Apply background settings
            if (backgroundEffect) {
                backgroundEffect.setEnabled(gameSettings.backgroundEffects);
                backgroundEffect.setEffect(gameSettings.backgroundType);
            }
        }

        function updateSettingsUI() {
            document.getElementById('volumeSlider').value = gameSettings.volume * 100;
            document.getElementById('volumeValue').textContent = Math.round(gameSettings.volume * 100) + '%';
            document.getElementById('themeSelect').value = gameSettings.theme;
            document.getElementById('particlesCheck').checked = gameSettings.particles;
            document.getElementById('shakeCheck').checked = gameSettings.screenShake;
            document.getElementById('trailCheck').checked = gameSettings.ballTrail;
            document.getElementById('backgroundCheck').checked = gameSettings.backgroundEffects;
            document.getElementById('backgroundTypeSelect').value = gameSettings.backgroundType;
        }

        function updateStatsPanel() {
            const stats = gameEngine.getStats();
            document.getElementById('statsContent').innerHTML = `
                <div class="stats-grid">
                    <div>
                        <h3>🎮 Games</h3>
                        <p>Played: <strong>${stats.gamesPlayed}</strong></p>
                        <p>Won: <strong style="color: #4ecdc4;">${stats.gamesWon}</strong></p>
                        <p>Lost: <strong style="color: #ff6b6b;">${stats.gamesLost}</strong></p>
                        <p>Win Rate: <strong>${stats.winRate}%</strong></p>
                    </div>
                    <div>
                        <h3>🏆 Records</h3>
                        <p>Longest Rally: <strong>${stats.longestRally}</strong></p>
                        <p>Total Hits: <strong>${stats.totalHits}</strong></p>
                        <p>Perfect Games: <strong>${stats.perfectGames}</strong></p>
                        <p>Average Rally: <strong>${stats.averageRally}</strong></p>
                    </div>
                </div>
            `;
        }

        function clearStats() {
            if (confirm('Clear all statistics?')) {
                gameEngine.stats = {gamesPlayed: 0, gamesWon: 0, gamesLost: 0, longestRally: 0, 
                                 currentRally: 0, totalHits: 0, perfectGames: 0};
                gameEngine.saveStats(); updateStatsPanel();
                audioSystem?.play('menuClick');
            }
        }

        function applyTheme(theme) {
            document.body.className = 'theme-' + theme;
            const themes = {
                neon: {bg: 'linear-gradient(135deg, #1e3c72, #2a5298)', primary: '#4ecdc4', secondary: '#ff6b6b'},
                retro: {bg: 'linear-gradient(135deg, #2d1b69, #11998e)', primary: '#f38ba8', secondary: '#a6e3a1'},
                classic: {bg: 'linear-gradient(135deg, #000000, #434343)', primary: '#ffffff', secondary: '#cccccc'},
                cyberpunk: {bg: 'linear-gradient(135deg, #0f0f0f, #1a0033)', primary: '#ff0080', secondary: '#00ff80'},
                synthwave: {bg: 'linear-gradient(135deg, #2d1b4e, #ff006e, #8338ec)', primary: '#ff006e', secondary: '#8338ec'},
                ocean: {bg: 'linear-gradient(135deg, #0f3460, #16537e, #005c98)', primary: '#00d4ff', secondary: '#0099cc'},
                forest: {bg: 'linear-gradient(135deg, #0f2027, #203a43, #2c5530)', primary: '#66ff66', secondary: '#44cc44'},
                sunset: {bg: 'linear-gradient(135deg, #f2994a, #f2c94c, #eb5757)', primary: '#f2994a', secondary: '#eb5757'},
                galaxy: {bg: 'linear-gradient(135deg, #1a0033, #330066, #660099)', primary: '#cc66ff', secondary: '#9933ff'},
                volcanic: {bg: 'linear-gradient(135deg, #1a0000, #cc0000, #ff3300)', primary: '#ff6600', secondary: '#ff3300'},
                arctic: {bg: 'linear-gradient(135deg, #e6f7ff, #b3e5fc, #81d4fa)', primary: '#0066cc', secondary: '#0099ff'},
                matrix: {bg: 'linear-gradient(135deg, #000000, #003300, #006600)', primary: '#00ff00', secondary: '#66ff66'},
                crimson: {bg: 'linear-gradient(135deg, #330000, #660000, #990000)', primary: '#ff3366', secondary: '#cc0033'},
                highcontrast: {bg: 'linear-gradient(135deg, #ffffff, #f0f0f0)', primary: '#000000', secondary: '#333333'},
                protanopia: {bg: 'linear-gradient(135deg, #0066cc, #004499)', primary: '#ffaa00', secondary: '#0088ff'},
                deuteranopia: {bg: 'linear-gradient(135deg, #cc6600, #994400)', primary: '#0066ff', secondary: '#ffcc00'}
            };
            const t = themes[theme] || themes.neon;
            document.body.style.background = t.bg;
            document.documentElement.style.setProperty('--primary-color', t.primary);
            document.documentElement.style.setProperty('--secondary-color', t.secondary);
        }

        function pauseGame() {
            if (gameEngine.gameState === 'playing') {
                gameEngine.gameState = 'paused';
                event.target.textContent = '▶️ Resume';
            } else if (gameEngine.gameState === 'paused') {
                gameEngine.gameState = 'playing';
                event.target.textContent = '⏸️ Pause';
            }
            audioSystem?.play('menuClick');
        }

        function updateInGameUI() {
            if (document.getElementById('inGameUI').style.display !== 'none') {
                document.getElementById('livesCount').textContent = gameEngine.player.lives;
                document.getElementById('rallyCount').textContent = gameEngine.stats.currentRally;
            }
        }
        
        // ===== HEAT MAP FUNCTIONS =====
        function updateHeatMap() {
            if (!heatMapVisualizer || !gameEngine) return;
            
            const heatmapType = document.getElementById('heatmapTypeSelect').value;
            let stats = null;
            
            switch (heatmapType) {
                case 'playerHits':
                    stats = heatMapVisualizer.drawPlayerHits(gameEngine.analytics);
                    displayHeatMapStats(stats, 'Player Paddle Hits');
                    break;
                    
                case 'aiHits':
                    stats = heatMapVisualizer.drawAIHits(gameEngine.analytics);
                    displayHeatMapStats(stats, 'AI Paddle Hits');
                    break;
                    
                case 'ballTrajectory':
                    stats = heatMapVisualizer.drawBallTrajectory(gameEngine.analytics);
                    displayHeatMapStats(stats, 'Ball Trajectory', 'totalSamples');
                    break;
                    
                case 'playerMovement':
                    stats = heatMapVisualizer.drawPlayerMovement(gameEngine.playerMovementSamples);
                    displayHeatMapStats(stats, 'Player Movement', 'totalSamples');
                    break;
                    
                case 'combined':
                    stats = heatMapVisualizer.drawCombined(gameEngine.analytics, gameEngine.playerMovementSamples);
                    displayCombinedHeatMapStats(stats);
                    break;
                    
                default:
                    document.getElementById('heatmapStats').innerHTML = '<p>Select a heat map type to view data.</p>';
            }
        }
        
        function displayHeatMapStats(stats, title, countKey = 'totalHits') {
            if (!stats) {
                document.getElementById('heatmapStats').innerHTML = `
                    <h3>${title}</h3>
                    <p>No data available yet. Play some games to generate heat map data!</p>
                `;
                return;
            }
            
            const count = stats[countKey] || 0;
            const avgIntensity = stats.avgIntensity || '0.00';
            const maxIntensity = stats.maxIntensity || 0;
            
            let extraStats = '';
            if (stats.avgPosition !== undefined) {
                extraStats = `<p><strong>Average Position:</strong> ${Math.round(stats.avgPosition)}px</p>`;
            }
            
            document.getElementById('heatmapStats').innerHTML = `
                <h3>📊 ${title}</h3>
                <p><strong>Total Points:</strong> ${count}</p>
                <p><strong>Average Intensity:</strong> ${avgIntensity}</p>
                <p><strong>Max Intensity:</strong> ${maxIntensity}</p>
                ${extraStats}
            `;
        }
        
        function displayCombinedHeatMapStats(stats) {
            if (!stats) {
                document.getElementById('heatmapStats').innerHTML = `
                    <h3>🌈 Combined View</h3>
                    <p>No data available yet. Play some games to generate heat map data!</p>
                `;
                return;
            }
            
            document.getElementById('heatmapStats').innerHTML = `
                <h3>📊 Combined Heat Map</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 12px;">
                    <div>
                        <p><strong>🔴 Player Hits:</strong> ${stats.playerHits || 0}</p>
                        <p><strong>🔵 AI Hits:</strong> ${stats.aiHits || 0}</p>
                    </div>
                    <div>
                        <p><strong>🟢 Ball Samples:</strong> ${stats.ballSamples || 0}</p>
                        <p><strong>Max Intensity:</strong> ${stats.maxIntensity || 0}</p>
                    </div>
                </div>
                <p style="margin-top: 10px; font-size: 11px; color: #aaa;">
                    🔴 Red = Player hits, 🔵 Blue = AI hits, 🟢 Green = Ball trajectory
                </p>
            `;
        }
        
        function clearHeatMapData() {
            if (confirm('Clear all heat map data? This will reset hit locations, ball trajectories, and movement patterns.')) {
                // Clear analytics heat map data
                gameEngine.analytics.heatMap = {
                    playerHits: [],
                    aiHits: [],
                    ballTrajectories: [],
                    scoringZones: []
                };
                
                // Clear movement samples
                gameEngine.playerMovementSamples = [];
                
                // Save the cleared analytics
                gameEngine.saveAnalytics();
                
                // Refresh the current heat map view
                updateHeatMap();
                
                audioSystem?.play('menuClick');
            }
        }
        
        // ===== ML AI STATS FUNCTIONS =====
        function updateMLStatsPanel() {
            if (!gameEngine || !gameEngine.mlAI) {
                document.getElementById('mlstatsContent').innerHTML = `
                    <p>ML AI system not available.</p>
                `;
                return;
            }
            
            const stats = gameEngine.mlAI.getLearningStats();
            
            if (stats.gamesAnalyzed === 0) {
                document.getElementById('mlstatsContent').innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <p><strong>🤖 Machine Learning AI</strong></p>
                        <p>No learning data yet. Play some games with the <strong>🧠 Adaptive</strong> AI personality to start generating learning statistics.</p>
                        <p style="font-size: 12px; color: #aaa; margin-top: 15px;">The ML AI analyzes your gameplay patterns and adapts its strategy accordingly. It needs at least 3 games to start learning effectively.</p>
                    </div>
                `;
                return;
            }
            
            const confidenceColor = stats.confidence >= 70 ? '#4ecdc4' : stats.confidence >= 40 ? '#ffd54f' : '#ff6b6b';
            const strategyEmoji = {
                'balanced': '⚖️',
                'exploit': '🎯', 
                'challenge': '🏋️'
            };
            
            document.getElementById('mlstatsContent').innerHTML = `
                <div style="font-size: 14px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <h3 style="color: var(--primary-color); margin-bottom: 10px;">🧠 Learning Progress</h3>
                            <p><strong>Games Analyzed:</strong> ${stats.gamesAnalyzed}</p>
                            <p><strong>Confidence Level:</strong> <span style="color: ${confidenceColor};">${stats.confidence}%</span></p>
                            <p><strong>Data Points:</strong> ${stats.totalDataPoints}</p>
                            <p><strong>Current Strategy:</strong> ${strategyEmoji[stats.strategy] || '⚖️'} ${stats.strategy.charAt(0).toUpperCase() + stats.strategy.slice(1)}</p>
                        </div>
                        <div>
                            <h3 style="color: var(--secondary-color); margin-bottom: 10px;">🎮 Player Profile</h3>
                            <p><strong>Favorite Position:</strong> ${stats.playerTendencies.favoritePosition}px</p>
                            <p><strong>Movement Consistency:</strong> ${stats.playerTendencies.consistency}%</p>
                            <p><strong>Defensive Ratio:</strong> ${stats.playerTendencies.defensiveRatio}%</p>
                            <p><strong>Avg Reaction Time:</strong> ${stats.playerTendencies.avgReactionTime}ms</p>
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; font-size: 12px;">
                        <h4 style="margin-top: 0; color: var(--primary-color);">🔬 How ML AI Works</h4>
                        <p><strong>Learning:</strong> The AI tracks your movement patterns, reaction times, defensive zones, and successful hits.</p>
                        <p><strong>Analysis:</strong> After each game, it analyzes your tendencies to find patterns and weaknesses.</p>
                        <p><strong>Adaptation:</strong> It adjusts its targeting, speed, and strategy based on your play style and performance.</p>
                        <p><strong>Strategy Types:</strong></p>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li><strong>⚖️ Balanced:</strong> Mixed approach based on your skill level</li>
                            <li><strong>🎯 Exploit:</strong> Targets your weak spots when you're performing well</li>
                            <li><strong>🏋️ Challenge:</strong> Provides good practice when you're struggling</li>
                        </ul>
                        <p style="margin-top: 10px; font-style: italic;">The more you play with Adaptive AI, the better it becomes at providing the right level of challenge!</p>
                    </div>
                </div>
            `;
        }
        
        function resetMLAI() {
            if (confirm('Reset all Machine Learning AI data? This will clear all learned patterns and start fresh.')) {
                if (gameEngine && gameEngine.mlAI) {
                    gameEngine.mlAI.resetLearning();
                    updateMLStatsPanel(); // Refresh the display
                    audioSystem?.play('menuClick');
                } else {
                    console.warn('ML AI system not available');
                }
            }
        }
        
        // ===== CACHE CLEAR FUNCTION =====
        function clearGameCache() {
            if (confirm('Clear ALL game data? This will reset everything including:\n\n• Game statistics and records\n• Heat map data\n• Machine Learning AI data\n• Settings and preferences\n• Achievement progress\n\nThis action cannot be undone. Continue?')) {
                try {
                    // Clear all localStorage items
                    localStorage.removeItem('pongStats');
                    localStorage.removeItem('pongAnalytics');
                    localStorage.removeItem('pongMLAI');
                    localStorage.removeItem('pongAchievements');
                    localStorage.removeItem('enhancedPongSettings');
                    
                    // Reset game engine if available
                    if (gameEngine) {
                        // Reset stats
                        gameEngine.stats = {gamesPlayed: 0, gamesWon: 0, gamesLost: 0, longestRally: 0, 
                                         currentRally: 0, totalHits: 0, perfectGames: 0, powerUpsCollected: 0,
                                         survivalWins: 0, speedballWins: 0, personalitiesBeaten: new Set(),
                                         currentWinStreak: 0, maxWinStreak: 0, comebacks: 0, totalPlayTime: 0};
                        
                        // Reset analytics
                        gameEngine.analytics = {
                            playerBehavior: {
                                movementPattern: [],
                                reactionTimes: [],
                                hitZones: [],
                                averagePosition: 0,
                                defensiveStyle: 0,
                                consistency: 0
                            },
                            heatMap: {
                                playerHits: [],
                                aiHits: [],
                                ballTrajectories: [],
                                scoringZones: []
                            },
                            gameFlow: {
                                rallyLengths: [],
                                gameRhythm: [],
                                intensityMoments: [],
                                comebackAttempts: 0
                            },
                            aiLearning: {
                                playerPreferences: {},
                                successfulStrategies: [],
                                adaptationLevel: 0
                            }
                        };
                        
                        // Reset ML AI
                        if (gameEngine.mlAI) {
                            gameEngine.mlAI.resetLearning();
                        }
                        
                        // Reset achievements
                        gameEngine.achievements.unlocked = new Set();
                        gameEngine.achievements.newlyUnlocked = [];
                        
                        // Clear movement samples
                        gameEngine.playerMovementSamples = [];
                        gameEngine.ballPositionSamples = [];
                    }
                    
                    // Reset settings to defaults
                    gameSettings = {volume: 0.7, theme: 'neon', particles: true, screenShake: true, 
                                  ballTrail: true, backgroundEffects: true, backgroundType: 'particles'};
                    
                    // Apply default theme
                    applyTheme('neon');
                    
                    // Update UI to reflect changes
                    updateSettingsUI();
                    
                    // Reload page to ensure clean state
                    setTimeout(() => {
                        alert('Cache cleared successfully! The page will reload to apply changes.');
                        location.reload();
                    }, 500);
                    
                    audioSystem?.play('menuClick');
                    
                } catch (error) {
                    console.error('Error clearing cache:', error);
                    alert('Error clearing cache. Please try again or refresh the page manually.');
                }
            }
        }

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('../sw.js')
                    .then(registration => console.log('SW registered:', registration.scope))
                    .catch(error => console.error('SW registration failed:', error));
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
        });
    </script>
</body>
</html>